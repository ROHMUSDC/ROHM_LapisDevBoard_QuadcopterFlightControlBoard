;; Compile Options : /TML610112 /MS /near /Icommon /Imain /Iirq /Itimer /Iclock /Itbc /Iuart /Ii2c /SS 256 /SD /Oa /Ot /W 3 /Wc /Fa_output\_obj\ 
;; Version Number  : Ver.3.41.8
;; File Name       : main.c

	type (ML610112) 
	model small, near
	$$NVARmain segment data 2h #0h
	$$NINITVAR segment data 2h #0h
	$$NINITTAB segment table 2h any
	$$AccelGyroDataReady_ISR$main segment code 2h #0h
	$$AccelSensorControlPID_D$main segment code 2h #0h
	$$AccelSensorControlPID_I$main segment code 2h #0h
	$$AccelSensorControlPID_P$main segment code 2h #0h
	$$CalibrateAccel$main segment code 2h #0h
	$$CalibrateGyro$main segment code 2h #0h
	$$CalibrateMotors$main segment code 2h #0h
	$$CheckSafetyLimit$main segment code 2h #0h
	$$CheckSafetyLimitUnscaled$main segment code 2h #0h
	$$ClearVariables$main segment code 2h #0h
	$$DistanceSensorControl$main segment code 2h #0h
	$$ESC1_PWM$main segment code 2h #0h
	$$ESC2_PWM$main segment code 2h #0h
	$$ESC3_PWM$main segment code 2h #0h
	$$ESC4_PWM$main segment code 2h #0h
	$$Emit_Warning$main segment code 2h #0h
	$$Get_AccGyroData$main segment code 2h #0h
	$$Get_MagData$main segment code 2h #0h
	$$Get_PingData$main segment code 2h #0h
	$$Get_RangeData$main segment code 2h #0h
	$$Initialization$main segment code 2h #0h
	$$InitializeTone$main segment code 2h #0h
	$$MagSensorControl$main segment code 2h #0h
	$$MagSensorControlPID$main segment code 2h #0h
	$$NOP$main segment code 2h #0h
	$$NOP1000$main segment code 2h #0h
	$$NOPms$main segment code 2h #0h
	$$NOPus$main segment code 2h #0h
	$$PortA_Digital_Inputs$main segment code 2h #0h
	$$PortA_Low$main segment code 2h #0h
	$$PortB_Low$main segment code 2h #0h
	$$PortC_Low$main segment code 2h #0h
	$$PortD_Low$main segment code 2h #0h
	$$RampUpMotorTest$main segment code 2h #0h
	$$RangeSensorControlPID$main segment code 2h #0h
	$$ReturnAccelData$main segment code 2h #0h
	$$ReturnMagData$main segment code 2h #0h
	$$ReturnSensorData$main segment code 2h #0h
	$$Run_AccGyroCF$main segment code 2h #0h
	$$SerialOutCoefficients$main segment code 2h #0h
	$$SetOSC$main segment code 2h #0h
	$$Shutdown$main segment code 2h #0h
	$$SoftStart$main segment code 2h #0h
	$$TAB$$S243$main segment table 2h #0h
	$$TAB$$S256$main segment table 2h #0h
	$$TAB$$S269$main segment table 2h #0h
	$$TAB$$S287$main segment table 2h #0h
	$$TAB$$S316$main segment table 2h #0h
	$$TAB$$S332$main segment table 2h #0h
	$$TAB$$S363$main segment table 2h #0h
	$$TAB$$S388$main segment table 2h #0h
	$$TAB$$S413$main segment table 2h #0h
	$$TAB$$S435$main segment table 2h #0h
	$$TAB$$S491$main segment table 2h #0h
	$$TAB$$S569$main segment table 2h #0h
	$$TAB_uartSetParam$main segment table 2h #0h
	$$TBC_ISR$main segment code 2h #0h
	$$TMR89_ISR$main segment code 2h #0h
	$$UARTTunePID$main segment code 2h #0h
	$$_funcI2CFin$main segment code 2h #0h
	$$_funcUartFin$main segment code 2h #0h
	$$_intI2c$main segment code 2h #0h
	$$_intUart$main segment code 2h #0h
	$$analog_comparator$main segment code 2h #0h
	$$approx_arctan2$main segment code 2h #0h
	$$checkI2C$main segment code 2h #0h
	$$main$main segment code 2h #0h
	$$main_clrWDT$main segment code 2h #0h
	$$main_reqNotHalt$main segment code 2h #0h
	STACKSEG 0100h
CVERSION 3.41.8
CGLOBAL 01H 03H 0000H "AccelSensorControlPID_D" 08H 02H 0F0H 00H 81H 1aH 00H 00H 07H
CGLOBAL 01H 03H 0000H "AccelSensorControlPID_I" 08H 02H 0EFH 00H 81H 16H 00H 00H 07H
CGLOBAL 01H 03H 0000H "AccelSensorControlPID_P" 08H 02H 0EEH 00H 81H 0eH 00H 00H 07H
CGLOBAL 01H 03H 0000H "Shutdown" 08H 02H 0F4H 00H 81H 02H 00H 00H 07H
CSGLOBAL 03H 0000H "TBC_ISR" 08H 02H 00H 01H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "NOPms" 08H 02H 0FCH 00H 81H 0aH 00H 00H 07H
CGLOBAL 01H 03H 0000H "NOPus" 08H 02H 0FDH 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "approx_arctan2" 08H 02H 0FFH 00H 83H 40H 00H 00H 03H
CGLOBAL 01H 03H 0000H "checkI2C" 08H 02H 0F7H 00H 81H 02H 00H 00H 07H
CGLOBAL 01H 03H 0000H "main_clrWDT" 08H 02H 0CEH 00H 80H 00H 00H 00H 07H
CSGLOBAL 03H 0000H "_funcUartFin" 08H 02H 0F5H 00H 81H 02H 00H 00H 07H
CGLOBAL 01H 03H 0000H "main_reqNotHalt" 08H 02H 0F8H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "ReturnMagData" 08H 02H 0E3H 00H 81H 0eH 00H 00H 07H
CGLOBAL 01H 03H 0000H "DistanceSensorControl" 08H 02H 0EBH 00H 81H 0aH 00H 00H 07H
CSGLOBAL 03H 0000H "Initialization" 08H 02H 0CFH 00H 81H 0aH 00H 00H 07H
CGLOBAL 01H 03H 0000H "RangeSensorControlPID" 08H 02H 0F1H 00H 81H 20H 00H 00H 07H
CGLOBAL 01H 03H 0000H "PortA_Digital_Inputs" 08H 02H 0D6H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "MagSensorControl" 08H 02H 0ECH 00H 81H 0aH 00H 00H 07H
CGLOBAL 01H 03H 0000H "ESC2_PWM" 08H 02H 0D8H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "Get_AccGyroData" 08H 02H 0DDH 00H 81H 10H 00H 00H 07H
CGLOBAL 01H 03H 0000H "main" 08H 02H 05H 01H 80H 00H 00H 00H 01H
CGLOBAL 01H 03H 0000H "MagSensorControlPID" 08H 02H 0EDH 00H 81H 2aH 00H 00H 07H
CSGLOBAL 03H 0000H "_intUart" 08H 02H 0F9H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "ClearVariables" 08H 02H 0E0H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "PortD_Low" 08H 02H 0D5H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "NOP1000" 08H 02H 0FEH 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "ESC1_PWM" 08H 02H 0D7H 00H 80H 00H 00H 00H 07H
CSGLOBAL 03H 0000H "_intI2c" 08H 02H 0FAH 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "CheckSafetyLimitUnscaled" 08H 02H 0F3H 00H 80H 00H 00H 00H 07H
CSGLOBAL 03H 0000H "SetOSC" 08H 02H 0D0H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "CalibrateAccel" 08H 02H 0E6H 00H 81H 0cH 00H 00H 07H
CSGLOBAL 03H 0000H "AccelGyroDataReady_ISR" 08H 02H 02H 01H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "Get_RangeData" 08H 02H 0DBH 00H 81H 0aH 00H 00H 07H
CGLOBAL 01H 03H 0000H "PortC_Low" 08H 02H 0D4H 00H 80H 00H 00H 00H 07H
CSGLOBAL 03H 0000H "TMR89_ISR" 08H 02H 01H 01H 81H 0aH 00H 00H 07H
CGLOBAL 01H 03H 0000H "CheckSafetyLimit" 08H 02H 0F2H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "ESC4_PWM" 08H 02H 0DAH 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "Get_MagData" 08H 02H 0DFH 00H 83H 28H 00H 00H 07H
CGLOBAL 01H 03H 0000H "UARTTunePID" 08H 02H 0E8H 00H 81H 32H 00H 00H 07H
CGLOBAL 01H 03H 0000H "Get_PingData" 08H 02H 0DCH 00H 81H 16H 00H 00H 07H
CGLOBAL 01H 03H 0000H "SerialOutCoefficients" 08H 02H 0E7H 00H 81H 32H 00H 00H 07H
CGLOBAL 01H 03H 0000H "PortB_Low" 08H 02H 0D3H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "CalibrateMotors" 08H 02H 0E4H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "ReturnAccelData" 08H 02H 0E2H 00H 81H 0cH 00H 00H 07H
CGLOBAL 01H 03H 0000H "ESC3_PWM" 08H 02H 0D9H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "CalibrateGyro" 08H 02H 0E5H 00H 81H 0cH 00H 00H 07H
CGLOBAL 01H 03H 0000H "RampUpMotorTest" 08H 02H 0EAH 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "NOP" 08H 02H 0FBH 00H 81H 08H 00H 00H 07H
CGLOBAL 01H 03H 0000H "Emit_Warning" 08H 02H 03H 01H 81H 04H 00H 00H 07H
CGLOBAL 01H 03H 0000H "InitializeTone" 08H 02H 04H 01H 81H 04H 00H 00H 07H
CGLOBAL 01H 03H 0000H "PortA_Low" 08H 02H 0D2H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "analog_comparator" 08H 02H 0D1H 00H 80H 00H 00H 00H 07H
CGLOBAL 01H 03H 0000H "Run_AccGyroCF" 08H 02H 0DEH 00H 83H 20H 00H 00H 07H
CSGLOBAL 03H 0000H "_funcI2CFin" 08H 02H 0F6H 00H 81H 02H 00H 00H 07H
CGLOBAL 01H 03H 0000H "SoftStart" 08H 02H 0E9H 00H 81H 02H 00H 00H 07H
CGLOBAL 01H 03H 0000H "ReturnSensorData" 08H 02H 0E1H 00H 81H 2eH 00H 00H 07H
CSTRUCTTAG 0000H 0000H 0005H 000CH 00000016H "_Notag"
CSTRUCTMEM 42H 00000002H 00000000H "_Mode" 02H 00H 08H
CSTRUCTMEM 43H 00000002H 00000002H "_Handle" 02H 00H 08H
CSTRUCTMEM 42H 00000002H 00000004H "_Buf" 04H 03H 00H 00H 00H
CSTRUCTMEM 42H 00000002H 00000006H "_Bend" 04H 03H 00H 00H 00H
CSTRUCTMEM 42H 00000002H 00000008H "_Next" 04H 03H 00H 00H 00H
CSTRUCTMEM 42H 00000002H 0000000AH "_Rend" 04H 03H 00H 00H 00H
CSTRUCTMEM 42H 00000002H 0000000CH "_Rsave" 04H 03H 00H 00H 00H
CSTRUCTMEM 42H 00000002H 0000000EH "_Wend" 04H 03H 00H 00H 00H
CSTRUCTMEM 42H 00000002H 00000010H "_Back" 05H 01H 02H 00H 00H 00H
CSTRUCTMEM 42H 00000001H 00000012H "_Cbuf" 02H 00H 00H
CSTRUCTMEM 42H 00000001H 00000013H "_Nback" 02H 00H 00H
CSTRUCTMEM 43H 00000002H 00000014H "_Tmpnam" 04H 03H 00H 00H 00H
CSTRUCTTAG 0000H 0000H 0004H 0001H 00000004H "_Notag"
CSTRUCTMEM 42H 00000004H 00000000H "_Off" 02H 00H 02H
CSTRUCTTAG 0000H 0000H 0003H 0006H 0000000AH "_Notag"
CSTRUCTMEM 42H 00000004H 00000000H "br" 02H 00H 02H
CSTRUCTMEM 42H 00000001H 00000004H "lg" 02H 00H 00H
CSTRUCTMEM 42H 00000001H 00000005H "pt" 02H 00H 00H
CSTRUCTMEM 42H 00000001H 00000006H "stp" 02H 00H 00H
CSTRUCTMEM 42H 00000001H 00000007H "neg" 02H 00H 00H
CSTRUCTMEM 42H 00000001H 00000008H "dir" 02H 00H 00H
CSTRUCTTAG 0000H 0000H 0002H 0002H 00000008H "_Notag"
CSTRUCTMEM 43H 00000004H 00000000H "quot" 02H 00H 02H
CSTRUCTMEM 43H 00000004H 00000004H "rem" 02H 00H 02H
CSTRUCTTAG 0000H 0000H 0001H 0002H 00000004H "_Notag"
CSTRUCTMEM 43H 00000002H 00000000H "quot" 02H 00H 01H
CSTRUCTMEM 43H 00000002H 00000002H "rem" 02H 00H 01H
CSTRUCTTAG 0000H 0000H 0000H 0008H 00000001H "_Notag"
CSTRUCTMEM 52H 00000001H 00000000H "b0" 02H 00H 00H
CSTRUCTMEM 52H 00000001H 00000001H "b1" 02H 00H 00H
CSTRUCTMEM 52H 00000001H 00000002H "b2" 02H 00H 00H
CSTRUCTMEM 52H 00000001H 00000003H "b3" 02H 00H 00H
CSTRUCTMEM 52H 00000001H 00000004H "b4" 02H 00H 00H
CSTRUCTMEM 52H 00000001H 00000005H "b5" 02H 00H 00H
CSTRUCTMEM 52H 00000001H 00000006H "b6" 02H 00H 00H
CSTRUCTMEM 52H 00000001H 00000007H "b7" 02H 00H 00H
CUNIONTAG 0000H 0000H 0006H 0002H 00000008H "_Notag"
CUNIONMEM 42H 00000008H "_W" 05H 01H 04H 00H 00H 08H
CUNIONMEM 43H 00000008H "_D" 02H 00H 04H
CTYPEDEF 0000H 0000H 01H "_Dconst" 04H 00H 06H 06H 00H
CTYPEDEF 0000H 0000H 43H "_Ptrdifft" 02H 00H 01H
CTYPEDEF 0000H 0000H 42H "_Sizet" 02H 00H 01H
CTYPEDEF 0000H 0000H 43H "tUartSetParam" 04H 00H 05H 03H 00H
CTYPEDEF 0000H 0000H 42H "size_t" 02H 00H 01H
CTYPEDEF 0000H 0000H 43H "cbfUart" 0AH 03H 00H 02H 2EH 00H 00H 00H 00H 00H 07H
CTYPEDEF 0000H 0000H 43H "fpos_t" 04H 00H 05H 04H 00H
CTYPEDEF 0000H 0000H 43H "cbfI2c" 0AH 03H 00H 02H 43H 00H 00H 00H 00H 00H 07H
CTYPEDEF 0000H 0000H 03H "_Cmpfun_nf" 08H 02H 01H 00H 00H 00H 00H 00H 01H
CTYPEDEF 0000H 0000H 03H "_Cmpfun_nn" 08H 02H 00H 00H 00H 00H 00H 00H 01H
CTYPEDEF 0000H 0000H 03H "_Cmpfun_ff" 08H 02H 03H 00H 00H 00H 00H 00H 01H
CTYPEDEF 0000H 0000H 03H "_Cmpfun_fn" 08H 02H 02H 00H 00H 00H 00H 00H 01H
CTYPEDEF 0000H 0000H 43H "FILE" 04H 00H 05H 05H 00H
CTYPEDEF 0000H 0000H 43H "div_t" 04H 00H 05H 01H 00H
CTYPEDEF 0000H 0000H 43H "ldiv_t" 04H 00H 05H 02H 00H
CTYPEDEF 0000H 0000H 43H "_BYTE_FIELD" 04H 00H 05H 00H 00H
CSGLOBAL 43H 0004H "CF_LPF" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_OpposingPole" 02H 00H 03H
CSGLOBAL 42H 0001H "AccGyro_GyroAccel_SMPRTDIV" 02H 00H 00H
CSGLOBAL 43H 0004H "Mag_PIDOutput" 02H 00H 03H
CSGLOBAL 42H 0008H "RecWorld" 05H 01H 08H 00H 00H 00H
CGLOBAL 00H 42H 0001H "_flgUartFin" 02H 00H 00H
CSGLOBAL 42H 0002H "Accel_PID_Motor4" 02H 00H 01H
CSGLOBAL 42H 0002H "Accel_PID_Motor1" 02H 00H 01H
CSGLOBAL 42H 0002H "Accel_PID_Motor2" 02H 00H 01H
CSGLOBAL 42H 0002H "Accel_PID_Motor3" 02H 00H 01H
CSGLOBAL 42H 0002H "PWMIdleDutyRun" 02H 00H 01H
CSGLOBAL 42H 0002H "Mag_PIDCounter" 02H 00H 01H
CSGLOBAL 43H 0004H "CF_YPitch_high" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_CWThres" 02H 00H 03H
CSGLOBAL 43H 0004H "Ping_out" 02H 00H 03H
CSGLOBAL 42H 00C8H "SensorReturn" 05H 01H 0C8H 00H 00H 00H
CSGLOBAL 42H 0001H "PWMCounter" 02H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_PWRMGMT1REG_Contents" 02H 00H 00H
CSGLOBAL 42H 0001H "Accel_SavIndex" 02H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_ReadData" 02H 00H 00H
CSGLOBAL 43H 0004H "Mag_PIDError" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_Gyro_YPitch" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_PID_kd" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_PID_ki" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_PID_kp" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_Xout" 02H 00H 03H
CSGLOBAL 42H 0002H "PWMPeriod" 02H 00H 01H
CSGLOBAL 43H 0004H "CF_YPitch_low" 02H 00H 03H
CSGLOBAL 43H 0004H "Gyro_Zout" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_XRollErrPrev" 02H 00H 03H
CSGLOBAL 42H 0002H "Range_out" 02H 00H 01H
CSGLOBAL 43H 0004H "Range_PIDError" 02H 00H 03H
CSGLOBAL 43H 0004H "Gyro_Yout" 02H 00H 03H
CSGLOBAL 43H 0004H "Range_PIDOutput" 02H 00H 03H
CSGLOBAL 42H 0006H "NewVar_Str" 05H 01H 06H 00H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_AccelConfig" 02H 00H 00H
CSGLOBAL 43H 0004H "Accel_PID_XRolldErr" 02H 00H 03H
CSGLOBAL 43H 0002H "Accel_PID_PBounds_Var_Pos" 02H 00H 01H
CSGLOBAL 42H 0002H "PWMLowerDutyLimitCalib" 02H 00H 01H
CSGLOBAL 43H 0004H "Accel_PID_XRoll_ki" 02H 00H 03H
CGLOBAL 01H 42H 0001H "Accel_PID_XYChangeFlag" 02H 00H 00H
CSGLOBAL 43H 0004H "Accel_PID_XRoll_kd" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_YPitchError" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_XRoll_kp" 02H 00H 03H
CSGLOBAL 42H 0001H "AccGyro_CF_FlagCounter" 02H 00H 00H
CSGLOBAL 43H 0002H "Accel_PID_PBounds_Var_Neg" 02H 00H 01H
CSGLOBAL 43H 0004H "Accel_Zout_Avg" 02H 00H 03H
CSGLOBAL 42H 0001H "AccGyro_ReadFlag" 02H 00H 00H
CSGLOBAL 43H 0004H "Accel_Yout_Avg" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_PIDErrSum" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_Xout_Avg" 02H 00H 03H
CSGLOBAL 43H 0004H "Range_PIDSetpoint" 02H 00H 03H
CSGLOBAL 42H 0001H "Mag_ModeReg_Contents" 02H 00H 00H
CSGLOBAL 43H 0004H "NewVar" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_Yout" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_Gyro_Counter" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_XRoll" 02H 00H 03H
CSGLOBAL 42H 0002H "Mag_MotorStep" 02H 00H 01H
CSGLOBAL 42H 0001H "Accel_PID_DFlag" 02H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_GyroAccelLPF_SMPRTDIVCo" 02H 00H 00H
CSGLOBAL 43H 0004H "CF_Accel_ForceMagApprox" 02H 00H 03H
CSGLOBAL 42H 0002H "PWMtoRPMOffset_Mot2" 02H 00H 01H
CSGLOBAL 42H 0002H "PWMtoRPMOffset_Mot3" 02H 00H 01H
CSGLOBAL 42H 0002H "PWMtoRPMOffset_Mot4" 02H 00H 01H
CSGLOBAL 43H 0004H "Mag_Zout" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_XRollErrSum" 02H 00H 03H
CSGLOBAL 42H 0001H "Accel_PID_GoCounter" 02H 00H 00H
CSGLOBAL 43H 0004H "CF_StdDev_Mtmp_X" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_StdDev_Mtmp_Y" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_StdDev_K" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_PIDCurrentCount" 02H 00H 03H
CSGLOBAL 42H 000EH "AccGyro_Data" 05H 01H 0EH 00H 00H 00H
CSGLOBAL 43H 0004H "CF_XRoll_avg" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_YPitch_kp" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_YPitch_ki" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_YPitch_kd" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_PIDdErr" 02H 00H 03H
CSGLOBAL 42H 0001H "PWMflag" 02H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_INTENABLEReg_contents" 02H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_GyroConfig_Contents" 02H 00H 00H
CSGLOBAL 42H 0001H "HMC5883Address" 02H 00H 00H
CSGLOBAL 43H 0004H "Accel_PID_XRollError" 02H 00H 03H
CSGLOBAL 42H 0001H "PWMSensorResPerInc" 02H 00H 00H
CSGLOBAL 43H 0004H "CF_Gyro_XRoll" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_YPitchdErr" 02H 00H 03H
CSGLOBAL 42H 0001H "MPU6050Address" 02H 00H 00H
CSGLOBAL 42H 0002H "PWMUpperLowerDiff" 02H 00H 01H
CSGLOBAL 01H 000AH "_uartSetParam" 04H 00H 05H 03H 00H
CSGLOBAL 43H 0004H "Range_PIDdErr" 02H 00H 03H
CSGLOBAL 42H 0002H "PWMSafeDuty" 02H 00H 01H
CSGLOBAL 43H 0004H "CF_StdDev_M_X" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_StdDev_M_Y" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_YPitchErrPrev" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_XRoll_low" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_StdDev_S_X" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_StdDev_S_Y" 02H 00H 03H
CSGLOBAL 42H 0001H "Mag_ModeReg" 02H 00H 00H
CSGLOBAL 42H 0001H "Mag_ConfigB_Contents" 02H 00H 00H
CSGLOBAL 43H 0004H "Temp_out" 02H 00H 03H
CSGLOBAL 42H 0001H "AccGyro_PWRMGMT1REG" 02H 00H 00H
CSGLOBAL 43H 0002H "Accel_PID_DBounds_Var_Neg" 02H 00H 01H
CSGLOBAL 42H 0001H "Mag_ConfigA_Contents" 02H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_GyroConfig" 02H 00H 00H
CSGLOBAL 43H 0004H "Range_PIDErrSum" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_YPitch" 02H 00H 03H
CSGLOBAL 43H 0002H "Accel_PID_DBounds_Var_Pos" 02H 00H 01H
CSGLOBAL 42H 0002H "Range_Output" 05H 01H 02H 00H 00H 00H
CSGLOBAL 42H 0002H "PWMLowerDutyLimitRun" 02H 00H 01H
CSGLOBAL 43H 0004H "CF_avgCnt" 02H 00H 03H
CSGLOBAL 42H 0001H "PrePIDCount" 02H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_GyroAccelLPF" 02H 00H 00H
CSGLOBAL 42H 0001H "Range_Address" 02H 00H 00H
CSGLOBAL 43H 0004H "Mag_DeclinationAngle" 02H 00H 03H
CSGLOBAL 42H 0001H "CF_Counter" 02H 00H 00H
CSGLOBAL 43H 0004H "Range_PIDCurrentCount" 02H 00H 03H
CSGLOBAL 43H 0004H "Range_ZHiThres" 02H 00H 03H
CSGLOBAL 43H 0004H "Range_ZLoThres" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_PIDAngleScaled" 02H 00H 03H
CSGLOBAL 42H 0002H "Range_PIDCounter" 02H 00H 01H
CSGLOBAL 42H 0002H "PWMUpperDutyLimitRun" 02H 00H 01H
CSGLOBAL 43H 0004H "Range_Ceiling" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_PID_YPitchErrSum" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_XRoll_high" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_CCWThres" 02H 00H 03H
CSGLOBAL 43H 000CH "Accel_Zcal" 05H 01H 03H 00H 00H 03H
CSGLOBAL 42H 0002H "Accel_PID_XRollCounter_D" 02H 00H 01H
CSGLOBAL 42H 0002H "Accel_PID_XRollCounter_I" 02H 00H 01H
CSGLOBAL 42H 0001H "Mag_Status" 02H 00H 00H
CSGLOBAL 42H 0001H "AccGyro_AccelConfig_Contents" 02H 00H 00H
CSGLOBAL 43H 0004H "Mag_PIDCorrectionFactor" 02H 00H 03H
CGLOBAL 00H 42H 0001H "_flgI2CFin" 02H 00H 00H
CSGLOBAL 43H 000CH "Accel_Xcal" 05H 01H 03H 00H 00H 03H
CSGLOBAL 43H 0004H "AccGyro_GyroScaling" 02H 00H 03H
CSGLOBAL 43H 0002H "isDemoing" 02H 00H 01H
CSGLOBAL 43H 0004H "CF_Accel_XRoll" 02H 00H 03H
CSGLOBAL 42H 0006H "Mag_Data" 05H 01H 06H 00H 00H 00H
CSGLOBAL 43H 0044H "Accel_Xout" 05H 01H 11H 00H 00H 03H
CSGLOBAL 42H 0002H "Accel_PID_YPitchCounter_D" 02H 00H 01H
CSGLOBAL 42H 0002H "Accel_PID_YPitchCounter_I" 02H 00H 01H
CSGLOBAL 42H 0001H "CF_highlow_flag" 02H 00H 00H
CSGLOBAL 43H 000CH "Accel_Ycal" 05H 01H 03H 00H 00H 03H
CSGLOBAL 42H 0001H "AccGYRO_Test" 02H 00H 00H
CSGLOBAL 42H 0032H "SensorReturnSM" 05H 01H 32H 00H 00H 00H
CSGLOBAL 43H 0004H "CF_Gyro_CurrentCount" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_PIDErrPrev" 02H 00H 03H
CGLOBAL 00H 42H 0001H "_reqNotHalt" 02H 00H 00H
CSGLOBAL 42H 0001H "CF_UseFlag" 02H 00H 00H
CSGLOBAL 42H 0002H "TestingEndTimer" 02H 00H 01H
CSGLOBAL 43H 0004H "CF_Accel_YPitch" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_Angle" 02H 00H 03H
CSGLOBAL 43H 0004H "Mag_GainFactor" 02H 00H 03H
CSGLOBAL 42H 0001H "AccGyro_INTENABLEReg" 02H 00H 00H
CSGLOBAL 42H 0002H "PWMUpperDutyLimitCalib" 02H 00H 01H
CSGLOBAL 43H 0002H "testI" 02H 00H 01H
CSGLOBAL 43H 0002H "testD" 02H 00H 01H
CSGLOBAL 43H 0004H "Mag_PIDSetpoint" 02H 00H 03H
CSGLOBAL 43H 0002H "testP" 02H 00H 01H
CSGLOBAL 43H 0004H "AccGyro_AccelScaling" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_XLoThres" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_YHiThres" 02H 00H 03H
CSGLOBAL 43H 0004H "Range_PID_kp" 02H 00H 03H
CSGLOBAL 43H 0004H "Accel_XHiThres" 02H 00H 03H
CSGLOBAL 42H 0001H "Range_TakeRangeReading" 02H 00H 00H
CSGLOBAL 43H 0004H "Range_PID_kd" 02H 00H 03H
CSGLOBAL 43H 0044H "Accel_Yout" 05H 01H 11H 00H 00H 03H
CSGLOBAL 43H 0004H "Range_PID_ki" 02H 00H 03H
CSGLOBAL 42H 0002H "MotorStep" 02H 00H 01H
CSGLOBAL 43H 0044H "Accel_Zout" 05H 01H 11H 00H 00H 03H
CSGLOBAL 42H 0002H "Timer8Counter" 02H 00H 01H
CSGLOBAL 42H 0001H "AccGyro_GyroAccelLPF_Contents" 02H 00H 00H
CSGLOBAL 43H 0004H "Gyro_Zcal" 02H 00H 03H
CSGLOBAL 42H 0001H "Accel_PID_IFlag" 02H 00H 00H
CSGLOBAL 42H 0001H "Mag_ConfigA" 02H 00H 00H
CSGLOBAL 42H 0001H "Mag_ConfigB" 02H 00H 00H
CSGLOBAL 42H 0001H "Mag_ReadData" 02H 00H 00H
CSGLOBAL 43H 0004H "Accel_YLoThres" 02H 00H 03H
CSGLOBAL 43H 0004H "Gyro_Ycal" 02H 00H 03H
CSGLOBAL 42H 0002H "timer_us" 02H 00H 01H
CSGLOBAL 43H 0004H "Gyro_Xout" 02H 00H 03H
CSGLOBAL 43H 0004H "Gyro_Xcal" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_YPitch_avg" 02H 00H 03H
CSGLOBAL 43H 0004H "CF_HPF" 02H 00H 03H
CSGLOBAL 43H 0004H "Range_PIDErrPrev" 02H 00H 03H
CSGLOBAL 42H 0002H "Ping_timer" 02H 00H 01H
CFILE 0001H 0000085AH "main\\ML610112.H"
CFILE 0002H 000000D8H "main\\stdlib.h"
CFILE 0003H 0000007AH "main\\yvals.h"
CFILE 0004H 0000006BH "uart\\uart.h"
CFILE 0005H 00000027H "common\\common.h"
CFILE 0006H 00000057H "irq\\irq.h"
CFILE 0007H 00000023H "main\\mcu.h"
CFILE 0008H 00000045H "i2c\\i2c.h"
CFILE 0009H 000000EEH "main\\stdio.h"
CFILE 000AH 00000046H "tbc\\tbc.h"
CFILE 000BH 000001B8H "timer\\timer.h"
CFILE 000CH 0000004FH "main\\math.h"
CFILE 0000H 00001067H "main\\main.c"

	rseg $$main$main
CFUNCTION 261

_main	:
CBLOCK 261 1 565

;;{
CLINEA 0000H 0001H 0235H 0001H 0001H
CBLOCK 261 2 565
CLOCAL 47H 0002H 0026H 0002H "i" 02H 00H 01H

;;		Initialization(); 			//Ports, UART, Timers, Oscillator, Comparators, etc.
CLINEA 0000H 0001H 023AH 0003H 004BH
	bl	_Initialization

;;		if(PC3D==0)
CLINEA 0000H 0001H 023CH 0003H 000DH
	tb	0f260h.3
	bne	_$L30
CBLOCK 261 3 573

;;			isDemoing = 1;
CLINEA 0000H 0001H 023EH 0004H 0011H
	mov	er0,	#1 
	st	er0,	NEAR _isDemoing

;;			InitializeTone();
CLINEA 0000H 0001H 023FH 0004H 0014H
	bl	_InitializeTone
CBLOCKEND 261 3 576

;;		else
CLINEA 0000H 0001H 0241H 0003H 0006H
	bal	_$L32
_$L30 :
CBLOCK 261 4 578

;;			isDemoing = 0; 
CLINEA 0000H 0001H 0243H 0004H 0012H
	mov	er0,	#0 
	st	er0,	NEAR _isDemoing

;;			InitializeTone();
CLINEA 0000H 0001H 0244H 0004H 0014H
	bl	_InitializeTone

;;			InitializeTone();
CLINEA 0000H 0001H 0245H 0004H 0014H
	bl	_InitializeTone
CBLOCKEND 261 4 582

;;		}
CLINEA 0000H 0000H 0246H 0003H 0003H
_$L32 :

;;		main_clrWDT();				//kick the dog...1.34uS duration
CLINEA 0000H 0001H 0249H 0003H 0034H
	bl	_main_clrWDT

;;		CalibrateMotors();			//Time-consuming ~6s 
CLINEA 0000H 0001H 024AH 0003H 002CH
	bl	_CalibrateMotors

;;		CalibrateGyro();			//Enter Calibration Sequence for Gyro
CLINEA 0000H 0001H 024BH 0003H 003AH
	bl	_CalibrateGyro

;;			Accel_Xcal[0] = 754;
CLINEA 0000H 0001H 0250H 0004H 0017H
	mov	r0,	#00h
	mov	r1,	#080h
	mov	r2,	#03ch
	mov	r3,	#044h
	st	er0,	NEAR _Accel_Xcal
	st	er2,	NEAR _Accel_Xcal+02h

;;			Accel_Ycal[0] = -1360;
CLINEA 0000H 0001H 0251H 0004H 0019H
	mov	er0,	#0 
	mov	r2,	#0aah
	mov	r3,	#0c4h
	st	er0,	NEAR _Accel_Ycal
	st	er2,	NEAR _Accel_Ycal+02h

;;			Accel_Zcal[0] = -162;
CLINEA 0000H 0001H 0252H 0004H 0018H
	mov	r2,	#022h
	mov	r3,	#0c3h
	st	er0,	NEAR _Accel_Zcal
	st	er2,	NEAR _Accel_Zcal+02h

;;Main_Loop:
CLINEA 0000H 0001H 025BH 0001H 000AH
CLABEL 0021H "Main_Loop"
_$L33 :

;;		if(!isDemoing)
CLINEA 0000H 0000H 025CH 0003H 0010H
	l	er0,	NEAR _isDemoing
	bne	_$L34
CBLOCK 261 5 605

;;			SerialOutCoefficients();	//~23ms when PID is Triggered as well..13.8ms otherwise
CLINEA 0000H 0001H 025EH 0004H 0053H
	bl	_SerialOutCoefficients

;;			PrePIDCount = 0;
CLINEA 0000H 0001H 025FH 0004H 0013H
	mov	r0,	#00h
	st	r0,	NEAR _PrePIDCount

;;			UARTTunePID();				//Allow PID & CF Constant changes over UART
CLINEA 0000H 0001H 0260H 0004H 0040H
	bl	_UARTTunePID

;;			main_clrWDT();				//kick the dog...1.34uS duration.
CLINEA 0000H 0001H 0261H 0004H 0036H
	bl	_main_clrWDT
CBLOCKEND 261 5 610

;;		} 
CLINEA 0000H 0000H 0262H 0003H 0004H
_$L34 :

;;		Accel_SavIndex = 0;			//Reset Circular Buffer for Accel/Gyro Measurements
CLINEA 0000H 0001H 0264H 0003H 004BH
	mov	r0,	#00h
	st	r0,	NEAR _Accel_SavIndex

;;		for(i=0; i<AccelAvg; i++){
CLINEA 0000H 0001H 0266H 0003H 001CH
	mov	er4,	#0 
_$L40 :
CBLOCK 261 6 614

;;			Accel_Xout[i] = 0;
CLINEA 0000H 0001H 0267H 0004H 0015H
	mov	er0,	er4
	sllc	r1,	#02h
	sll	r0,	#02h
	mov	er2,	#0 
	st	er2,	NEAR _Accel_Xout[er0]
	st	er2,	NEAR _Accel_Xout+02h[er0]

;;			Accel_Yout[i] = 0;
CLINEA 0000H 0001H 0268H 0004H 0015H
	mov	er0,	er4
	sllc	r1,	#02h
	sll	r0,	#02h
	st	er2,	NEAR _Accel_Yout[er0]
	st	er2,	NEAR _Accel_Yout+02h[er0]

;;			Accel_Zout[i] = 0;
CLINEA 0000H 0001H 0269H 0004H 0015H
	mov	er0,	er4
	sllc	r1,	#02h
	sll	r0,	#02h
	st	er2,	NEAR _Accel_Zout[er0]
	st	er2,	NEAR _Accel_Zout+02h[er0]
CBLOCKEND 261 6 621

;;		for(i=0; i<AccelAvg; i++){
CLINEA 0000H 0000H 0266H 0003H 001CH
	add	er4,	#1 
	cmp	r4,	#011h
	cmpc	r5,	#00h
	blts	_$L40

;;		EPB3 = 1;					//Enable Accel/Gyro Interrupt Pin
CLINEA 0000H 0001H 026EH 0003H 0031H
	sb	0f011h.7

;;		while(!PC3D){
CLINEA 0000H 0000H 0270H 0003H 000FH
	bal	_$L44
_$L46 :
CBLOCK 261 7 624

;;			NOPms(100);
CLINEA 0000H 0001H 0271H 0004H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;			main_clrWDT();
CLINEA 0000H 0001H 0272H 0004H 0011H
	bl	_main_clrWDT
CBLOCKEND 261 7 627

;;		}
CLINEA 0000H 0000H 0273H 0003H 0003H
_$L44 :

;;		while(!PC3D){
CLINEA 0000H 0000H 0270H 0000H 0000H
	tb	0f260h.3
	beq	_$L46

;;		Emit_Warning();
CLINEA 0000H 0001H 0275H 0003H 0011H
	bl	_Emit_Warning

;;		SoftStart();				//Smoothly bring up the Motor RPM
CLINEA 0000H 0001H 0276H 0003H 0033H
	bl	_SoftStart

;;Fast_Loop:							//This loop takes 22.4ms for this loop as of 3/30/2014		
CLINEA 0000H 0001H 0279H 0001H 0049H
CLABEL 0032H "Fast_Loop"
_$L50 :

;;		main_clrWDT();				//kick the dog...1.34uS duration
CLINEA 0000H 0001H 027BH 0003H 0034H
	bl	_main_clrWDT

;;		ClearVariables();			//Fresh start each loop...
CLINEA 0000H 0001H 027CH 0003H 0030H
	bl	_ClearVariables

;;		if(AccGyro_ReadFlag >= 1){		//Triggered by External Interrupt (flag set in AccelGyroDataReady_ISR)
CLINEA 0000H 0001H 0292H 0003H 0064H
	l	r0,	NEAR _AccGyro_ReadFlag
	cmp	r0,	#01h
	blt	_$L51
CBLOCK 261 8 658

;;			LED_4 = 1;				//LED4 = C2, Pin 14	//Loop Time = 1.5ms @20Hz Rate
CLINEA 0000H 0001H 0293H 0004H 0043H
	sb	0f260h.2

;;			Get_AccGyroData();
CLINEA 0000H 0001H 0294H 0004H 0015H
	bl	_Get_AccGyroData

;;			LED_4 = 0;
CLINEA 0000H 0001H 0295H 0004H 000DH
	rb	0f260h.2

;;			AccGyro_ReadFlag = 0;
CLINEA 0000H 0001H 0296H 0004H 0018H
	mov	r0,	#00h
	st	r0,	NEAR _AccGyro_ReadFlag
CBLOCKEND 261 8 663

;;		}
CLINEA 0000H 0000H 0297H 0003H 0003H
_$L51 :

;;		if(AccGyro_CF_FlagCounter > 0){	//This Value is incremented after Get_AccGyroData(); is called
CLINEA 0000H 0001H 0298H 0003H 0060H
	l	r0,	NEAR _AccGyro_CF_FlagCounter
	cmp	r0,	#00h
	ble	_$L53
CBLOCK 261 9 664

;;			LED_2 = 1;			//B7, Pin 11	//Inside RUN_CF	//Loop Time = 13.5ms
CLINEA 0000H 0001H 0299H 0004H 0041H
	sb	0f258h.7

;;			Run_AccGyroCF();
CLINEA 0000H 0001H 029AH 0004H 0013H
	bl	_Run_AccGyroCF

;;			LED_2 = 0;
CLINEA 0000H 0001H 029BH 0004H 000DH
	rb	0f258h.7

;;			AccGyro_CF_FlagCounter--;	//Decremented because this value is not a static 1/0... number shows number of items in buffer that have not gone though the CF yet
CLINEA 0000H 0000H 029CH 0004H 00A0H
	lea	OFFSET _AccGyro_CF_FlagCounter
	dec	[ea]
CBLOCKEND 261 9 669

;;		}
CLINEA 0000H 0000H 029DH 0003H 0003H
_$L53 :

;;		if(Accel_PID_GoCounter>= 1){		//This increments in the Run_AccGyroCF()... I don't know if this is the best trigger.. but for now, it works.  Calls GetAccGyroData and AccGyroCF once within the routine.
CLINEA 0000H 0001H 029EH 0003H 00CAH
	l	r0,	NEAR _Accel_PID_GoCounter
	cmp	r0,	#01h
	blt	_$L55
CBLOCK 261 10 670

;;			LED_3 = 1;			//C1, Pin 13		//Loop Time = 25.47 with UART Debugging ON... 
CLINEA 0000H 0001H 029FH 0004H 004CH
	sb	0f260h.1

;;			AccelSensorControlPID_P(); 		
CLINEA 0000H 0001H 02A0H 0004H 0020H
	bl	_AccelSensorControlPID_P

;;			LED_3 = 0;
CLINEA 0000H 0001H 02A1H 0004H 000DH
	rb	0f260h.1

;;			Accel_PID_IFlag++;
CLINEA 0000H 0000H 02A2H 0004H 0015H
	lea	OFFSET _Accel_PID_IFlag
	inc	[ea]

;;			Accel_PID_DFlag++;
CLINEA 0000H 0000H 02A3H 0004H 0015H
	lea	OFFSET _Accel_PID_DFlag
	inc	[ea]
	l	r0,	NEAR _Accel_PID_DFlag

;;			if(Accel_PID_DFlag < DenterThres){
CLINEA 0000H 0001H 02A4H 0004H 0025H
	cmp	r0,	#01h
	bge	_$L57
CBLOCK 261 11 676

;;				Accel_PID_YPitchErrPrev = Accel_PID_YPitchError;
CLINEA 0000H 0001H 02A5H 0005H 0034H
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	st	er0,	NEAR _Accel_PID_YPitchErrPrev
	st	er2,	NEAR _Accel_PID_YPitchErrPrev+02h

;;				Accel_PID_XRollErrPrev = Accel_PID_XRollError;
CLINEA 0000H 0001H 02A6H 0005H 0032H
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	st	er0,	NEAR _Accel_PID_XRollErrPrev
	st	er2,	NEAR _Accel_PID_XRollErrPrev+02h
CBLOCKEND 261 11 679

;;			}
CLINEA 0000H 0000H 02A7H 0004H 0004H
_$L57 :

;;			Accel_PID_GoCounter = 0;
CLINEA 0000H 0001H 02A8H 0004H 001BH
	mov	r0,	#00h
	st	r0,	NEAR _Accel_PID_GoCounter

;;			TestingEndTimer++;			//Comment this out to always loop (i.e.: no shut-down...)
CLINEA 0000H 0000H 02A9H 0004H 0051H
	l	er0,	NEAR _TestingEndTimer
	add	er0,	#1 
	st	er0,	NEAR _TestingEndTimer
CBLOCKEND 261 10 682

;;		}
CLINEA 0000H 0000H 02AAH 0003H 0003H
_$L55 :

;;		if(Accel_PID_IFlag >= IenterThres){		//This increments in the Run_AccGyroCF()... I don't know if this is the best trigger.. but for now, it works.  Calls GetAccGyroData and AccGyroCF once within the routine.
CLINEA 0000H 0001H 02ACH 0003H 00D1H
	l	r0,	NEAR _Accel_PID_IFlag
	cmp	r0,	#01h
	blt	_$L59
CBLOCK 261 12 684

;;			AccelSensorControlPID_I(); 		
CLINEA 0000H 0001H 02AEH 0004H 0020H
	bl	_AccelSensorControlPID_I

;;			Accel_PID_IFlag = 0;
CLINEA 0000H 0001H 02B0H 0004H 0017H
	mov	r0,	#00h
	st	r0,	NEAR _Accel_PID_IFlag
CBLOCKEND 261 12 689

;;		}
CLINEA 0000H 0000H 02B1H 0003H 0003H
_$L59 :

;;		if(Accel_PID_DFlag >= DenterThres){		//This increments in the Run_AccGyroCF()... I don't know if this is the best trigger.. but for now, it works.  Calls GetAccGyroData and AccGyroCF once within the routine.
CLINEA 0000H 0001H 02B2H 0003H 00D1H
	l	r0,	NEAR _Accel_PID_DFlag
	cmp	r0,	#01h
	blt	_$L61
CBLOCK 261 13 690

;;			AccelSensorControlPID_D();
CLINEA 0000H 0001H 02B4H 0004H 001DH
	bl	_AccelSensorControlPID_D

;;			Accel_PID_DFlag = 0;
CLINEA 0000H 0001H 02B6H 0004H 0017H
	mov	r0,	#00h
	st	r0,	NEAR _Accel_PID_DFlag
CBLOCKEND 261 13 695

;;		}
CLINEA 0000H 0000H 02B7H 0003H 0003H
_$L61 :

;;		if(PC3D==1){		//50 == 3secs = 250 = 15 seconds
CLINEA 0000H 0001H 02C9H 0003H 0030H
	tb	0f260h.3
	beq	_$M1
	b	_$L50
_$M1 :
CBLOCK 261 14 713

;;			goto Fast_Loop;
CLINEA 0000H 0001H 02CBH 0004H 0012H
CBLOCKEND 261 14 716

;;		else{
CLINEA 0000H 0000H 02CDH 0003H 0007H
CBLOCK 261 15 717

;;			EPB3 = 0;
CLINEA 0000H 0001H 02CEH 0004H 000CH
	rb	0f011h.7

;;			Shutdown();
CLINEA 0000H 0001H 02D1H 0004H 000EH
	bl	_Shutdown

;;			TestingEndTimer = 0;
CLINEA 0000H 0001H 02D2H 0004H 0017H
	mov	er0,	#0 
	st	er0,	NEAR _TestingEndTimer

;;			goto Main_Loop;
CLINEA 0000H 0001H 02D4H 0004H 0012H
	b	_$L33
CBLOCKEND 261 15 725
CBLOCKEND 261 2 727

;;}//end main
CLINEA 0000H 0001H 02D7H 0001H 000BH
CBLOCKEND 261 1 727
CFUNCTIONEND 261


	rseg $$InitializeTone$main
CFUNCTION 260

_InitializeTone	:
CBLOCK 260 1 730

;;{ 
CLINEA 0000H 0001H 02DAH 0001H 0002H
	push	lr
	push	er4
CBLOCK 260 2 730
CRET 0002H
CLOCAL 47H 0002H 0026H 0002H "i" 02H 00H 01H
	mov	er4,	#0 

;;	if(isDemoing)
CLINEA 0000H 0001H 02DCH 0002H 000EH
	l	er0,	NEAR _isDemoing
	beq	_$L67
CBLOCK 260 3 733

;;		for(i=0; i<15; i++)
CLINEA 0000H 0000H 02DEH 0012H 0014H
_$L71 :
CBLOCK 260 4 735

;;			LED_2 = 1;
CLINEA 0000H 0001H 02E0H 0004H 000DH
	sb	0f258h.7

;;			NOPms(100);
CLINEA 0000H 0001H 02E1H 0004H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;			LED_2 = 0;
CLINEA 0000H 0001H 02E2H 0004H 000DH
	rb	0f258h.7

;;			NOPms(100);  
CLINEA 0000H 0001H 02E3H 0004H 0010H
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 260 4 740

;;		for(i=0; i<15; i++)
CLINEA 0000H 0000H 02DEH 0012H 0014H
	add	er4,	#1 

;;		for(i=0; i<15; i++)
CLINEA 0000H 0000H 02DEH 000CH 0010H
	cmp	r4,	#0fh
	cmpc	r5,	#00h
	blts	_$L71

;;		NOPms(100); 
CLINEA 0000H 0001H 02E5H 0003H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		NOPms(100);    
CLINEA 0000H 0001H 02E6H 0003H 0011H
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		for(i=0; i<15; i++)
CLINEA 0000H 0001H 02E7H 0003H 0015H
	mov	er4,	#0 
_$L77 :
CBLOCK 260 5 744

;;			LED_2 = 1;
CLINEA 0000H 0001H 02E9H 0004H 000DH
	sb	0f258h.7

;;			NOPms(100);
CLINEA 0000H 0001H 02EAH 0004H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;			LED_2 = 0;
CLINEA 0000H 0001H 02EBH 0004H 000DH
	rb	0f258h.7

;;			NOPms(100);  
CLINEA 0000H 0001H 02ECH 0004H 0010H
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 260 5 749

;;		for(i=0; i<15; i++)
CLINEA 0000H 0000H 02E7H 0003H 0015H
	add	er4,	#1 

;;		for(i=0; i<15; i++)
CLINEA 0000H 0000H 02E7H 000CH 0010H
	cmp	r4,	#0fh
	cmpc	r5,	#00h
	blts	_$L77

;;		NOPms(100); 
CLINEA 0000H 0001H 02EEH 0003H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		NOPms(100);  
CLINEA 0000H 0001H 02EFH 0003H 000FH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 260 3 752

;;	else
CLINEA 0000H 0001H 02F1H 0002H 0005H
	b	_$L81
_$L67 :
CBLOCK 260 6 754
CBLOCK 260 7 756

;;			LED_2 = 1;
CLINEA 0000H 0001H 02F5H 0004H 000DH
	sb	0f258h.7

;;			NOPms(100);
CLINEA 0000H 0001H 02F6H 0004H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;			LED_2 = 0;
CLINEA 0000H 0001H 02F7H 0004H 000DH
	rb	0f258h.7

;;			NOPms(100);  
CLINEA 0000H 0001H 02F8H 0004H 0010H
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 260 7 761

;;		for(i=0; i<7; i++)
CLINEA 0000H 0000H 02F3H 0011H 0013H
	add	er4,	#1 

;;		for(i=0; i<7; i++)
CLINEA 0000H 0000H 02F3H 000CH 000FH
	cmp	r4,	#07h
	cmpc	r5,	#00h
	blts	_$L67

;;		NOPms(100); 
CLINEA 0000H 0001H 02FAH 0003H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		NOPms(100);  
CLINEA 0000H 0001H 02FBH 0003H 000FH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		for(i=0; i<7; i++)
CLINEA 0000H 0001H 02FCH 0003H 0014H
	mov	er4,	#0 
_$L90 :
CBLOCK 260 8 765

;;			LED_2 = 1;
CLINEA 0000H 0001H 02FEH 0004H 000DH
	sb	0f258h.7

;;			NOPms(100);
CLINEA 0000H 0001H 02FFH 0004H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;			LED_2 = 0;
CLINEA 0000H 0001H 0300H 0004H 000DH
	rb	0f258h.7

;;			NOPms(100);  
CLINEA 0000H 0001H 0301H 0004H 0010H
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 260 8 770

;;		for(i=0; i<7; i++)
CLINEA 0000H 0000H 02FCH 0003H 0014H
	add	er4,	#1 

;;		for(i=0; i<7; i++)
CLINEA 0000H 0000H 02FCH 000CH 000FH
	cmp	r4,	#07h
	cmpc	r5,	#00h
	blts	_$L90

;;		NOPms(100); 
CLINEA 0000H 0001H 0303H 0003H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		NOPms(100);  
CLINEA 0000H 0001H 0304H 0003H 000FH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		for(i=0; i<7; i++)
CLINEA 0000H 0001H 0305H 0003H 0014H
	mov	er4,	#0 
_$L96 :
CBLOCK 260 9 774

;;			LED_2 = 1;
CLINEA 0000H 0001H 0307H 0004H 000DH
	sb	0f258h.7

;;			NOPms(100);
CLINEA 0000H 0001H 0308H 0004H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;			LED_2 = 0;
CLINEA 0000H 0001H 0309H 0004H 000DH
	rb	0f258h.7

;;			NOPms(100);  
CLINEA 0000H 0001H 030AH 0004H 0010H
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 260 9 779

;;		for(i=0; i<7; i++)
CLINEA 0000H 0000H 0305H 0003H 0014H
	add	er4,	#1 

;;		for(i=0; i<7; i++)
CLINEA 0000H 0000H 0305H 000CH 000FH
	cmp	r4,	#07h
	cmpc	r5,	#00h
	blts	_$L96

;;		NOPms(100); 
CLINEA 0000H 0001H 030CH 0003H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		NOPms(100);  
CLINEA 0000H 0001H 030DH 0003H 000FH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		for(i=0; i<7; i++)
CLINEA 0000H 0001H 030EH 0003H 0014H
	mov	er4,	#0 
_$L102 :
CBLOCK 260 10 783

;;			LED_2 = 1;
CLINEA 0000H 0001H 0310H 0004H 000DH
	sb	0f258h.7

;;			NOPms(100);
CLINEA 0000H 0001H 0311H 0004H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;			LED_2 = 0;
CLINEA 0000H 0001H 0312H 0004H 000DH
	rb	0f258h.7

;;			NOPms(100);  
CLINEA 0000H 0001H 0313H 0004H 0010H
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 260 10 788

;;		for(i=0; i<7; i++)
CLINEA 0000H 0000H 030EH 0003H 0014H
	add	er4,	#1 

;;		for(i=0; i<7; i++)
CLINEA 0000H 0000H 030EH 000CH 000FH
	cmp	r4,	#07h
	cmpc	r5,	#00h
	blts	_$L102

;;		NOPms(100); 
CLINEA 0000H 0001H 0315H 0003H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		NOPms(100);  
CLINEA 0000H 0001H 0316H 0003H 000FH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 260 6 791

;;	}
CLINEA 0000H 0000H 0317H 0002H 0002H
_$L81 :
CBLOCKEND 260 2 792

;;}
CLINEA 0000H 0001H 0318H 0001H 0001H
	pop	er4
	pop	pc
CBLOCKEND 260 1 792
CFUNCTIONEND 260


	rseg $$Emit_Warning$main
CFUNCTION 259

_Emit_Warning	:
CBLOCK 259 1 795

;;{
CLINEA 0000H 0001H 031BH 0001H 0001H
	push	lr
	push	er4
CBLOCK 259 2 795
CRET 0002H
CLOCAL 47H 0002H 0026H 0002H "i" 02H 00H 01H

;;	for(i=0; i<40; i++)
CLINEA 0000H 0001H 031DH 0002H 0014H
	mov	er4,	#0 
_$L109 :
CBLOCK 259 3 798

;;		LED_2 = 1;
CLINEA 0000H 0001H 031FH 0003H 000CH
	sb	0f258h.7

;;		NOPms(100);
CLINEA 0000H 0001H 0320H 0003H 000DH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;		LED_2 = 0;
CLINEA 0000H 0001H 0321H 0003H 000CH
	rb	0f258h.7

;;		NOPms(100);  
CLINEA 0000H 0001H 0322H 0003H 000FH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms
CBLOCKEND 259 3 803

;;	for(i=0; i<40; i++)
CLINEA 0000H 0000H 031DH 0002H 0014H
	add	er4,	#1 

;;	for(i=0; i<40; i++)
CLINEA 0000H 0000H 031DH 000CH 000FH
	cmp	r4,	#028h
	cmpc	r5,	#00h
	blts	_$L109
CBLOCKEND 259 2 804

;;}
CLINEA 0000H 0001H 0324H 0001H 0001H
	pop	er4
	pop	pc
CBLOCKEND 259 1 804
CFUNCTIONEND 259


	rseg $$main_clrWDT$main
CFUNCTION 206

_main_clrWDT	:
CBLOCK 206 1 984

;;{
CLINEA 0000H 0001H 03D8H 0001H 0001H
CBLOCK 206 2 984

;;	do {
CLINEA 0000H 0001H 03DCH 0002H 0005H
_$L116 :
CBLOCK 206 3 988

;;		WDTCON = 0x5Au;
CLINEA 0000H 0001H 03DDH 0003H 0011H
	mov	r0,	#05ah
	st	r0,	0f00eh
CBLOCKEND 206 3 990

;;	} while (WDP != 1);
CLINEA 0000H 0000H 03DEH 0002H 0014H
	tb	0f00eh.0
	beq	_$L116

;;	WDTCON = 0xA5u;
CLINEA 0000H 0001H 03DFH 0002H 0010H
	mov	r0,	#0a5h
	st	r0,	0f00eh
CBLOCKEND 206 2 993

;;}
CLINEA 0000H 0001H 03E1H 0001H 0001H
	rt
CBLOCKEND 206 1 993
CFUNCTIONEND 206


	rseg $$Initialization$main
CFUNCTION 207

_Initialization	:
CBLOCK 207 1 1000

;;static void Initialization(void){
CLINEA 0000H 0001H 03E8H 0001H 0021H
	push	lr
CBLOCK 207 2 1000
CRET 0000H

;;	DSIO0 = 1; // 0=> Enables Synchronous Serial Port 0 (initial value).
CLINEA 0000H 0001H 03ECH 0002H 0045H
	sb	0f02ah.0

;;	DUA0  = 0; // 0=> Enables the operation of UART0 (initial value).
CLINEA 0000H 0001H 03EDH 0002H 0042H
	rb	0f02ah.2

;;	DUA1  = 1; // 0=> Enables Uart1 (initial value). 
CLINEA 0000H 0001H 03EEH 0002H 0032H
	sb	0f02ah.3

;;	DI2C1 = 1; // 0=> Enables I2C bus Interface (Slave) (initial value).
CLINEA 0000H 0001H 03EFH 0002H 0045H
	sb	0f02ah.6

;;	DI2C0 = 0; // 0=> Enables I2C bus Interface (Master) (initial value).	
CLINEA 0000H 0001H 03F0H 0002H 0047H
	rb	0f02ah.7

;;	BLKCON4 = 0x00; // 0=> Enables SA-ADC
CLINEA 0000H 0001H 03F2H 0002H 0026H
	mov	r0,	#00h
	st	r0,	0f02ch

;;	BLKCON6 = 0x00; // (1=disables; 0=enables) the operation of Timers 8, 9, A, E, F.
CLINEA 0000H 0001H 03F3H 0002H 0052H
	st	r0,	0f02eh

;;	BLKCON7 = 0x00; // (1=disables; 0=enables) the operation of PWM (PWMC, PWMD, PWME, PWMF
CLINEA 0000H 0001H 03F4H 0002H 0058H
	st	r0,	0f02fh

;;	PortA_Low();	//Initialize all 3 Ports of Port A to GPIO-Low
CLINEA 0000H 0001H 03F7H 0002H 003CH
	bl	_PortA_Low

;;	PortB_Low();	//Initialize all 8 Ports of Port B to GPIO-Low
CLINEA 0000H 0001H 03F8H 0002H 003CH
	bl	_PortB_Low

;;	PortC_Low();	//Initialize all 8 Ports of Port C to GPIO-Low
CLINEA 0000H 0001H 03F9H 0002H 003CH
	bl	_PortC_Low

;;	PortD_Low();	//Initialize all 6 Ports of Port D to GPIO-Low
CLINEA 0000H 0001H 03FAH 0002H 003CH
	bl	_PortD_Low

;;    SetOSC();
CLINEA 0000H 0001H 03FDH 0005H 000DH
	bl	_SetOSC

;;	irq_di();	// Disable Interrupts
CLINEA 0000H 0001H 0401H 0002H 0020H
	bl	_irq_di

;;	irq_init();	// Initialize Interrupts (All Off and NO Requests)
CLINEA 0000H 0001H 0402H 0002H 003FH
	bl	_irq_init

;;	(void)irq_setHdr( (unsigned char)IRQ_NO_I2CMINT, _intI2c );
CLINEA 0000H 0001H 041FH 0002H 003CH
	mov	r2,	#BYTE1 OFFSET __intI2c
	mov	r3,	#BYTE2 OFFSET __intI2c
	mov	r0,	#0ch
	bl	_irq_setHdr

;;		EI2CM = 1;
CLINEA 0000H 0001H 0420H 0003H 000CH
	sb	0f012h.7

;;	(void)irq_setHdr( (unsigned char)IRQ_NO_UA0INT, _intUart );		
CLINEA 0000H 0001H 0424H 0002H 003EH
	mov	r2,	#BYTE1 OFFSET __intUart
	mov	r3,	#BYTE2 OFFSET __intUart
	mov	r0,	#0fh
	bl	_irq_setHdr

;;		EUA0 = 1; // EUA0 is the enable flag for the UART0 interrupt (1=ENABLED)
CLINEA 0000H 0001H 0425H 0003H 004AH
	sb	0f014h.0

;;	(void)irq_setHdr( (unsigned char)IRQ_NO_TM9INT, TMR89_ISR );  //Clear interrupt request flag
CLINEA 0000H 0001H 0432H 0002H 005DH
	mov	r2,	#BYTE1 OFFSET _TMR89_ISR
	mov	r3,	#BYTE2 OFFSET _TMR89_ISR
	mov	r0,	#0eh
	bl	_irq_setHdr

;;		ETM8 = 1;	  	// Enable timer 8 Interrupt (1=ENABLED
CLINEA 0000H 0001H 0433H 0003H 0035H
	sb	0f013h.2

;;		ETM9 = 1;	  	// Enable timer 9 Interrupt (1=ENABLED)
CLINEA 0000H 0001H 0434H 0003H 0036H
	sb	0f013h.3

;;		QTM8 = 1;		// timer 8 IRQ request flag
CLINEA 0000H 0001H 0435H 0003H 0028H
	sb	0f01bh.2

;;		QTM9 = 1;		// timer 9 IRQ request flag
CLINEA 0000H 0001H 0436H 0003H 0028H
	sb	0f01bh.3

;;		T8CS0 = 1;
CLINEA 0000H 0001H 0437H 0003H 000CH
	sb	0f8e2h.0

;;		T8CS1 = 1;
CLINEA 0000H 0001H 0438H 0003H 000CH
	sb	0f8e2h.1

;;		T8CS2 = 0;
CLINEA 0000H 0001H 0439H 0003H 000CH
	rb	0f8e2h.2

;;		T9CS0 = 1;
CLINEA 0000H 0001H 043AH 0003H 000CH
	sb	0f8e6h.0

;;		T9CS1 = 1;
CLINEA 0000H 0001H 043BH 0003H 000CH
	sb	0f8e6h.1

;;		T9CS2 = 0;
CLINEA 0000H 0001H 043CH 0003H 000CH
	rb	0f8e6h.2

;;		tm_init(TM_CH_NO_89);
CLINEA 0000H 0001H 043DH 0003H 0017H
	mov	r0,	#00h
	bl	_tm_init

;;		tm_set89Data(8192);				//A value of 1023 should yield 125us interrupts at 8.192 MHz
CLINEA 0000H 0000H 0150H 0002H 0025H
	mov	r0,	#00h
	st	r0,	0f8e0h

;;		tm_set89Data(8192);				//A value of 1023 should yield 125us interrupts at 8.192 MHz
CLINEA 0000H 0000H 0151H 0002H 0023H
	mov	r0,	#020h
	st	r0,	0f8e4h

;;		tm_set89Source(TM_CS_HTBCLK);
CLINEA 0000H 0000H 0186H 0002H 0015H
	sb	0f8e2h.0

;;		tm_set89Source(TM_CS_HTBCLK);
CLINEA 0000H 0000H 0187H 0002H 001AH
	rb	0f8e2h.1

;;		tm_start89();
CLINEA 0000H 0001H 00CAH 0002H 000AH
	mov	r0,	#00h
	st	r0,	0f8e1h

;;		tm_start89();
CLINEA 0000H 0000H 00CBH 0002H 000BH
	sb	0f8e3h.0

;;		T89M16 = 1;
CLINEA 0000H 0001H 0441H 0003H 000DH
	sb	0f8e2h.5

;;		HTD3 = 1;
CLINEA 0000H 0001H 0443H 0003H 000BH
	sb	0f00bh.3

;;		HTD2 = 1;
CLINEA 0000H 0001H 0444H 0003H 000BH
	sb	0f00bh.2

;;		HTD1 = 1;
CLINEA 0000H 0001H 0445H 0003H 000BH
	sb	0f00bh.1

;;		HTD0 = 1; 
CLINEA 0000H 0001H 0446H 0003H 000CH
	sb	0f00bh.0

;;	PB3DIR = 1;
CLINEA 0000H 0001H 0449H 0002H 000CH
	sb	0f259h.3

;;	PB3C1 = 0;
CLINEA 0000H 0001H 044AH 0002H 000BH
	rb	0f25bh.3

;;	PB3C0 = 0;
CLINEA 0000H 0001H 044BH 0002H 000BH
	rb	0f25ah.3

;;	PB3MD1 = 0;
CLINEA 0000H 0001H 044CH 0002H 000CH
	rb	0f25dh.3

;;	PB3MD0 = 0;
CLINEA 0000H 0001H 044DH 0002H 000CH
	rb	0f25ch.3

;;	PB3E1 = 1;
CLINEA 0000H 0001H 044EH 0002H 000BH
	sb	0f025h.7

;;	PB3E0 = 0;		//PBnE0-1 are used to choose the Rising-Edge Mode for this interrupt
CLINEA 0000H 0001H 0450H 0002H 0051H
	rb	0f024h.7

;;	PB3SM = 0;
CLINEA 0000H 0001H 0451H 0002H 000BH
	rb	0f026h.7

;;	(void)irq_setHdr( (unsigned char)IRQ_NO_PB3INT, AccelGyroDataReady_ISR );  //Clear interrupt request flag
CLINEA 0000H 0001H 0453H 0002H 006AH
	mov	r2,	#BYTE1 OFFSET _AccelGyroDataReady_ISR
	mov	r3,	#BYTE2 OFFSET _AccelGyroDataReady_ISR
	mov	r0,	#08h
	bl	_irq_setHdr

;;	EPB3 = 0;	//Enables Interrupt
CLINEA 0000H 0001H 0455H 0002H 001EH
	rb	0f011h.7

;;	QPB3 = 0;	//Enables Request Flag (need to set to start using... this is set after the UART control Stuff!)
CLINEA 0000H 0001H 0456H 0002H 006BH
	rb	0f019h.7

;;	WDTMOD = 0x03; 	// 0x03=overflow 8sec...
CLINEA 0000H 0001H 045AH 0002H 0029H
	mov	r0,	#03h
	st	r0,	0f00fh

;;	main_clrWDT(); 	// Clear WDT
CLINEA 0000H 0001H 045BH 0002H 001DH
	bl	_main_clrWDT

;;	(void)i2c_init(I2C_MOD_FST, (unsigned short)HSCLK_KHZ, I2C_SYN_ON);
CLINEA 0000H 0001H 045FH 0002H 0044H
	mov	r0,	#01h
	push	r0
	mov	r2,	#040h
	mov	r3,	#01fh
	bl	_i2c_init
	add	sp,	#2 

;;			     &_uartSetParam );				/* Param... 	 */
CLINEA 0000H 0001H 0465H 0009H 002DH
	mov	r0,	#BYTE1 OFFSET __uartSetParam
	mov	r1,	#BYTE2 OFFSET __uartSetParam
	push	er0
	mov	r2,	#040h
	mov	r3,	#01fh
	mov	r0,	#02h
	bl	_uart_init
	add	sp,	#2 

;;		uart_PortSet();
CLINEA 0000H 0001H 0466H 0003H 0011H
	bl	_uart_PortSet

;;		_flgUartFin = 0;
CLINEA 0000H 0001H 0467H 0003H 0012H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;		uart_stop();
CLINEA 0000H 0001H 0468H 0003H 000EH
	bl	_uart_stop

;;	irq_ei(); // Enable Interrupts
CLINEA 0000H 0001H 046AH 0002H 001FH
	bl	_irq_ei

;;		ESC1_PWM();
CLINEA 0000H 0001H 046EH 0003H 000DH
	bl	_ESC1_PWM

;;		ESC2_PWM();
CLINEA 0000H 0001H 046FH 0003H 000DH
	bl	_ESC2_PWM

;;		ESC3_PWM();
CLINEA 0000H 0001H 0470H 0003H 000DH
	bl	_ESC3_PWM

;;		ESC4_PWM();
CLINEA 0000H 0001H 0471H 0003H 000DH
	bl	_ESC4_PWM

;;		PD0DIR = 1;
CLINEA 0000H 0001H 0473H 0003H 000DH
	sb	0f269h.0

;;		PD1DIR = 1;
CLINEA 0000H 0001H 0474H 0003H 000DH
	sb	0f269h.1

;;		PD2DIR = 0;
CLINEA 0000H 0001H 0475H 0003H 000DH
	rb	0f269h.2

;;		PWMUpperLowerDiff = PWMUpperDutyLimitRun-PWMLowerDutyLimitRun;
CLINEA 0000H 0001H 0477H 0003H 0040H
	l	er0,	NEAR _PWMUpperDutyLimitRun
	l	er2,	NEAR _PWMLowerDutyLimitRun
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	NEAR _PWMUpperLowerDiff

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 047AH 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 047BH 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( MPU6050Address, &AccGyro_PWRMGMT1REG, 1, &AccGyro_PWRMGMT1REG_Contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 047CH 0002H 008DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_PWRMGMT1REG_Contents
	mov	r1,	#BYTE2 OFFSET _AccGyro_PWRMGMT1REG_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_PWRMGMT1REG
	mov	r3,	#BYTE2 OFFSET _AccGyro_PWRMGMT1REG
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 047DH 0001H 0015H
	bal	_$L159

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 047DH 0002H 004EH
_$L121 :
CBLOCK 207 3 1149

;;		main_clrWDT();
CLINEA 0000H 0001H 047EH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 3 1151

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 047DH 0001H 0015H
_$L159 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 047DH 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L121

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 0481H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 0482H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( MPU6050Address, &AccGyro_AccelConfig, 1, &AccGyro_AccelConfig_Contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 0483H 0002H 008DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_AccelConfig_Contents
	mov	r1,	#BYTE2 OFFSET _AccGyro_AccelConfig_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_AccelConfig
	mov	r3,	#BYTE2 OFFSET _AccGyro_AccelConfig
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0484H 0001H 0015H
	bal	_$L160

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0484H 0002H 004EH
_$L125 :
CBLOCK 207 4 1156

;;		main_clrWDT();
CLINEA 0000H 0001H 0485H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 4 1158

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0484H 0001H 0015H
_$L160 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0484H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L125

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 0488H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 0489H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( MPU6050Address, &AccGyro_GyroConfig, 1, &AccGyro_GyroConfig_Contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 048AH 0002H 008BH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_GyroConfig_Contents
	mov	r1,	#BYTE2 OFFSET _AccGyro_GyroConfig_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_GyroConfig
	mov	r3,	#BYTE2 OFFSET _AccGyro_GyroConfig
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 048BH 0001H 0015H
	bal	_$L161

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 048BH 0002H 004EH
_$L129 :
CBLOCK 207 5 1163

;;		main_clrWDT();
CLINEA 0000H 0001H 048CH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 5 1165

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 048BH 0001H 0015H
_$L161 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 048BH 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L129

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 0490H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 0491H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( MPU6050Address, &AccGyro_GyroAccel_SMPRTDIV, 1, &AccGyro_GyroAccelLPF_SMPRTDIVContents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 0492H 0002H 009DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_GyroAccelLPF_SMPRTDIVCo
	mov	r1,	#BYTE2 OFFSET _AccGyro_GyroAccelLPF_SMPRTDIVCo
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_GyroAccel_SMPRTDIV
	mov	r3,	#BYTE2 OFFSET _AccGyro_GyroAccel_SMPRTDIV
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0493H 0001H 0015H
	bal	_$L162

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0493H 0002H 004EH
_$L133 :
CBLOCK 207 6 1171

;;		main_clrWDT();
CLINEA 0000H 0001H 0494H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 6 1173

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0493H 0001H 0015H
_$L162 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0493H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L133

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 0498H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 0499H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( MPU6050Address, &AccGyro_GyroAccelLPF, 1, &AccGyro_GyroAccelLPF_Contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 049AH 0002H 008FH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_GyroAccelLPF_Contents
	mov	r1,	#BYTE2 OFFSET _AccGyro_GyroAccelLPF_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_GyroAccelLPF
	mov	r3,	#BYTE2 OFFSET _AccGyro_GyroAccelLPF
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 049BH 0001H 0015H
	bal	_$L163

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 049BH 0002H 004EH
_$L137 :
CBLOCK 207 7 1179

;;		main_clrWDT();
CLINEA 0000H 0001H 049CH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 7 1181

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 049BH 0001H 0015H
_$L163 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 049BH 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L137

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 04A0H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 04A1H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( MPU6050Address, &AccGyro_INTENABLEReg, 1, &AccGyro_INTENABLEReg_contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 04A2H 0002H 008FH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_INTENABLEReg_contents
	mov	r1,	#BYTE2 OFFSET _AccGyro_INTENABLEReg_contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_INTENABLEReg
	mov	r3,	#BYTE2 OFFSET _AccGyro_INTENABLEReg
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04A3H 0001H 0015H
	bal	_$L164

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04A3H 0002H 004EH
_$L141 :
CBLOCK 207 8 1187

;;		main_clrWDT();
CLINEA 0000H 0001H 04A4H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 8 1189

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04A3H 0001H 0015H
_$L164 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04A3H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L141

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 04A8H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 04A9H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( HMC5883Address, &Mag_ConfigA, 1, &Mag_ConfigA_Contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 04AAH 0002H 007DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _Mag_ConfigA_Contents
	mov	r1,	#BYTE2 OFFSET _Mag_ConfigA_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _Mag_ConfigA
	mov	r3,	#BYTE2 OFFSET _Mag_ConfigA
	l	r0,	NEAR _HMC5883Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04ABH 0001H 0015H
	bal	_$L165

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04ABH 0002H 004EH
_$L145 :
CBLOCK 207 9 1195

;;		main_clrWDT();
CLINEA 0000H 0001H 04ACH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 9 1197

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04ABH 0001H 0015H
_$L165 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04ABH 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L145

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 04AFH 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 04B0H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( HMC5883Address, &Mag_ConfigB, 1, &Mag_ConfigB_Contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 04B1H 0002H 007DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _Mag_ConfigB_Contents
	mov	r1,	#BYTE2 OFFSET _Mag_ConfigB_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _Mag_ConfigB
	mov	r3,	#BYTE2 OFFSET _Mag_ConfigB
	l	r0,	NEAR _HMC5883Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04B2H 0001H 0015H
	bal	_$L166

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04B2H 0002H 004EH
_$L149 :
CBLOCK 207 10 1202

;;		main_clrWDT();
CLINEA 0000H 0001H 04B3H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 10 1204

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04B2H 0001H 0015H
_$L166 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04B2H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L149

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 04B6H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 04B7H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( HMC5883Address, &Mag_ModeReg, 1, &Mag_ModeReg_Contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 04B8H 0002H 007DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _Mag_ModeReg_Contents
	mov	r1,	#BYTE2 OFFSET _Mag_ModeReg_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _Mag_ModeReg
	mov	r3,	#BYTE2 OFFSET _Mag_ModeReg
	l	r0,	NEAR _HMC5883Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04B9H 0001H 0015H
	bal	_$L167

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04B9H 0002H 004EH
_$L153 :
CBLOCK 207 11 1209

;;		main_clrWDT();
CLINEA 0000H 0001H 04BAH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 11 1211

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04B9H 0001H 0015H
_$L167 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04B9H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L153

;;	EPB3 = 0;
CLINEA 0000H 0001H 04BEH 0002H 000AH
	rb	0f011h.7

;;	_flgI2CFin = 0;																	//reset I2C completed Flag
CLINEA 0000H 0001H 04C1H 0002H 003BH
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();																		//Make sure I2C is not currently running
CLINEA 0000H 0001H 04C2H 0002H 0046H
	bl	_i2c_stop

;;	I20MD = 1;		//Switch to I2C Fast Operation (400kbps)
CLINEA 0000H 0001H 04C3H 0002H 0035H
	sb	0f2a4h.1

;;	i2c_startReceive(MPU6050Address, &AccGyro_ReadData, 1, &AccGyro_Data, 14, (cbfI2c)_funcI2CFin);	//Begin I2C Receive Command
CLINEA 0000H 0001H 04C4H 0002H 007CH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#14
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_Data
	mov	r1,	#BYTE2 OFFSET _AccGyro_Data
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_ReadData
	mov	r3,	#BYTE2 OFFSET _AccGyro_ReadData
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startReceive
	add	sp,	#8 

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04C5H 0001H 0015H
	bal	_$L168

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04C5H 0002H 0051H
_$L157 :
CBLOCK 207 12 1221

;;		main_clrWDT();
CLINEA 0000H 0001H 04C6H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 207 12 1227

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04C5H 0001H 0015H
_$L168 :

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04C5H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L157

;;	PD1C1 = 1;
CLINEA 0000H 0001H 04CFH 0002H 000BH
	sb	0f26bh.1

;;	PD1C0 = 1;
CLINEA 0000H 0001H 04D0H 0002H 000BH
	sb	0f26ah.1

;;	PC6DIR = 1;
CLINEA 0000H 0001H 04D3H 0002H 000CH
	sb	0f261h.6

;;	PC6C0 = 1;
CLINEA 0000H 0001H 04D4H 0002H 000BH
	sb	0f262h.6

;;	PC6C1 = 1;
CLINEA 0000H 0001H 04D5H 0002H 000BH
	sb	0f263h.6

;;	PC6MD0 = 0;
CLINEA 0000H 0001H 04D6H 0002H 000CH
	rb	0f264h.6

;;	PC6MD1 = 0;
CLINEA 0000H 0001H 04D7H 0002H 000CH
	rb	0f265h.6
CBLOCKEND 207 2 1243

;;}//End Initialization
CLINEA 0000H 0001H 04DBH 0001H 0015H
	pop	pc
CBLOCKEND 207 1 1243
CFUNCTIONEND 207


	rseg $$Get_RangeData$main
CFUNCTION 219

_Get_RangeData	:
CBLOCK 219 1 1249

;;void Get_RangeData(void){
CLINEA 0000H 0001H 04E1H 0001H 0019H
	push	lr
CBLOCK 219 2 1249
CRET 0000H

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 04E3H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 04E4H 0002H 0043H
	bl	_i2c_stop

;;	I20MD = 0;		//Switch to I2C Standard Operation (100kbps)
CLINEA 0000H 0001H 04E5H 0002H 0039H
	rb	0f2a4h.1

;;	i2c_startSend( Range_Address, &Range_TakeRangeReading, 1, &AccGyro_PWRMGMT1REG_Contents, 0, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 04E6H 0002H 008FH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#0 
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_PWRMGMT1REG_Contents
	mov	r1,	#BYTE2 OFFSET _AccGyro_PWRMGMT1REG_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _Range_TakeRangeReading
	mov	r3,	#BYTE2 OFFSET _Range_TakeRangeReading
	l	r0,	NEAR _Range_Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04E7H 0001H 0001H
	bal	_$L182

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04E7H 0002H 004EH
_$L172 :
CBLOCK 219 3 1255

;;		main_clrWDT();
CLINEA 0000H 0001H 04E8H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 219 3 1257

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04E7H 0001H 0001H
_$L182 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04E7H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L172

;;	}
CLINEA 0000H 0000H 04E9H 0002H 0002H
_$L171 :

;;	while(RANGE_STAT==1);
CLINEA 0000H 0000H 04EAH 000CH 000FH
	tb	0f260h.6
	bne	_$L171

;;	_flgI2CFin = 0;																	//reset I2C completed Flag
CLINEA 0000H 0001H 04EDH 0002H 003BH
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();																		//Make sure I2C is not currently running
CLINEA 0000H 0001H 04EEH 0002H 0046H
	bl	_i2c_stop

;;	i2c_startReceive(Range_Address, &Range_TakeRangeReading, 0, &Range_Output, 2, (cbfI2c)_funcI2CFin);	//Begin I2C Receive Command
CLINEA 0000H 0001H 04EFH 0002H 0080H
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#2 
	push	er0
	mov	r0,	#BYTE1 OFFSET _Range_Output
	mov	r1,	#BYTE2 OFFSET _Range_Output
	push	er0
	mov	er0,	#0 
	push	er0
	mov	r2,	#BYTE1 OFFSET _Range_TakeRangeReading
	mov	r3,	#BYTE2 OFFSET _Range_TakeRangeReading
	l	r0,	NEAR _Range_Address
	bl	_i2c_startReceive
	add	sp,	#8 

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04F0H 0001H 0001H
	bal	_$L183

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04F0H 0002H 0051H
_$L180 :
CBLOCK 219 4 1264

;;		main_clrWDT();
CLINEA 0000H 0001H 04F1H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 219 4 1266

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04F0H 0001H 0001H
_$L183 :

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 04F0H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L180

;;	Range_out = (Range_Output[0]<<8)+(Range_Output[1]);
CLINEA 0000H 0001H 04F4H 0002H 0034H
	l	r0,	NEAR _Range_Output+01h
	mov	r1,	#00h
	l	r2,	NEAR _Range_Output
	mov	r3,	r2
	mov	r2,	#00h
	add	er0,	er2
	st	er0,	NEAR _Range_out

;;	I20MD = 1;		//Switch Back to I2C Fast Operation (400kbps)
CLINEA 0000H 0001H 04F5H 0002H 003AH
	sb	0f2a4h.1
CBLOCKEND 219 2 1270

;;}
CLINEA 0000H 0001H 04F6H 0001H 0001H
	pop	pc
CBLOCKEND 219 1 1270
CFUNCTIONEND 219


	rseg $$Get_PingData$main
CFUNCTION 220

_Get_PingData	:
CBLOCK 220 1 1272

;;void Get_PingData(void){
CLINEA 0000H 0001H 04F8H 0001H 0018H
	push	lr
	push	xr4
CBLOCK 220 2 1272
CRET 0004H

;;	PD1DIR = 0;		// PortD Bit0 set to Output Mode...
CLINEA 0000H 0001H 04FBH 0002H 0031H
	rb	0f269h.1

;;	PingSensor = 1;
CLINEA 0000H 0001H 04FCH 0002H 0010H
	sb	0f268h.1

;;	NOPus();
CLINEA 0000H 0001H 04FDH 0002H 0009H
	bl	_NOPus

;;	PingSensor = 0;
CLINEA 0000H 0001H 04FEH 0002H 0010H
	rb	0f268h.1

;;	PD1DIR = 1;		// PortD Bit0 set to Input Mode...
CLINEA 0000H 0001H 0501H 0002H 0030H
	sb	0f269h.1

;;	while(PingSensor == 0){
CLINEA 0000H 0001H 0502H 0002H 0018H
	bal	_$L185
_$L187 :
CBLOCK 220 3 1282

;;		NOPus();
CLINEA 0000H 0001H 0503H 0003H 000AH
	bl	_NOPus
CBLOCKEND 220 3 1284

;;	}
CLINEA 0000H 0000H 0504H 0002H 0002H
_$L185 :

;;	while(PingSensor == 0){
CLINEA 0000H 0000H 0502H 000CH 000FH
	tb	0f268h.1
	beq	_$L187

;;	while(PingSensor ==1){
CLINEA 0000H 0001H 0505H 0002H 0017H
	bal	_$L189
_$L191 :
CBLOCK 220 4 1285

;;		NOPus();
CLINEA 0000H 0001H 0506H 0003H 000AH
	bl	_NOPus

;;		Ping_timer++;
CLINEA 0000H 0000H 0507H 0003H 000FH
	l	er0,	NEAR _Ping_timer
	add	er0,	#1 
	st	er0,	NEAR _Ping_timer
CBLOCKEND 220 4 1288

;;	}
CLINEA 0000H 0000H 0508H 0002H 0002H
_$L189 :

;;	while(PingSensor ==1){
CLINEA 0000H 0000H 0505H 000CH 000FH
	tb	0f268h.1
	bne	_$L191

;;	Ping_timer *= 11;	//Convert the ping timer response to us
CLINEA 0000H 0001H 0509H 0002H 003AH
	l	er0,	NEAR _Ping_timer
	mov	er2,	er0
	sllc	r1,	#02h
	sll	r0,	#02h
	add	er0,	er2
	add	er0,	er0
	add	er0,	er2
	st	er0,	NEAR _Ping_timer

;;	Ping_out = (0.0162*Ping_timer) + 0.1359; //Convert us to distance based on Datasheet
CLINEA 0000H 0001H 050AH 0002H 0055H
	mov	er2,	#0 
	push	xr0
	add	sp,	#-4
	bl	__dildu8sw
	mov	r0,	#082h
	mov	r1,	#0e2h
	mov	r2,	#0c7h
	mov	r3,	#098h
	mov	r4,	#0bbh
	mov	r5,	#096h
	mov	r6,	#090h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	mov	r0,	#013h
	mov	r1,	#061h
	mov	r2,	#0c3h
	mov	r3,	#0d3h
	mov	r4,	#02bh
	mov	r5,	#065h
	mov	r6,	#0c1h
	push	qr0
	bl	__daddu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Ping_out
	st	er2,	NEAR _Ping_out+02h
CBLOCKEND 220 2 1292

;;}
CLINEA 0000H 0001H 050CH 0001H 0001H
	pop	xr4
	pop	pc
CBLOCKEND 220 1 1292
CFUNCTIONEND 220


	rseg $$Get_AccGyroData$main
CFUNCTION 221

_Get_AccGyroData	:
CBLOCK 221 1 1294

;;void Get_AccGyroData(void){
CLINEA 0000H 0001H 050EH 0001H 001BH
	push	lr
	push	xr8
	push	er4
CBLOCK 221 2 1294
CRET 0006H
CSLOCAL 43H 0002H 0000H 0002H "i" 02H 00H 01H

;;	EPB3 = 0;		//Turn off Accel/Gyro Interrupt.  This can probably be removed...
CLINEA 0000H 0001H 0516H 0002H 004DH
	rb	0f011h.7

;;	_flgI2CFin = 0;																	//reset I2C completed Flag
CLINEA 0000H 0001H 0518H 0002H 003BH
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();																		//Make sure I2C is not currently running
CLINEA 0000H 0001H 0519H 0002H 0046H
	bl	_i2c_stop

;;	I20MD = 1;		//Switch to I2C Fast Operation (400kbps)
CLINEA 0000H 0001H 051AH 0002H 0035H
	sb	0f2a4h.1

;;	i2c_startReceive(MPU6050Address, &AccGyro_ReadData, 1, &AccGyro_Data, 14, (cbfI2c)_funcI2CFin);	//Begin I2C Receive Command
CLINEA 0000H 0001H 051BH 0002H 007CH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#14
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_Data
	mov	r1,	#BYTE2 OFFSET _AccGyro_Data
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_ReadData
	mov	r3,	#BYTE2 OFFSET _AccGyro_ReadData
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startReceive
	add	sp,	#8 

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 051CH 0001H 0001H
	bal	_$L206

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 051CH 0002H 0051H
_$L196 :
CBLOCK 221 3 1308

;;		main_clrWDT();
CLINEA 0000H 0001H 051DH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 221 3 1310

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 051CH 0001H 0001H
_$L206 :

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 051CH 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L196

;;	Accel_Xout[Accel_SavIndex] = (AccGyro_Data[0]<<8)+(AccGyro_Data[1]);
CLINEA 0000H 0001H 0521H 0002H 0045H
	l	r0,	NEAR _AccGyro_Data+01h
	mov	r1,	#00h
	l	r2,	NEAR _AccGyro_Data
	mov	r3,	r2
	mov	r2,	#00h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	l	r4,	NEAR _Accel_SavIndex
	mov	r5,	#00h
	sllc	r5,	#02h
	sll	r4,	#02h
	st	er0,	NEAR _Accel_Xout[er4]
	st	er2,	NEAR _Accel_Xout+02h[er4]

;;	Accel_Yout[Accel_SavIndex] = (AccGyro_Data[2]<<8)+(AccGyro_Data[3]);
CLINEA 0000H 0001H 0522H 0002H 0045H
	l	r0,	NEAR _AccGyro_Data+02h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+03h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	st	er0,	NEAR _Accel_Yout[er4]
	st	er2,	NEAR _Accel_Yout+02h[er4]

;;	Accel_Zout[Accel_SavIndex] = (AccGyro_Data[4]<<8)+(AccGyro_Data[5]);
CLINEA 0000H 0001H 0523H 0002H 0045H
	l	r0,	NEAR _AccGyro_Data+04h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+05h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	st	er0,	NEAR _Accel_Zout[er4]
	st	er2,	NEAR _Accel_Zout+02h[er4]

;;	Gyro_Xout = (AccGyro_Data[8]<<8)+(AccGyro_Data[9]);
CLINEA 0000H 0001H 052CH 0002H 0034H
	l	r0,	NEAR _AccGyro_Data+08h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+09h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	st	er0,	NEAR _Gyro_Xout
	st	er2,	NEAR _Gyro_Xout+02h

;;	Gyro_Yout = (AccGyro_Data[10]<<8)+(AccGyro_Data[11]);
CLINEA 0000H 0001H 052DH 0002H 0036H
	l	r0,	NEAR _AccGyro_Data+0ah
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+0bh
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	st	er0,	NEAR _Gyro_Yout
	st	er2,	NEAR _Gyro_Yout+02h

;;	Gyro_Zout = (AccGyro_Data[12]<<8)+(AccGyro_Data[13]);
CLINEA 0000H 0001H 052EH 0002H 0036H
	l	r0,	NEAR _AccGyro_Data+0ch
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+0dh
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	st	er0,	NEAR _Gyro_Zout
	st	er2,	NEAR _Gyro_Zout+02h

;;	Accel_Xout[Accel_SavIndex] -= Accel_Xcal[0];
CLINEA 0000H 0001H 0530H 0002H 002DH
	l	er0,	NEAR _Accel_Xout[er4]
	l	er2,	NEAR _Accel_Xout+02h[er4]
	push	xr0
	l	er0,	NEAR _Accel_Xcal
	l	er2,	NEAR _Accel_Xcal+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xout[er4]
	st	er2,	NEAR _Accel_Xout+02h[er4]

;;	Accel_Yout[Accel_SavIndex] -= Accel_Ycal[0];
CLINEA 0000H 0001H 0531H 0002H 002DH
	l	er0,	NEAR _Accel_Yout[er4]
	l	er2,	NEAR _Accel_Yout+02h[er4]
	push	xr0
	l	er0,	NEAR _Accel_Ycal
	l	er2,	NEAR _Accel_Ycal+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Yout[er4]
	st	er2,	NEAR _Accel_Yout+02h[er4]

;;	Accel_Zout[Accel_SavIndex] -= Accel_Zcal[0];
CLINEA 0000H 0001H 0532H 0002H 002DH
	l	er0,	NEAR _Accel_Zout[er4]
	l	er2,	NEAR _Accel_Zout+02h[er4]
	push	xr0
	l	er0,	NEAR _Accel_Zcal
	l	er2,	NEAR _Accel_Zcal+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Zout[er4]
	st	er2,	NEAR _Accel_Zout+02h[er4]

;;	Gyro_Xout -= Gyro_Xcal;
CLINEA 0000H 0001H 0534H 0002H 0018H
	l	er0,	NEAR _Gyro_Xout
	l	er2,	NEAR _Gyro_Xout+02h
	push	xr0
	l	er0,	NEAR _Gyro_Xcal
	l	er2,	NEAR _Gyro_Xcal+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Xout
	st	er2,	NEAR _Gyro_Xout+02h

;;	Gyro_Yout -= Gyro_Ycal;
CLINEA 0000H 0001H 0535H 0002H 0018H
	l	er0,	NEAR _Gyro_Yout
	l	er2,	NEAR _Gyro_Yout+02h
	push	xr0
	l	er0,	NEAR _Gyro_Ycal
	l	er2,	NEAR _Gyro_Ycal+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Yout
	st	er2,	NEAR _Gyro_Yout+02h

;;	Gyro_Zout -= Gyro_Zcal;
CLINEA 0000H 0001H 0536H 0002H 0018H
	l	er0,	NEAR _Gyro_Zout
	l	er2,	NEAR _Gyro_Zout+02h
	push	xr0
	l	er0,	NEAR _Gyro_Zcal
	l	er2,	NEAR _Gyro_Zcal+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Zout
	st	er2,	NEAR _Gyro_Zout+02h

;;	for(i=0; i<AccelAvg; i++)
CLINEA 0000H 0001H 0538H 0002H 001AH
	mov	er0,	#0 
	st	er0,	NEAR _$ST0
_$L200 :
CBLOCK 221 4 1337

;;		Accel_Xout_Avg += Accel_Xout[i];
CLINEA 0000H 0001H 053AH 0003H 0022H
	mov	er4,	er0
	sllc	r5,	#02h
	sll	r4,	#02h
	l	er8,	NEAR _Accel_Xout[er4]
	l	er10,	NEAR _Accel_Xout+02h[er4]
	push	xr8
	l	er0,	NEAR _Accel_Xout_Avg
	l	er2,	NEAR _Accel_Xout_Avg+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xout_Avg
	st	er2,	NEAR _Accel_Xout_Avg+02h

;;		Accel_Yout_Avg += Accel_Yout[i];
CLINEA 0000H 0001H 053BH 0003H 0022H
	l	er8,	NEAR _Accel_Yout[er4]
	l	er10,	NEAR _Accel_Yout+02h[er4]
	push	xr8
	l	er0,	NEAR _Accel_Yout_Avg
	l	er2,	NEAR _Accel_Yout_Avg+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Yout_Avg
	st	er2,	NEAR _Accel_Yout_Avg+02h

;;		Accel_Zout_Avg += Accel_Zout[i];
CLINEA 0000H 0001H 053CH 0003H 0022H
	l	er0,	NEAR _Accel_Zout[er4]
	l	er2,	NEAR _Accel_Zout+02h[er4]
	push	xr0
	l	er0,	NEAR _Accel_Zout_Avg
	l	er2,	NEAR _Accel_Zout_Avg+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Zout_Avg
	st	er2,	NEAR _Accel_Zout_Avg+02h
CBLOCKEND 221 4 1341

;;	for(i=0; i<AccelAvg; i++)
CLINEA 0000H 0000H 0538H 0002H 001AH
	l	er0,	NEAR _$ST0
	add	er0,	#1 
	st	er0,	NEAR _$ST0

;;	for(i=0; i<AccelAvg; i++)
CLINEA 0000H 0000H 0538H 000CH 000FH
	cmp	r0,	#011h
	cmpc	r1,	#00h
	blts	_$L200

;;	Accel_Xout_Avg /= AccelAvg;
CLINEA 0000H 0001H 053EH 0002H 001CH
	l	er0,	NEAR _Accel_Xout_Avg
	l	er2,	NEAR _Accel_Xout_Avg+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#088h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xout_Avg
	st	er2,	NEAR _Accel_Xout_Avg+02h

;;	Accel_Yout_Avg /= AccelAvg;
CLINEA 0000H 0001H 053FH 0002H 001CH
	l	er0,	NEAR _Accel_Yout_Avg
	l	er2,	NEAR _Accel_Yout_Avg+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#088h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Yout_Avg
	st	er2,	NEAR _Accel_Yout_Avg+02h

;;	Accel_Zout_Avg /= AccelAvg;
CLINEA 0000H 0001H 0540H 0002H 001CH
	l	er0,	NEAR _Accel_Zout_Avg
	l	er2,	NEAR _Accel_Zout_Avg+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#088h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Zout_Avg
	st	er2,	NEAR _Accel_Zout_Avg+02h

;;	Accel_SavIndex++;
CLINEA 0000H 0000H 0543H 0002H 0012H
	lea	OFFSET _Accel_SavIndex
	inc	[ea]
	l	r0,	NEAR _Accel_SavIndex

;;	if(Accel_SavIndex >= AccelAvg){
CLINEA 0000H 0001H 0544H 0002H 0020H
	cmp	r0,	#011h
	blt	_$L204
CBLOCK 221 5 1348

;;		Accel_SavIndex = 0;
CLINEA 0000H 0001H 0545H 0003H 0015H
	mov	r0,	#00h
	st	r0,	NEAR _Accel_SavIndex
CBLOCKEND 221 5 1350

;;	}
CLINEA 0000H 0000H 0546H 0002H 0002H
_$L204 :

;;	EPB3 = 1;		//Turns Accel/Gyro Interrupt back on... again, this may not be necessary
CLINEA 0000H 0001H 0549H 0002H 0054H
	sb	0f011h.7

;;	AccGyro_CF_FlagCounter++;	//Counts up to the number of values are in the buffer so main loop can call CF filter function
CLINEA 0000H 0000H 054AH 0002H 0079H
	lea	OFFSET _AccGyro_CF_FlagCounter
	inc	[ea]
CBLOCKEND 221 2 1355

;;}
CLINEA 0000H 0001H 054BH 0001H 0001H
	pop	er4
	pop	xr8
	pop	pc
CBLOCKEND 221 1 1355
CFUNCTIONEND 221


	rseg $$Run_AccGyroCF$main
CFUNCTION 222

_Run_AccGyroCF	:
CBLOCK 222 1 1357

;;void Run_AccGyroCF(void){
CLINEA 0000H 0001H 054DH 0001H 0019H
	push	lr
	push	fp
	mov	fp,	sp
	add	sp,	#-08
	push	xr4
CBLOCK 222 2 1357
CRET 000EH
CSLOCAL 43H 0002H 0001H 0002H "i" 02H 00H 01H
CSLOCAL 43H 0001H 0002H 0002H "I2CCont" 02H 00H 00H

;;	CF_Gyro_CurrentCount = CF_Gyro_Counter * .001;		//Timer in Seconds (.007 used to convert 128Hz TBC to seconds)
CLINEA 0000H 0001H 0553H 0002H 006FH
	l	er0,	NEAR _CF_Gyro_Counter
	l	er2,	NEAR _CF_Gyro_Counter+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	r0,	#0fch
	mov	r1,	#0a9h
	mov	r2,	#0f1h
	mov	r3,	#0d2h
	mov	r4,	#04dh
	mov	r5,	#062h
	mov	r6,	#050h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_Gyro_CurrentCount
	st	er2,	NEAR _CF_Gyro_CurrentCount+02h

;;	CF_Gyro_Counter = 0;
CLINEA 0000H 0001H 0554H 0002H 0015H
	mov	er0,	#0 
	st	er0,	NEAR _CF_Gyro_Counter
	st	er0,	NEAR _CF_Gyro_Counter+02h

;;	CF_Gyro_YPitch = CF_YPitch + ((Gyro_Xout/AccGyro_GyroScaling) * CF_Gyro_CurrentCount);
CLINEA 0000H 0001H 0556H 0002H 0057H
	l	er0,	NEAR _Gyro_Xout
	l	er2,	NEAR _Gyro_Xout+02h
	push	xr0
	l	er0,	NEAR _AccGyro_GyroScaling
	l	er2,	NEAR _AccGyro_GyroScaling+02h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	l	er0,	NEAR _CF_Gyro_CurrentCount
	l	er2,	NEAR _CF_Gyro_CurrentCount+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	l	er0,	NEAR _CF_YPitch
	l	er2,	NEAR _CF_YPitch+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_Gyro_YPitch
	st	er2,	NEAR _CF_Gyro_YPitch+02h

;;	CF_Gyro_XRoll = CF_XRoll - ((Gyro_Yout/AccGyro_GyroScaling) * CF_Gyro_CurrentCount);	
CLINEA 0000H 0001H 0557H 0002H 0056H
	l	er0,	NEAR _Gyro_Yout
	l	er2,	NEAR _Gyro_Yout+02h
	push	xr0
	l	er0,	NEAR _AccGyro_GyroScaling
	l	er2,	NEAR _AccGyro_GyroScaling+02h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	l	er0,	NEAR _CF_Gyro_CurrentCount
	l	er2,	NEAR _CF_Gyro_CurrentCount+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _CF_XRoll
	l	er6,	NEAR _CF_XRoll+02h
	push	qr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_Gyro_XRoll
	st	er2,	NEAR _CF_Gyro_XRoll+02h

;;	CF_Accel_ForceMagApprox = abs(Accel_Xout_Avg) + abs(Accel_Yout_Avg) + abs(Accel_Zout_Avg);
CLINEA 0000H 0000H 0559H 0002H 005BH
	l	er0,	NEAR _Accel_Xout_Avg
	l	er2,	NEAR _Accel_Xout_Avg+02h
	push	xr0
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	bl	_abs
	mov	er4,	er0
	l	er0,	NEAR _Accel_Yout_Avg
	l	er2,	NEAR _Accel_Yout_Avg+02h
	push	xr0
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	bl	_abs
	add	er4,	er0
	l	er0,	NEAR _Accel_Zout_Avg
	l	er2,	NEAR _Accel_Zout_Avg+02h
	push	xr0
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	bl	_abs
	mov	er2,	er0
	mov	er0,	er4
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	st	er0,	NEAR _CF_Accel_ForceMagApprox
	st	er2,	NEAR _CF_Accel_ForceMagApprox+02h

;;	if (CF_Accel_ForceMagApprox > 16384 && CF_Accel_ForceMagApprox < 32768)
CLINEA 0000H 0001H 055AH 0002H 0048H
	push	xr0
	mov	er0,	#0 
	mov	r2,	#080h
	mov	r3,	#046h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bgt	_$M10
	b	_$L208
_$M10 :
	l	er0,	NEAR _CF_Accel_ForceMagApprox
	l	er2,	NEAR _CF_Accel_ForceMagApprox+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#00h
	mov	r3,	#047h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$M11
	b	_$L208
_$M11 :
CBLOCK 222 3 1371

;;        CF_Accel_YPitch = atan2(Accel_Yout_Avg, Accel_Zout_Avg) * (57.29);	//57.29 = 180deg/pi
CLINEA 0000H 0000H 055DH 0009H 005EH
	l	er0,	NEAR _Accel_Zout_Avg
	l	er2,	NEAR _Accel_Zout_Avg+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_Yout_Avg
	l	er2,	NEAR _Accel_Yout_Avg+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	er0,	fp
	add	er0,	#-8
	bl	_atan2
	add	sp,	#16
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#085h
	mov	r1,	#0ebh
	mov	r2,	#051h
	mov	r3,	#0b8h
	mov	r4,	#01eh
	mov	r5,	#0a5h
	mov	r6,	#04ch
	mov	r7,	#040h
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_Accel_YPitch
	st	er2,	NEAR _CF_Accel_YPitch+02h

;;        CF_YPitch = (CF_Gyro_YPitch * CF_HPF) + (CF_Accel_YPitch * CF_LPF);
CLINEA 0000H 0001H 055EH 0009H 004BH
	l	er0,	NEAR _CF_Gyro_YPitch
	l	er2,	NEAR _CF_Gyro_YPitch+02h
	push	xr0
	l	er0,	NEAR _CF_HPF
	l	er2,	NEAR _CF_HPF+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _CF_Accel_YPitch
	l	er6,	NEAR _CF_Accel_YPitch+02h
	push	xr4
	l	er4,	NEAR _CF_LPF
	l	er6,	NEAR _CF_LPF+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_YPitch
	st	er2,	NEAR _CF_YPitch+02h

;;        CF_Accel_XRoll = atan2(Accel_Xout_Avg, Accel_Zout_Avg) * (57.29);
CLINEA 0000H 0000H 0561H 0009H 0049H
	l	er0,	NEAR _Accel_Zout_Avg
	l	er2,	NEAR _Accel_Zout_Avg+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_Xout_Avg
	l	er2,	NEAR _Accel_Xout_Avg+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	er0,	fp
	add	er0,	#-8
	bl	_atan2
	add	sp,	#16
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#085h
	mov	r1,	#0ebh
	mov	r2,	#051h
	mov	r3,	#0b8h
	mov	r4,	#01eh
	mov	r5,	#0a5h
	mov	r6,	#04ch
	mov	r7,	#040h
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_Accel_XRoll
	st	er2,	NEAR _CF_Accel_XRoll+02h

;;        CF_XRoll = (CF_Gyro_XRoll * CF_HPF) + (CF_Accel_XRoll * CF_LPF);
CLINEA 0000H 0001H 0562H 0009H 0048H
	l	er0,	NEAR _CF_Gyro_XRoll
	l	er2,	NEAR _CF_Gyro_XRoll+02h
	push	xr0
	l	er0,	NEAR _CF_HPF
	l	er2,	NEAR _CF_HPF+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _CF_Accel_XRoll
	l	er6,	NEAR _CF_Accel_XRoll+02h
	push	xr4
	l	er4,	NEAR _CF_LPF
	l	er6,	NEAR _CF_LPF+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
CBLOCKEND 222 3 1379

;;	else{
CLINEA 0000H 0001H 0564H 0002H 0006H
	b	_$L215
_$L208 :
CBLOCK 222 4 1380

;;        CF_Accel_YPitch = atan2(Accel_Yout_Avg, Accel_Zout_Avg) * (57.29);	//57.29 = 180deg/pi
CLINEA 0000H 0000H 0566H 0009H 005EH
	l	er0,	NEAR _Accel_Zout_Avg
	l	er2,	NEAR _Accel_Zout_Avg+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_Yout_Avg
	l	er2,	NEAR _Accel_Yout_Avg+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	er0,	fp
	add	er0,	#-8
	bl	_atan2
	add	sp,	#16
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#085h
	mov	r1,	#0ebh
	mov	r2,	#051h
	mov	r3,	#0b8h
	mov	r4,	#01eh
	mov	r5,	#0a5h
	mov	r6,	#04ch
	mov	r7,	#040h
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_Accel_YPitch
	st	er2,	NEAR _CF_Accel_YPitch+02h

;;		CF_YPitch = CF_Gyro_YPitch;
CLINEA 0000H 0001H 0567H 0003H 001DH
	l	er0,	NEAR _CF_Gyro_YPitch
	l	er2,	NEAR _CF_Gyro_YPitch+02h
	st	er0,	NEAR _CF_YPitch
	st	er2,	NEAR _CF_YPitch+02h

;;        CF_Accel_XRoll = atan2(Accel_Xout_Avg, Accel_Zout_Avg) * (57.29);
CLINEA 0000H 0000H 056AH 0009H 0049H
	l	er0,	NEAR _Accel_Zout_Avg
	l	er2,	NEAR _Accel_Zout_Avg+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_Xout_Avg
	l	er2,	NEAR _Accel_Xout_Avg+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	er0,	fp
	add	er0,	#-8
	bl	_atan2
	add	sp,	#16
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#085h
	mov	r1,	#0ebh
	mov	r2,	#051h
	mov	r3,	#0b8h
	mov	r4,	#01eh
	mov	r5,	#0a5h
	mov	r6,	#04ch
	mov	r7,	#040h
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_Accel_XRoll
	st	er2,	NEAR _CF_Accel_XRoll+02h

;;		CF_XRoll = CF_Gyro_XRoll;
CLINEA 0000H 0001H 056BH 0003H 001BH
	l	er0,	NEAR _CF_Gyro_XRoll
	l	er2,	NEAR _CF_Gyro_XRoll+02h
CBLOCKEND 222 4 1388

;;	}
CLINEA 0000H 0000H 056CH 0002H 0002H
_$L215 :
	st	er0,	NEAR _CF_XRoll
	st	er2,	NEAR _CF_XRoll+02h

;;	Accel_PID_GoCounter++;		//Counts up to 4 to trigger the PID loop to start.
CLINEA 0000H 0000H 058DH 0002H 004BH
	lea	OFFSET _Accel_PID_GoCounter
	inc	[ea]
CBLOCKEND 222 2 1423

;;}
CLINEA 0000H 0001H 058FH 0001H 0001H
	pop	xr4
	mov	sp,	fp
	pop	fp
	pop	pc
CBLOCKEND 222 1 1423
CFUNCTIONEND 222


	rseg $$Get_MagData$main
CFUNCTION 223

_Get_MagData	:
CBLOCK 223 1 1426

;;void Get_MagData(void){
CLINEA 0000H 0001H 0592H 0001H 0017H
	push	lr
	push	fp
	mov	fp,	sp
	add	sp,	#-08
	push	xr4
CBLOCK 223 2 1426
CRET 000EH

;;	_flgI2CFin = 0;														//reset I2C completed flag
CLINEA 0000H 0001H 0594H 0002H 0038H
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();															//Make sure I2C is not currently running
CLINEA 0000H 0001H 0595H 0002H 0043H
	bl	_i2c_stop

;;	i2c_startSend( HMC5883Address, &Mag_ModeReg, 1, &Mag_ModeReg_Contents, 1, (cbfI2c)_funcI2CFin);		//Begin I2C Receive Command
CLINEA 0000H 0001H 0596H 0002H 007DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r0,	#BYTE1 OFFSET _Mag_ModeReg_Contents
	mov	r1,	#BYTE2 OFFSET _Mag_ModeReg_Contents
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _Mag_ModeReg
	mov	r3,	#BYTE2 OFFSET _Mag_ModeReg
	l	r0,	NEAR _HMC5883Address
	bl	_i2c_startSend
	add	sp,	#8 

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0597H 0001H 0001H
	bal	_$L233

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0597H 0002H 004EH
_$L219 :
CBLOCK 223 3 1431

;;		main_clrWDT();
CLINEA 0000H 0001H 0598H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 223 3 1433

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0597H 0001H 0001H
_$L233 :

;;	while(_flgI2CFin != 1){												//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0597H 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L219

;;	_flgI2CFin = 0;																	//reset I2C completed Flag
CLINEA 0000H 0001H 059BH 0002H 003BH
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;	i2c_stop();																		//Make sure I2C is not currently running
CLINEA 0000H 0001H 059CH 0002H 0046H
	bl	_i2c_stop

;;	i2c_startReceive(HMC5883Address, &Mag_ReadData, 1, &Mag_Data, 6, (cbfI2c)_funcI2CFin);	//Begin I2C Recieve Command
CLINEA 0000H 0001H 059DH 0002H 0073H
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#6 
	push	er0
	mov	r0,	#BYTE1 OFFSET _Mag_Data
	mov	r1,	#BYTE2 OFFSET _Mag_Data
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _Mag_ReadData
	mov	r3,	#BYTE2 OFFSET _Mag_ReadData
	l	r0,	NEAR _HMC5883Address
	bl	_i2c_startReceive
	add	sp,	#8 

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 059EH 0001H 0001H
	bal	_$L234

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 059EH 0002H 0051H
_$L223 :
CBLOCK 223 4 1438

;;		main_clrWDT();
CLINEA 0000H 0001H 059FH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 223 4 1440

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 059EH 0001H 0001H
_$L234 :

;;	while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 059EH 000CH 000FH
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L223

;;	Mag_Zout = (Mag_Data[2]<<8)+(Mag_Data[3]);
CLINEA 0000H 0001H 05A4H 0002H 002BH
	l	r0,	NEAR _Mag_Data+02h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _Mag_Data+03h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	st	er0,	NEAR _Mag_Zout
	st	er2,	NEAR _Mag_Zout+02h

;;	Mag_Xout *= Mag_GainFactor;
CLINEA 0000H 0001H 05A6H 0002H 001CH
	l	r0,	NEAR _Mag_Data+01h
	mov	r1,	#00h
	l	r2,	NEAR _Mag_Data
	mov	r3,	r2
	mov	r2,	#00h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	l	er0,	NEAR _Mag_GainFactor
	l	er2,	NEAR _Mag_GainFactor+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_Xout
	st	er2,	NEAR _Mag_Xout+02h

;;	Mag_Yout *= Mag_GainFactor;
CLINEA 0000H 0001H 05A7H 0002H 001CH
	l	r0,	NEAR _Mag_Data+04h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _Mag_Data+05h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	l	er0,	NEAR _Mag_GainFactor
	l	er2,	NEAR _Mag_GainFactor+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_Yout
	st	er2,	NEAR _Mag_Yout+02h

;;	if(Mag_Yout >= 0){
CLINEA 0000H 0001H 05A9H 0002H 0013H
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$L225
CBLOCK 223 5 1449

;;		Mag_Angle = 90 - (atan(Mag_Xout/Mag_Yout)) * (180/3.1415927);
CLINEA 0000H 0000H 05AAH 0003H 003FH
	l	er0,	NEAR _Mag_Xout
	l	er2,	NEAR _Mag_Xout+02h
	push	xr0
	l	er0,	NEAR _Mag_Yout
	l	er2,	NEAR _Mag_Yout+02h
	push	xr0
	bl	__fdivu8sw
	bl	__ftodu8sw
	mov	er0,	fp
	add	er0,	#-8
	bl	_atan
	add	sp,	#8 
	mov	er0,	#0 
	mov	er2,	#0 
	mov	r4,	#00h
	mov	r5,	#080h
	mov	r6,	#056h
	mov	r7,	#040h
	push	qr0
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#04ah
	mov	r1,	#015h
	mov	r2,	#04ah
	mov	r3,	#013h
	mov	r4,	#0dch
	mov	r5,	#0a5h
	mov	r6,	#04ch
	mov	r7,	#040h
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dsubu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_Angle
	st	er2,	NEAR _Mag_Angle+02h
CBLOCKEND 223 5 1451

;;	}
CLINEA 0000H 0000H 05ABH 0002H 0002H
_$L225 :

;;	if(Mag_Yout < 0){
CLINEA 0000H 0001H 05ACH 0002H 0012H
	l	er0,	NEAR _Mag_Yout
	l	er2,	NEAR _Mag_Yout+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L227
CBLOCK 223 6 1452

;;		Mag_Angle = 270 - (atan(Mag_Xout/Mag_Yout)) * (180/3.1415927);
CLINEA 0000H 0000H 05ADH 0003H 0040H
	l	er0,	NEAR _Mag_Xout
	l	er2,	NEAR _Mag_Xout+02h
	push	xr0
	l	er0,	NEAR _Mag_Yout
	l	er2,	NEAR _Mag_Yout+02h
	push	xr0
	bl	__fdivu8sw
	bl	__ftodu8sw
	mov	er0,	fp
	add	er0,	#-8
	bl	_atan
	add	sp,	#8 
	mov	er0,	#0 
	mov	er2,	#0 
	mov	r4,	#00h
	mov	r5,	#0e0h
	mov	r6,	#070h
	mov	r7,	#040h
	push	qr0
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#04ah
	mov	r1,	#015h
	mov	r2,	#04ah
	mov	r3,	#013h
	mov	r4,	#0dch
	mov	r5,	#0a5h
	mov	r6,	#04ch
	mov	r7,	#040h
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dsubu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_Angle
	st	er2,	NEAR _Mag_Angle+02h
CBLOCKEND 223 6 1454

;;	}
CLINEA 0000H 0000H 05AEH 0002H 0002H
_$L227 :

;;	Mag_Angle -= 90;  //This will adjust and get the true 
CLINEA 0000H 0001H 05B0H 0002H 0037H
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#0b4h
	mov	r3,	#0c2h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_Angle
	st	er2,	NEAR _Mag_Angle+02h

;;	if(Mag_Angle >=360){
CLINEA 0000H 0001H 05B1H 0002H 0015H
	push	xr0
	mov	er0,	#0 
	mov	r2,	#0b4h
	mov	r3,	#043h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$L229
CBLOCK 223 7 1457

;;		Mag_Angle -= 360;
CLINEA 0000H 0001H 05B2H 0003H 0013H
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#0b4h
	mov	r3,	#0c3h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_Angle
	st	er2,	NEAR _Mag_Angle+02h
CBLOCKEND 223 7 1459

;;	}
CLINEA 0000H 0000H 05B3H 0002H 0002H
_$L229 :

;;	if(Mag_Angle < 0){
CLINEA 0000H 0001H 05B4H 0002H 0013H
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L231
CBLOCK 223 8 1460

;;		Mag_Angle += 360;
CLINEA 0000H 0001H 05B5H 0003H 0013H
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#0b4h
	mov	r3,	#043h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_Angle
	st	er2,	NEAR _Mag_Angle+02h
CBLOCKEND 223 8 1462

;;	}
CLINEA 0000H 0000H 05B6H 0002H 0002H
_$L231 :
CBLOCKEND 223 2 1463

;;}
CLINEA 0000H 0001H 05B7H 0001H 0001H
	pop	xr4
	mov	sp,	fp
	pop	fp
	pop	pc
CBLOCKEND 223 1 1463
CFUNCTIONEND 223


	rseg $$ClearVariables$main
CFUNCTION 224

_ClearVariables	:
CBLOCK 224 1 1465

;;void ClearVariables(void){
CLINEA 0000H 0001H 05B9H 0001H 001AH
CBLOCK 224 2 1465

;;	Temp_out = 0;
CLINEA 0000H 0001H 05BAH 0002H 000EH
	mov	er0,	#0 
	st	er0,	NEAR _Temp_out
	st	er0,	NEAR _Temp_out+02h

;;	Mag_Xout = 0;
CLINEA 0000H 0001H 05BBH 0002H 000EH
	st	er0,	NEAR _Mag_Xout
	st	er0,	NEAR _Mag_Xout+02h

;;	Mag_Yout = 0;
CLINEA 0000H 0001H 05BCH 0002H 000EH
	st	er0,	NEAR _Mag_Yout
	st	er0,	NEAR _Mag_Yout+02h

;;	Mag_Zout = 0;
CLINEA 0000H 0001H 05BDH 0002H 000EH
	st	er0,	NEAR _Mag_Zout
	st	er0,	NEAR _Mag_Zout+02h

;;	Mag_Angle = 0;
CLINEA 0000H 0001H 05BEH 0002H 000FH
	st	er0,	NEAR _Mag_Angle
	st	er0,	NEAR _Mag_Angle+02h

;;	Ping_timer = 0;
CLINEA 0000H 0001H 05BFH 0002H 0010H
	st	er0,	NEAR _Ping_timer

;;	Ping_out = 0;
CLINEA 0000H 0001H 05C0H 0002H 000EH
	st	er0,	NEAR _Ping_out
	st	er0,	NEAR _Ping_out+02h

;;	Range_out = 0;
CLINEA 0000H 0001H 05C1H 0002H 000FH
	st	er0,	NEAR _Range_out
CBLOCKEND 224 2 1474

;;}
CLINEA 0000H 0001H 05C2H 0001H 0001H
	rt
CBLOCKEND 224 1 1474
CFUNCTIONEND 224


	rseg $$ReturnSensorData$main
CFUNCTION 225

_ReturnSensorData	:
CBLOCK 225 1 1476

;;void ReturnSensorData(void){
CLINEA 0000H 0001H 05C4H 0001H 001CH
	push	lr
CBLOCK 225 2 1476
CRET 0000H
CLOCAL 47H 0002H 0024H 0002H "i" 02H 00H 01H

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 05C6H 0002H 0017H
	mov	er0,	#0 
_$L239 :
CBLOCK 225 3 1479

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 05C8H 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 225 3 1481

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 05C6H 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 05C6H 000CH 000FH
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L239

;;	sprintf(SensorReturn, "%f,%f,%f,%f,%f,%f,%f,%u", Accel_Xout, Accel_Yout, Accel_Zout, Gyro_Xout, Gyro_Yout, Gyro_Zout, Mag_Angle,Range_out);
CLINEA 0000H 0001H 05CBH 0002H 008CH
	l	er0,	NEAR _Range_out
	push	er0
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Gyro_Zout
	l	er2,	NEAR _Gyro_Zout+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Gyro_Yout
	l	er2,	NEAR _Gyro_Yout+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Gyro_Xout
	l	er2,	NEAR _Gyro_Xout+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	r0,	#BYTE1 OFFSET _Accel_Zout
	mov	r1,	#BYTE2 OFFSET _Accel_Zout
	push	er0
	mov	r0,	#BYTE1 OFFSET _Accel_Yout
	mov	r1,	#BYTE2 OFFSET _Accel_Yout
	push	er0
	mov	r0,	#BYTE1 OFFSET _Accel_Xout
	mov	r1,	#BYTE2 OFFSET _Accel_Xout
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S243
	mov	r1,	#BYTE2 OFFSET $$S243
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#44

;;	SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 05CDH 0002H 001AH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 05CEH 0002H 001AH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 05D1H 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 05D2H 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 05D3H 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05D4H 0001H 0001H
	bal	_$L248

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05D4H 0002H 0019H
_$L246 :
CBLOCK 225 4 1492

;;		main_clrWDT();
CLINEA 0000H 0001H 05D5H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 225 4 1494

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05D4H 0001H 0001H
_$L248 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05D4H 000CH 000FH
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L246
CBLOCKEND 225 2 1495

;;}
CLINEA 0000H 0001H 05D7H 0001H 0001H
	pop	pc
CBLOCKEND 225 1 1495
CFUNCTIONEND 225


	rseg $$ReturnAccelData$main
CFUNCTION 226

_ReturnAccelData	:
CBLOCK 226 1 1497

;;void ReturnAccelData(void){
CLINEA 0000H 0001H 05D9H 0001H 001BH
	push	lr
CBLOCK 226 2 1497
CRET 0000H
CLOCAL 47H 0002H 0024H 0002H "i" 02H 00H 01H

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 05DBH 0002H 0017H
	mov	er0,	#0 
_$L252 :
CBLOCK 226 3 1500

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 05DDH 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 226 3 1502

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 05DBH 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 05DBH 000CH 000FH
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L252

;;	sprintf(SensorReturn, "%f,%f,%f", Accel_Xout, Accel_Yout, Accel_Zout);
CLINEA 0000H 0001H 05E1H 0002H 0047H
	mov	r0,	#BYTE1 OFFSET _Accel_Zout
	mov	r1,	#BYTE2 OFFSET _Accel_Zout
	push	er0
	mov	r0,	#BYTE1 OFFSET _Accel_Yout
	mov	r1,	#BYTE2 OFFSET _Accel_Yout
	push	er0
	mov	r0,	#BYTE1 OFFSET _Accel_Xout
	mov	r1,	#BYTE2 OFFSET _Accel_Xout
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S256
	mov	r1,	#BYTE2 OFFSET $$S256
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#10

;;	SensorReturn[148] = 0x0D;	//CR
CLINEA 0000H 0001H 05E3H 0002H 001FH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;	//LF
CLINEA 0000H 0001H 05E4H 0002H 001FH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 05E7H 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 05E8H 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 05E9H 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05EAH 0001H 0001H
	bal	_$L261

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05EAH 0002H 0019H
_$L259 :
CBLOCK 226 4 1514

;;		main_clrWDT();
CLINEA 0000H 0001H 05EBH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 226 4 1516

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05EAH 0001H 0001H
_$L261 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05EAH 000CH 000FH
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L259
CBLOCKEND 226 2 1517

;;}
CLINEA 0000H 0001H 05EDH 0001H 0001H
	pop	pc
CBLOCKEND 226 1 1517
CFUNCTIONEND 226


	rseg $$ReturnMagData$main
CFUNCTION 227

_ReturnMagData	:
CBLOCK 227 1 1519

;;void ReturnMagData(void){
CLINEA 0000H 0001H 05EFH 0001H 0019H
	push	lr
CBLOCK 227 2 1519
CRET 0000H
CLOCAL 47H 0002H 0024H 0002H "i" 02H 00H 01H

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 05F1H 0002H 0017H
	mov	er0,	#0 
_$L265 :
CBLOCK 227 3 1522

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 05F3H 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 227 3 1524

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 05F1H 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 05F1H 000CH 000FH
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L265

;;	sprintf(SensorReturn, "%f", Mag_Angle);
CLINEA 0000H 0001H 05F5H 0002H 0028H
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#12

;;	SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 05F7H 0002H 001AH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 05F8H 0002H 001AH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 05FBH 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 05FCH 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 05FDH 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05FEH 0001H 0001H
	bal	_$L274

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05FEH 0002H 0019H
_$L272 :
CBLOCK 227 4 1534

;;		main_clrWDT();
CLINEA 0000H 0001H 05FFH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 227 4 1536

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05FEH 0001H 0001H
_$L274 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 05FEH 000CH 000FH
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L272
CBLOCKEND 227 2 1537

;;}
CLINEA 0000H 0001H 0601H 0001H 0001H
	pop	pc
CBLOCKEND 227 1 1537
CFUNCTIONEND 227


	rseg $$CalibrateMotors$main
CFUNCTION 228

_CalibrateMotors	:
CBLOCK 228 1 1545

;;void CalibrateMotors(void){
CLINEA 0000H 0001H 0609H 0001H 001BH
CBLOCK 228 2 1545
CLOCAL 4BH 0002H 0000H 0002H "i" 02H 00H 01H

;;	PFRUN = 0;
CLINEA 0000H 0001H 0645H 0002H 000BH
	rb	0f973h.0

;;	PERUN = 0;
CLINEA 0000H 0001H 0646H 0002H 000BH
	rb	0f937h.0

;;	PDRUN = 0;
CLINEA 0000H 0001H 0647H 0002H 000BH
	rb	0f927h.0

;;	PCRUN = 0;
CLINEA 0000H 0001H 0648H 0002H 000BH
	rb	0f917h.0

;;	PWF0D = PWMSafeDuty; //Can't be running to change
CLINEA 0000H 0001H 064AH 0002H 0032H
	l	er0,	NEAR _PWMSafeDuty
	st	er0,	0f962h

;;	PWED = PWMSafeDuty;
CLINEA 0000H 0001H 064BH 0002H 0014H
	st	er0,	0f932h

;;	PWDD = PWMSafeDuty;
CLINEA 0000H 0001H 064CH 0002H 0014H
	st	er0,	0f922h

;;	PWCD = PWMSafeDuty;
CLINEA 0000H 0001H 064DH 0002H 0014H
	st	er0,	0f912h

;;	PFRUN = 1;
CLINEA 0000H 0001H 064FH 0002H 000BH
	sb	0f973h.0

;;	PERUN = 1;
CLINEA 0000H 0001H 0650H 0002H 000BH
	sb	0f937h.0

;;	PDRUN = 1;
CLINEA 0000H 0001H 0651H 0002H 000BH
	sb	0f927h.0

;;	PCRUN = 1;
CLINEA 0000H 0001H 0652H 0002H 000BH
	sb	0f917h.0

;;	Mag_PIDCounter = 0;
CLINEA 0000H 0001H 0654H 0002H 0014H
	mov	er0,	#0 
	st	er0,	NEAR _Mag_PIDCounter

;;	CF_Gyro_Counter = 0;
CLINEA 0000H 0001H 0655H 0002H 0015H
	st	er0,	NEAR _CF_Gyro_Counter
	st	er0,	NEAR _CF_Gyro_Counter+02h

;;	Accel_PID_XRollCounter_I = 0;
CLINEA 0000H 0001H 0656H 0002H 001EH
	st	er0,	NEAR _Accel_PID_XRollCounter_I

;;	Accel_PID_XRollCounter_D = 0;
CLINEA 0000H 0001H 0657H 0002H 001EH
	st	er0,	NEAR _Accel_PID_XRollCounter_D

;;	Accel_PID_YPitchCounter_I = 0;
CLINEA 0000H 0001H 0658H 0002H 001FH
	st	er0,	NEAR _Accel_PID_YPitchCounter_I

;;	Accel_PID_YPitchCounter_D = 0;
CLINEA 0000H 0001H 0659H 0002H 001FH
	st	er0,	NEAR _Accel_PID_YPitchCounter_D

;;	Range_PIDCounter = 0;
CLINEA 0000H 0001H 065AH 0002H 0016H
	st	er0,	NEAR _Range_PIDCounter
CBLOCKEND 228 2 1646

;;}
CLINEA 0000H 0001H 066EH 0001H 0001H
	rt
CBLOCKEND 228 1 1646
CFUNCTIONEND 228


	rseg $$CalibrateGyro$main
CFUNCTION 229

_CalibrateGyro	:
CBLOCK 229 1 1649

;;void CalibrateGyro(void){
CLINEA 0000H 0001H 0671H 0001H 0019H
	push	lr
	push	er4
CBLOCK 229 2 1649
CRET 0002H
CLOCAL 47H 0002H 0026H 0002H "i" 02H 00H 01H

;;	if(!isDemoing)
CLINEA 0000H 0000H 0673H 0002H 000FH
	l	er0,	NEAR _isDemoing
	beq	_$M19
	b	_$L293
_$M19 :
CBLOCK 229 3 1652

;;		for(i = 0; i<150; i++)
CLINEA 0000H 0001H 0676H 0007H 000CH
	mov	er0,	#0 

;;		for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0676H 0015H 0017H
_$L283 :
CBLOCK 229 4 1655

;;			SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 0678H 0004H 001AH
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 229 4 1657

;;		for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0676H 0015H 0017H
	add	er0,	#1 

;;		for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0676H 000EH 0013H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L283

;;		sprintf(SensorReturn, "Gyro Calibration: Please Keep the Quad Flat and Return Any 2 chars to Start");
CLINEA 0000H 0001H 067AH 0003H 0067H
	mov	r0,	#BYTE1 OFFSET $$S287
	mov	r1,	#BYTE2 OFFSET $$S287
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#4 

;;		SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 067CH 0003H 001BH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;		SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 067DH 0003H 001BH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;		_flgUartFin = 0;
CLINEA 0000H 0001H 067FH 0003H 0012H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;		uart_stop();
CLINEA 0000H 0001H 0680H 0003H 000EH
	bl	_uart_stop

;;		uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 0681H 0003H 0032H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0682H 0001H 0001H
	bal	_$L321

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0682H 0003H 001AH
_$L290 :
CBLOCK 229 5 1666

;;			NOP1000();
CLINEA 0000H 0001H 0683H 0004H 000DH
	bl	_NOP1000

;;			main_clrWDT();
CLINEA 0000H 0001H 0684H 0004H 0011H
	bl	_main_clrWDT
CBLOCKEND 229 5 1669

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0682H 0001H 0001H
_$L321 :

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0682H 000EH 0013H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L290

;;		_flgUartFin = 0;
CLINEA 0000H 0001H 0688H 0003H 0012H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;		uart_stop();
CLINEA 0000H 0001H 0689H 0003H 000EH
	bl	_uart_stop

;;		uart_startReceive(RecWorld, 2, _funcUartFin);
CLINEA 0000H 0001H 068AH 0003H 002FH
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	er2,	#2 
	mov	r0,	#BYTE1 OFFSET _RecWorld
	mov	r1,	#BYTE2 OFFSET _RecWorld
	bl	_uart_startReceive
	add	sp,	#2 

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 068BH 0001H 0001H
	bal	_$L322

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 068BH 0003H 001AH
_$L294 :
CBLOCK 229 6 1675

;;			main_clrWDT();
CLINEA 0000H 0001H 068CH 0004H 0011H
	bl	_main_clrWDT
CBLOCKEND 229 6 1677

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 068BH 0001H 0001H
_$L322 :

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 068BH 000EH 0013H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L294

;;		}
CLINEA 0000H 0000H 068DH 0003H 0003H
_$L293 :
CBLOCKEND 229 3 1678

;;	i = 0;
CLINEA 0000H 0001H 068FH 0002H 0007H
	mov	er4,	#0 

;;	EPB3 = 1;					//Enable Accel/Gyro Interrupt Pin
CLINEA 0000H 0001H 0691H 0002H 0030H
	sb	0f011h.7

;;	while(i < 10){
CLINEA 0000H 0000H 0692H 0002H 000FH
_$L298 :
CBLOCK 229 7 1682

;;		if(AccGyro_ReadFlag >= 1){		//Triggered by External Interrupt (flag set in AccelGyroDataReady_ISR)
CLINEA 0000H 0001H 0693H 0003H 0064H
	l	r0,	NEAR _AccGyro_ReadFlag
	cmp	r0,	#01h
	bge	_$M20
	b	_$L300
_$M20 :
CBLOCK 229 8 1683

;;			_flgI2CFin = 0;																	//reset I2C completed Flag
CLINEA 0000H 0001H 0697H 0004H 003DH
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;			i2c_stop();																		//Make sure I2C is not currently running
CLINEA 0000H 0001H 0698H 0004H 0048H
	bl	_i2c_stop

;;			I20MD = 1;		//Switch to I2C Fast Operation (400kbps)
CLINEA 0000H 0001H 0699H 0004H 0037H
	sb	0f2a4h.1

;;			i2c_startReceive(MPU6050Address, &AccGyro_ReadData, 1, &AccGyro_Data, 14, (cbfI2c)_funcI2CFin);	//Begin I2C Receive Command
CLINEA 0000H 0001H 069AH 0004H 007EH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#14
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_Data
	mov	r1,	#BYTE2 OFFSET _AccGyro_Data
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_ReadData
	mov	r3,	#BYTE2 OFFSET _AccGyro_ReadData
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startReceive
	add	sp,	#8 

;;			while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 069BH 0001H 0001H
	bal	_$L323

;;			while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 069BH 0004H 0053H
_$L304 :
CBLOCK 229 9 1691

;;				main_clrWDT();	
CLINEA 0000H 0001H 069CH 0005H 0013H
	bl	_main_clrWDT
CBLOCKEND 229 9 1693

;;			while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 069BH 0001H 0001H
_$L323 :

;;			while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 069BH 000EH 0013H
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L304

;;			Gyro_Xcal += (AccGyro_Data[8]<<8)+(AccGyro_Data[9]);
CLINEA 0000H 0001H 06A1H 0004H 0037H
	l	r0,	NEAR _AccGyro_Data+08h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+09h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	l	er0,	NEAR _Gyro_Xcal
	l	er2,	NEAR _Gyro_Xcal+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Xcal
	st	er2,	NEAR _Gyro_Xcal+02h

;;			Gyro_Ycal += (AccGyro_Data[10]<<8)+(AccGyro_Data[11]);
CLINEA 0000H 0001H 06A2H 0004H 0039H
	l	r0,	NEAR _AccGyro_Data+0ah
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+0bh
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	l	er0,	NEAR _Gyro_Ycal
	l	er2,	NEAR _Gyro_Ycal+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Ycal
	st	er2,	NEAR _Gyro_Ycal+02h

;;			Gyro_Zcal += (AccGyro_Data[12]<<8)+(AccGyro_Data[13]);
CLINEA 0000H 0001H 06A3H 0004H 0039H
	l	r0,	NEAR _AccGyro_Data+0ch
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+0dh
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	l	er0,	NEAR _Gyro_Zcal
	l	er2,	NEAR _Gyro_Zcal+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Zcal
	st	er2,	NEAR _Gyro_Zcal+02h

;;			Accel_Xcal[0] += (AccGyro_Data[0]<<8)+(AccGyro_Data[1]);
CLINEA 0000H 0001H 06A4H 0004H 003BH
	l	r0,	NEAR _AccGyro_Data+01h
	mov	r1,	#00h
	l	r2,	NEAR _AccGyro_Data
	mov	r3,	r2
	mov	r2,	#00h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	l	er0,	NEAR _Accel_Xcal
	l	er2,	NEAR _Accel_Xcal+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xcal
	st	er2,	NEAR _Accel_Xcal+02h

;;			Accel_Ycal[0] += (AccGyro_Data[2]<<8)+(AccGyro_Data[3]);
CLINEA 0000H 0001H 06A5H 0004H 003BH
	l	r0,	NEAR _AccGyro_Data+02h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+03h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	l	er0,	NEAR _Accel_Ycal
	l	er2,	NEAR _Accel_Ycal+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Ycal
	st	er2,	NEAR _Accel_Ycal+02h

;;			i++;
CLINEA 0000H 0000H 06A6H 0004H 0007H
	add	er4,	#1 
CBLOCKEND 229 8 1703

;;		}
CLINEA 0000H 0000H 06A7H 0003H 0003H
_$L300 :
CBLOCKEND 229 7 1704

;;	while(i < 10){
CLINEA 0000H 0000H 0692H 000EH 0013H
	cmp	r4,	#0ah
	cmpc	r5,	#00h
	bges	_$M21
	b	_$L298
_$M21 :

;;	Gyro_Xcal /= 10;
CLINEA 0000H 0001H 06A9H 0002H 0011H
	l	er0,	NEAR _Gyro_Xcal
	l	er2,	NEAR _Gyro_Xcal+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Xcal
	st	er2,	NEAR _Gyro_Xcal+02h

;;	Gyro_Ycal /= 10;
CLINEA 0000H 0001H 06AAH 0002H 0011H
	l	er0,	NEAR _Gyro_Ycal
	l	er2,	NEAR _Gyro_Ycal+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Ycal
	st	er2,	NEAR _Gyro_Ycal+02h

;;	Gyro_Zcal /= 10;
CLINEA 0000H 0001H 06ABH 0002H 0011H
	l	er0,	NEAR _Gyro_Zcal
	l	er2,	NEAR _Gyro_Zcal+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Gyro_Zcal
	st	er2,	NEAR _Gyro_Zcal+02h

;;	EPB3 = 0;					//Enable Accel/Gyro Interrupt Pin
CLINEA 0000H 0001H 06AEH 0002H 0030H
	rb	0f011h.7

;;	if(!isDemoing)
CLINEA 0000H 0000H 06C6H 0002H 000FH
	l	er0,	NEAR _isDemoing
	bne	_$L318
CBLOCK 229 10 1735

;;		for(i = 0; i<150; i++)
CLINEA 0000H 0001H 06C9H 0007H 000CH
	mov	er0,	#0 

;;		for(i = 0; i<150; i++)
CLINEA 0000H 0000H 06C9H 0015H 0017H
_$L312 :
CBLOCK 229 11 1738

;;			SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 06CBH 0004H 001AH
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 229 11 1740

;;		for(i = 0; i<150; i++)
CLINEA 0000H 0000H 06C9H 0015H 0017H
	add	er0,	#1 

;;		for(i = 0; i<150; i++)
CLINEA 0000H 0000H 06C9H 000EH 0013H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L312

;;		sprintf(SensorReturn, "Gyro Calibration Complete!");
CLINEA 0000H 0001H 06CDH 0003H 0036H
	mov	r0,	#BYTE1 OFFSET $$S316
	mov	r1,	#BYTE2 OFFSET $$S316
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#4 

;;		SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 06CEH 0003H 001BH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;		SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 06CFH 0003H 001BH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;		_flgUartFin = 0;
CLINEA 0000H 0001H 06D1H 0003H 0012H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;		uart_stop();
CLINEA 0000H 0001H 06D2H 0003H 000EH
	bl	_uart_stop

;;		uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 06D3H 0003H 0032H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 06D4H 0001H 0001H
	bal	_$L324

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 06D4H 0003H 001AH
_$L319 :
CBLOCK 229 12 1748

;;			NOP1000();
CLINEA 0000H 0001H 06D5H 0004H 000DH
	bl	_NOP1000

;;			main_clrWDT();
CLINEA 0000H 0001H 06D6H 0004H 0011H
	bl	_main_clrWDT
CBLOCKEND 229 12 1751

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 06D4H 0001H 0001H
_$L324 :

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 06D4H 000EH 0013H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L319

;;		}
CLINEA 0000H 0000H 06D7H 0003H 0003H
_$L318 :
CBLOCKEND 229 10 1752
CBLOCKEND 229 2 1753

;;}
CLINEA 0000H 0001H 06D9H 0001H 0001H
	pop	er4
	pop	pc
CBLOCKEND 229 1 1753
CFUNCTIONEND 229


	rseg $$CalibrateAccel$main
CFUNCTION 230

_CalibrateAccel	:
CBLOCK 230 1 1755

;;void CalibrateAccel(void){
CLINEA 0000H 0001H 06DBH 0001H 001AH
	push	lr
	push	er8
CBLOCK 230 2 1755
CRET 0002H
CLOCAL 47H 0002H 0028H 0002H "i" 02H 00H 01H

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 06DFH 0002H 0017H
	mov	er0,	#0 
_$L328 :
CBLOCK 230 3 1760

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 06E1H 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 230 3 1762

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 06DFH 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 06DFH 000EH 0013H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L328

;;	sprintf(SensorReturn, "Accel Calibration: Keep Quad Flat! Return any 2 chars to Start");
CLINEA 0000H 0001H 06E3H 0002H 0059H
	mov	r0,	#BYTE1 OFFSET $$S332
	mov	r1,	#BYTE2 OFFSET $$S332
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#4 

;;	SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 06E4H 0002H 001AH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 06E5H 0002H 001AH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 06E7H 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 06E8H 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 06E9H 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 06EAH 0001H 0001H
	bal	_$L418

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 06EAH 0002H 0019H
_$L335 :
CBLOCK 230 4 1770

;;		NOP1000();
CLINEA 0000H 0001H 06EBH 0003H 000CH
	bl	_NOP1000

;;		main_clrWDT();
CLINEA 0000H 0001H 06ECH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 230 4 1773

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 06EAH 0001H 0001H
_$L418 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 06EAH 000EH 0013H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L335

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 06EFH 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 06F0H 0002H 000DH
	bl	_uart_stop

;;	uart_startReceive(RecWorld, 2, _funcUartFin);
CLINEA 0000H 0001H 06F1H 0002H 002EH
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	er2,	#2 
	mov	r0,	#BYTE1 OFFSET _RecWorld
	mov	r1,	#BYTE2 OFFSET _RecWorld
	bl	_uart_startReceive
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 06F2H 0001H 0001H
	bal	_$L419

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 06F2H 0002H 0019H
_$L339 :
CBLOCK 230 5 1778

;;		main_clrWDT();
CLINEA 0000H 0001H 06F3H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 230 5 1780

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 06F2H 0001H 0001H
_$L419 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 06F2H 000DH 0011H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L339

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0001H 06F6H 0006H 000BH
	mov	er8,	#0 

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 06F6H 0013H 0015H
_$L343 :
CBLOCK 230 6 1782

;;		_flgI2CFin = 0;																	//reset I2C completed Flag
CLINEA 0000H 0001H 06FAH 0003H 003CH
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;		i2c_stop();																		//Make sure I2C is not currently running
CLINEA 0000H 0001H 06FBH 0003H 0047H
	bl	_i2c_stop

;;		I20MD = 1;		//Switch to I2C Fast Operation (400kbps)
CLINEA 0000H 0001H 06FCH 0003H 0036H
	sb	0f2a4h.1

;;		i2c_startReceive(MPU6050Address, &AccGyro_ReadData, 1, &AccGyro_Data, 14, (cbfI2c)_funcI2CFin);	//Begin I2C Receive Command
CLINEA 0000H 0001H 06FDH 0003H 007DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#14
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_Data
	mov	r1,	#BYTE2 OFFSET _AccGyro_Data
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_ReadData
	mov	r3,	#BYTE2 OFFSET _AccGyro_ReadData
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startReceive
	add	sp,	#8 

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 06FEH 0001H 0001H
	bal	_$L420

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 06FEH 0003H 0052H
_$L349 :
CBLOCK 230 7 1790

;;			main_clrWDT();	
CLINEA 0000H 0001H 06FFH 0004H 0012H
	bl	_main_clrWDT
CBLOCKEND 230 7 1792

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 06FEH 0001H 0001H
_$L420 :

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 06FEH 000DH 0011H
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L349

;;		Accel_Xcal[1] += (AccGyro_Data[0]<<8)+(AccGyro_Data[1]);
CLINEA 0000H 0001H 0705H 0003H 003AH
	l	r0,	NEAR _AccGyro_Data+01h
	mov	r1,	#00h
	l	r2,	NEAR _AccGyro_Data
	mov	r3,	r2
	mov	r2,	#00h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	push	xr0
	l	er0,	NEAR _Accel_Xcal+04h
	l	er2,	NEAR _Accel_Xcal+06h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xcal+04h
	st	er2,	NEAR _Accel_Xcal+06h

;;		Accel_Ycal[1] += (AccGyro_Data[2]<<8)+(AccGyro_Data[3]);
CLINEA 0000H 0001H 0706H 0003H 003AH
	l	r0,	NEAR _AccGyro_Data+02h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+03h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	push	xr0
	l	er0,	NEAR _Accel_Ycal+04h
	l	er2,	NEAR _Accel_Ycal+06h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Ycal+04h
	st	er2,	NEAR _Accel_Ycal+06h
CBLOCKEND 230 6 1799

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 06F6H 0013H 0015H
	add	er8,	#1 

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 06F6H 000DH 0011H
	cmp	r8,	#0ah
	cmpc	r9,	#00h
	bges	_$M23
	b	_$L343
_$M23 :

;;	Accel_Xcal[1] /= 10;
CLINEA 0000H 0001H 0708H 0002H 0015H
	l	er0,	NEAR _Accel_Xcal+04h
	l	er2,	NEAR _Accel_Xcal+06h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xcal+04h
	st	er2,	NEAR _Accel_Xcal+06h

;;	Accel_Ycal[1] /= 10;
CLINEA 0000H 0001H 0709H 0002H 0015H
	l	er0,	NEAR _Accel_Ycal+04h
	l	er2,	NEAR _Accel_Ycal+06h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Ycal+04h
	st	er2,	NEAR _Accel_Ycal+06h

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 070BH 0002H 0017H
	mov	er0,	#0 
_$L353 :
CBLOCK 230 8 1804

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 070DH 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 230 8 1806

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 070BH 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 070BH 000DH 0012H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L353

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 0711H 0006H 000BH
	mov	er0,	#0 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0711H 0014H 0016H
_$L359 :
CBLOCK 230 9 1810

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 0713H 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 230 9 1812

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0711H 0014H 0016H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0711H 000DH 0012H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L359

;;	sprintf(SensorReturn, "Accel Calibration: Tilt the Quad 90deg in the ROLL Direction! Return any 2 chars to Start");
CLINEA 0000H 0001H 0715H 0002H 0074H
	mov	r0,	#BYTE1 OFFSET $$S363
	mov	r1,	#BYTE2 OFFSET $$S363
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#4 

;;	SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 0716H 0002H 001AH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 0717H 0002H 001AH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 0719H 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 071AH 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 071BH 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 071CH 0001H 0001H
	bal	_$L421

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 071CH 0002H 0019H
_$L366 :
CBLOCK 230 10 1820

;;		NOP1000();
CLINEA 0000H 0001H 071DH 0003H 000CH
	bl	_NOP1000

;;		main_clrWDT();
CLINEA 0000H 0001H 071EH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 230 10 1823

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 071CH 0001H 0001H
_$L421 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 071CH 000DH 0012H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L366

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 0721H 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 0722H 0002H 000DH
	bl	_uart_stop

;;	uart_startReceive(RecWorld, 2, _funcUartFin);
CLINEA 0000H 0001H 0723H 0002H 002EH
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	er2,	#2 
	mov	r0,	#BYTE1 OFFSET _RecWorld
	mov	r1,	#BYTE2 OFFSET _RecWorld
	bl	_uart_startReceive
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0724H 0001H 0001H
	bal	_$L422

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0724H 0002H 0019H
_$L370 :
CBLOCK 230 11 1828

;;		main_clrWDT();
CLINEA 0000H 0001H 0725H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 230 11 1830

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0724H 0001H 0001H
_$L422 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0724H 000DH 0011H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L370

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0001H 0728H 0006H 000BH
	mov	er8,	#0 

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 0728H 0013H 0015H
_$L374 :
CBLOCK 230 12 1832

;;		_flgI2CFin = 0;																	//reset I2C completed Flag
CLINEA 0000H 0001H 072CH 0003H 003CH
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;		i2c_stop();																		//Make sure I2C is not currently running
CLINEA 0000H 0001H 072DH 0003H 0047H
	bl	_i2c_stop

;;		I20MD = 1;		//Switch to I2C Fast Operation (400kbps)
CLINEA 0000H 0001H 072EH 0003H 0036H
	sb	0f2a4h.1

;;		i2c_startReceive(MPU6050Address, &AccGyro_ReadData, 1, &AccGyro_Data, 14, (cbfI2c)_funcI2CFin);	//Begin I2C Receive Command
CLINEA 0000H 0001H 072FH 0003H 007DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#14
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_Data
	mov	r1,	#BYTE2 OFFSET _AccGyro_Data
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_ReadData
	mov	r3,	#BYTE2 OFFSET _AccGyro_ReadData
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startReceive
	add	sp,	#8 

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0730H 0001H 0001H
	bal	_$L423

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0730H 0003H 0052H
_$L380 :
CBLOCK 230 13 1840

;;			main_clrWDT();	
CLINEA 0000H 0001H 0731H 0004H 0012H
	bl	_main_clrWDT
CBLOCKEND 230 13 1842

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0730H 0001H 0001H
_$L423 :

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 0730H 000DH 0011H
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L380

;;		Accel_Zcal[1] += (AccGyro_Data[4]<<8)+(AccGyro_Data[5]);
CLINEA 0000H 0001H 0737H 0003H 003AH
	l	r0,	NEAR _AccGyro_Data+04h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+05h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	push	xr0
	l	er0,	NEAR _Accel_Zcal+04h
	l	er2,	NEAR _Accel_Zcal+06h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Zcal+04h
	st	er2,	NEAR _Accel_Zcal+06h

;;		Accel_Ycal[2] += (AccGyro_Data[2]<<8)+(AccGyro_Data[3]);
CLINEA 0000H 0001H 0738H 0003H 003AH
	l	r0,	NEAR _AccGyro_Data+02h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+03h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	push	xr0
	l	er0,	NEAR _Accel_Ycal+08h
	l	er2,	NEAR _Accel_Ycal+0ah
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Ycal+08h
	st	er2,	NEAR _Accel_Ycal+0ah
CBLOCKEND 230 12 1849

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 0728H 0013H 0015H
	add	er8,	#1 

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 0728H 000DH 0011H
	cmp	r8,	#0ah
	cmpc	r9,	#00h
	bges	_$M24
	b	_$L374
_$M24 :

;;	Accel_Zcal[1] /= 10;
CLINEA 0000H 0001H 073AH 0002H 0015H
	l	er0,	NEAR _Accel_Zcal+04h
	l	er2,	NEAR _Accel_Zcal+06h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Zcal+04h
	st	er2,	NEAR _Accel_Zcal+06h

;;	Accel_Ycal[2] /= 10;
CLINEA 0000H 0001H 073BH 0002H 0015H
	l	er0,	NEAR _Accel_Ycal+08h
	l	er2,	NEAR _Accel_Ycal+0ah
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Ycal+08h
	st	er2,	NEAR _Accel_Ycal+0ah

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 073EH 0002H 0017H
	mov	er0,	#0 
_$L384 :
CBLOCK 230 14 1855

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 0740H 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 230 14 1857

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 073EH 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 073EH 000DH 0011H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L384

;;	sprintf(SensorReturn, "Accel Calibration: Tilt the Quad 90deg in the PITCH direction! Return any 2 chars to Start");
CLINEA 0000H 0001H 0742H 0002H 0075H
	mov	r0,	#BYTE1 OFFSET $$S388
	mov	r1,	#BYTE2 OFFSET $$S388
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#4 

;;	SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 0743H 0002H 001AH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 0744H 0002H 001AH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 0746H 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 0747H 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 0748H 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0749H 0001H 0001H
	bal	_$L424

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0749H 0002H 0019H
_$L391 :
CBLOCK 230 15 1865

;;		NOP1000();
CLINEA 0000H 0001H 074AH 0003H 000CH
	bl	_NOP1000

;;		main_clrWDT();
CLINEA 0000H 0001H 074BH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 230 15 1868

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0749H 0001H 0001H
_$L424 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0749H 000DH 0011H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L391

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 074EH 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 074FH 0002H 000DH
	bl	_uart_stop

;;	uart_startReceive(RecWorld, 2, _funcUartFin);
CLINEA 0000H 0001H 0750H 0002H 002EH
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	er2,	#2 
	mov	r0,	#BYTE1 OFFSET _RecWorld
	mov	r1,	#BYTE2 OFFSET _RecWorld
	bl	_uart_startReceive
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0751H 0001H 0001H
	bal	_$L425

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0751H 0002H 0019H
_$L395 :
CBLOCK 230 16 1873

;;		main_clrWDT();
CLINEA 0000H 0001H 0752H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 230 16 1875

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0751H 0001H 0001H
_$L425 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0751H 000DH 0011H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L395

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0001H 0755H 0006H 000BH
	mov	er8,	#0 

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 0755H 0013H 0015H
_$L399 :
CBLOCK 230 17 1877

;;		_flgI2CFin = 0;																	//reset I2C completed Flag
CLINEA 0000H 0001H 0759H 0003H 003CH
	mov	r0,	#00h
	st	r0,	NEAR __flgI2CFin

;;		i2c_stop();																		//Make sure I2C is not currently running
CLINEA 0000H 0001H 075AH 0003H 0047H
	bl	_i2c_stop

;;		I20MD = 1;		//Switch to I2C Fast Operation (400kbps)
CLINEA 0000H 0001H 075BH 0003H 0036H
	sb	0f2a4h.1

;;		i2c_startReceive(MPU6050Address, &AccGyro_ReadData, 1, &AccGyro_Data, 14, (cbfI2c)_funcI2CFin);	//Begin I2C Receive Command
CLINEA 0000H 0001H 075CH 0003H 007DH
	mov	r0,	#BYTE1 OFFSET __funcI2CFin
	mov	r1,	#BYTE2 OFFSET __funcI2CFin
	push	er0
	mov	er0,	#14
	push	er0
	mov	r0,	#BYTE1 OFFSET _AccGyro_Data
	mov	r1,	#BYTE2 OFFSET _AccGyro_Data
	push	er0
	mov	er0,	#1 
	push	er0
	mov	r2,	#BYTE1 OFFSET _AccGyro_ReadData
	mov	r3,	#BYTE2 OFFSET _AccGyro_ReadData
	l	r0,	NEAR _MPU6050Address
	bl	_i2c_startReceive
	add	sp,	#8 

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 075DH 0001H 0001H
	bal	_$L426

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 075DH 0003H 0052H
_$L405 :
CBLOCK 230 18 1885

;;			main_clrWDT();	
CLINEA 0000H 0001H 075EH 0004H 0012H
	bl	_main_clrWDT
CBLOCKEND 230 18 1887

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 075DH 0001H 0001H
_$L426 :

;;		while(_flgI2CFin != 1){															//Wait for I2C commands to finish transfer
CLINEA 0000H 0000H 075DH 000DH 0011H
	l	r0,	NEAR __flgI2CFin
	cmp	r0,	#01h
	bne	_$L405

;;		Accel_Zcal[2] += (AccGyro_Data[4]<<8)+(AccGyro_Data[5]);
CLINEA 0000H 0001H 0764H 0003H 003AH
	l	r0,	NEAR _AccGyro_Data+04h
	mov	r1,	#00h
	mov	r3,	r0
	mov	r2,	#00h
	l	r0,	NEAR _AccGyro_Data+05h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	push	xr0
	l	er0,	NEAR _Accel_Zcal+08h
	l	er2,	NEAR _Accel_Zcal+0ah
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Zcal+08h
	st	er2,	NEAR _Accel_Zcal+0ah

;;		Accel_Xcal[2] += (AccGyro_Data[0]<<8)+(AccGyro_Data[1]);
CLINEA 0000H 0001H 0765H 0003H 003AH
	l	r0,	NEAR _AccGyro_Data+01h
	mov	r1,	#00h
	l	r2,	NEAR _AccGyro_Data
	mov	r3,	r2
	mov	r2,	#00h
	add	er0,	er2
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	push	xr0
	l	er0,	NEAR _Accel_Xcal+08h
	l	er2,	NEAR _Accel_Xcal+0ah
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xcal+08h
	st	er2,	NEAR _Accel_Xcal+0ah
CBLOCKEND 230 17 1894

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 0755H 0013H 0015H
	add	er8,	#1 

;;	for(i = 0; i<10; i++){
CLINEA 0000H 0000H 0755H 000DH 0011H
	cmp	r8,	#0ah
	cmpc	r9,	#00h
	bges	_$M25
	b	_$L399
_$M25 :

;;	Accel_Zcal[2] /= 10;
CLINEA 0000H 0001H 0767H 0002H 0015H
	l	er0,	NEAR _Accel_Zcal+08h
	l	er2,	NEAR _Accel_Zcal+0ah
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Zcal+08h
	st	er2,	NEAR _Accel_Zcal+0ah

;;	Accel_Xcal[2] /= 10;
CLINEA 0000H 0001H 0768H 0002H 0015H
	l	er0,	NEAR _Accel_Xcal+08h
	l	er2,	NEAR _Accel_Xcal+0ah
	push	xr0
	mov	er0,	#0 
	mov	r2,	#020h
	mov	r3,	#041h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xcal+08h
	st	er2,	NEAR _Accel_Xcal+0ah

;;	Accel_Xcal[0] = (Accel_Xcal[1]+Accel_Xcal[2])/2;
CLINEA 0000H 0001H 076BH 0002H 0031H
	l	er0,	NEAR _Accel_Xcal+04h
	l	er2,	NEAR _Accel_Xcal+06h
	push	xr0
	l	er0,	NEAR _Accel_Xcal+08h
	l	er2,	NEAR _Accel_Xcal+0ah
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	mov	er0,	#0 
	mov	r2,	#00h
	mov	r3,	#040h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Xcal
	st	er2,	NEAR _Accel_Xcal+02h

;;	Accel_Ycal[0] = (Accel_Ycal[1]+Accel_Ycal[2])/2;
CLINEA 0000H 0001H 076CH 0002H 0031H
	l	er0,	NEAR _Accel_Ycal+04h
	l	er2,	NEAR _Accel_Ycal+06h
	push	xr0
	l	er0,	NEAR _Accel_Ycal+08h
	l	er2,	NEAR _Accel_Ycal+0ah
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	mov	er0,	#0 
	mov	r2,	#00h
	mov	r3,	#040h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Ycal
	st	er2,	NEAR _Accel_Ycal+02h

;;	Accel_Zcal[0] = (Accel_Zcal[1]+Accel_Zcal[2])/2;
CLINEA 0000H 0001H 076DH 0002H 0031H
	l	er0,	NEAR _Accel_Zcal+04h
	l	er2,	NEAR _Accel_Zcal+06h
	push	xr0
	l	er0,	NEAR _Accel_Zcal+08h
	l	er2,	NEAR _Accel_Zcal+0ah
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	mov	er0,	#0 
	mov	r2,	#00h
	mov	r3,	#040h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_Zcal
	st	er2,	NEAR _Accel_Zcal+02h

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 0770H 0002H 0017H
	mov	er0,	#0 
_$L409 :
CBLOCK 230 19 1905

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 0772H 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 230 19 1907

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0770H 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0770H 000DH 0011H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L409

;;	sprintf(SensorReturn, "Accel Calibration Complete!");
CLINEA 0000H 0001H 0774H 0002H 0036H
	mov	r0,	#BYTE1 OFFSET $$S413
	mov	r1,	#BYTE2 OFFSET $$S413
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#4 

;;	SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 0775H 0002H 001AH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 0776H 0002H 001AH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 0778H 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 0779H 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 077AH 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 077BH 0001H 0001H
	bal	_$L427

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 077BH 0002H 0019H
_$L416 :
CBLOCK 230 20 1915

;;		NOP1000();
CLINEA 0000H 0001H 077CH 0003H 000CH
	bl	_NOP1000

;;		main_clrWDT();
CLINEA 0000H 0001H 077DH 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 230 20 1918

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 077BH 0001H 0001H
_$L427 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 077BH 000DH 0011H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L416
CBLOCKEND 230 2 1919

;;}
CLINEA 0000H 0001H 077FH 0001H 0001H
	pop	er8
	pop	pc
CBLOCKEND 230 1 1919
CFUNCTIONEND 230


	rseg $$SerialOutCoefficients$main
CFUNCTION 231

_SerialOutCoefficients	:
CBLOCK 231 1 1923

;;{
CLINEA 0000H 0001H 0783H 0001H 0001H
	push	lr
CBLOCK 231 2 1923
CRET 0000H
CLOCAL 47H 0002H 0024H 0002H "j" 02H 00H 01H

;;		for(j = 0; j<150; j++)
CLINEA 0000H 0001H 0786H 0003H 0018H
	mov	er0,	#0 
_$L431 :
CBLOCK 231 3 1927

;;			SensorReturn[j] = 0x20;
CLINEA 0000H 0001H 0788H 0004H 001AH
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 231 3 1929

;;		for(j = 0; j<150; j++)
CLINEA 0000H 0000H 0786H 0003H 0018H
	add	er0,	#1 

;;		for(j = 0; j<150; j++)
CLINEA 0000H 0000H 0786H 000DH 0011H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L431

;;		sprintf(SensorReturn, "Current Settings: kp=%f,ki=%f,kd=%f,a1=%f,a2=%f,Pb=%u,Db=%u", Accel_PID_XRoll_kp, Accel_PID_XRoll_ki, Accel_PID_XRoll_kd, CF_HPF, CF_LPF,Accel_PID_PBounds_Var_Pos,Accel_PID_DBounds_Var_Pos);
CLINEA 0000H 0001H 078BH 0003H 00D7H
	l	er0,	NEAR _Accel_PID_DBounds_Var_Pos
	push	er0
	l	er0,	NEAR _Accel_PID_PBounds_Var_Pos
	push	er0
	l	er0,	NEAR _CF_LPF
	l	er2,	NEAR _CF_LPF+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _CF_HPF
	l	er2,	NEAR _CF_HPF+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_PID_XRoll_kd
	l	er2,	NEAR _Accel_PID_XRoll_kd+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_PID_XRoll_ki
	l	er2,	NEAR _Accel_PID_XRoll_ki+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_PID_XRoll_kp
	l	er2,	NEAR _Accel_PID_XRoll_kp+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	r0,	#BYTE1 OFFSET $$S435
	mov	r1,	#BYTE2 OFFSET $$S435
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#48

;;		SensorReturn[148] = 0x0D;	//CR
CLINEA 0000H 0001H 078DH 0003H 0020H
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;		SensorReturn[149] = 0x0A;	//LF
CLINEA 0000H 0001H 078EH 0003H 0020H
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;		_flgUartFin = 0;
CLINEA 0000H 0001H 0791H 0003H 0012H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;		uart_stop();
CLINEA 0000H 0001H 0792H 0003H 000EH
	bl	_uart_stop

;;		uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 0793H 0003H 0032H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0794H 0001H 0001H
	bal	_$L440

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0794H 0003H 001AH
_$L438 :
CBLOCK 231 4 1940

;;			main_clrWDT();
CLINEA 0000H 0001H 0795H 0004H 0011H
	bl	_main_clrWDT
CBLOCKEND 231 4 1942

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0794H 0001H 0001H
_$L440 :

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0794H 000DH 0011H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L438
CBLOCKEND 231 2 1943

;;}
CLINEA 0000H 0001H 0797H 0001H 0001H
	pop	pc
CBLOCKEND 231 1 1943
CFUNCTIONEND 231


	rseg $$UARTTunePID$main
CFUNCTION 232

_UARTTunePID	:
CBLOCK 232 1 1947

;;{
CLINEA 0000H 0001H 079BH 0001H 0001H
	push	lr
CBLOCK 232 2 1947
CRET 0000H
CLOCAL 47H 0002H 0024H 0002H "k" 02H 00H 01H
CLOCAL 4BH 0002H 0000H 0002H "i" 02H 00H 01H
CLOCAL 4BH 0002H 0000H 0002H "j" 02H 00H 01H

;;		for (k=0;k<7;k++)
CLINEA 0000H 0001H 07A2H 0008H 000BH
	mov	er0,	#0 

;;		for (k=0;k<7;k++)
CLINEA 0000H 0000H 07A2H 0010H 0012H
_$L445 :
CBLOCK 232 3 1955

;;			RecWorld[k] = 0;	//ie: to set ki to 1.5 =>send ki1.50000
CLINEA 0000H 0001H 07A4H 0004H 003BH
	mov	r2,	#00h
	st	r2,	NEAR _RecWorld[er0]
CBLOCKEND 232 3 1957

;;		for (k=0;k<7;k++)
CLINEA 0000H 0000H 07A2H 0010H 0012H
	add	er0,	#1 

;;		for (k=0;k<7;k++)
CLINEA 0000H 0000H 07A2H 000CH 000FH
	cmp	r0,	#07h
	cmpc	r1,	#00h
	blts	_$L445

;;		ETM8 = 0; //Turn OFF TIMER8/9 ISR for this function...
CLINEA 0000H 0001H 07A7H 0003H 0038H
	rb	0f013h.2

;;		ETM9 = 0; //Turn OFF TIMER8/9 ISR for this function...
CLINEA 0000H 0001H 07A8H 0003H 0038H
	rb	0f013h.3

;;		_flgUartFin = 0;
CLINEA 0000H 0001H 07ABH 0003H 0012H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;		uart_stop();
CLINEA 0000H 0001H 07ACH 0003H 000EH
	bl	_uart_stop

;;		uart_startReceive(RecWorld, 8, _funcUartFin);
CLINEA 0000H 0001H 07ADH 0003H 002FH
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	er2,	#8 
	mov	r0,	#BYTE1 OFFSET _RecWorld
	mov	r1,	#BYTE2 OFFSET _RecWorld
	bl	_uart_startReceive
	add	sp,	#2 

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 07AEH 0001H 0001H
	bal	_$L496

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 07AEH 0003H 001AH
_$L451 :
CBLOCK 232 4 1966

;;			main_clrWDT();
CLINEA 0000H 0001H 07AFH 0004H 0011H
	bl	_main_clrWDT
CBLOCKEND 232 4 1968

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 07AEH 0001H 0001H
_$L496 :

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 07AEH 000CH 000FH
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L451

;;		if(RecWorld[0] == 0x70){		//if RECWORLD == "pi"
CLINEA 0000H 0001H 07DEH 0003H 0031H
	l	r0,	NEAR _RecWorld
	cmp	r0,	#070h
	beq	_$M28
	b	_$L455
_$M28 :
CBLOCK 232 5 2014

;;			if(RecWorld[1] == 0x69){
CLINEA 0000H 0001H 07DFH 0004H 001BH
	l	r0,	NEAR _RecWorld+01h
	cmp	r0,	#069h
	beq	_$M29
	b	_$L455
_$M29 :
CBLOCK 232 6 2015

;;				NewVar_Str[0] = RecWorld[2];
CLINEA 0000H 0001H 07E0H 0005H 0020H
	l	r0,	NEAR _RecWorld+02h
	st	r0,	NEAR _NewVar_Str

;;				NewVar_Str[1] = RecWorld[3];
CLINEA 0000H 0001H 07E1H 0005H 0020H
	l	r0,	NEAR _RecWorld+03h
	st	r0,	NEAR _NewVar_Str+01h

;;				NewVar_Str[2] = RecWorld[4];
CLINEA 0000H 0001H 07E2H 0005H 0020H
	l	r0,	NEAR _RecWorld+04h
	st	r0,	NEAR _NewVar_Str+02h

;;				NewVar_Str[3] = RecWorld[5];
CLINEA 0000H 0001H 07E3H 0005H 0020H
	l	r0,	NEAR _RecWorld+05h
	st	r0,	NEAR _NewVar_Str+03h

;;				NewVar_Str[4] = RecWorld[6];
CLINEA 0000H 0001H 07E4H 0005H 0020H
	l	r0,	NEAR _RecWorld+06h
	st	r0,	NEAR _NewVar_Str+04h

;;				NewVar_Str[5] = RecWorld[7];
CLINEA 0000H 0001H 07E5H 0005H 0020H
	l	r0,	NEAR _RecWorld+07h
	st	r0,	NEAR _NewVar_Str+05h

;;				sscanf(NewVar_Str, "%f", &NewVar);
CLINEA 0000H 0001H 07E6H 0005H 0026H
	mov	r0,	#BYTE1 OFFSET _NewVar
	mov	r1,	#BYTE2 OFFSET _NewVar
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _NewVar_Str
	mov	r1,	#BYTE2 OFFSET _NewVar_Str
	push	er0
	bl	_sscanf_nn
	add	sp,	#6 

;;				Accel_PID_XRoll_kp = NewVar;
CLINEA 0000H 0001H 07E7H 0005H 0020H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	st	er0,	NEAR _Accel_PID_XRoll_kp
	st	er2,	NEAR _Accel_PID_XRoll_kp+02h

;;				Accel_PID_YPitch_kp = NewVar;
CLINEA 0000H 0001H 07E8H 0005H 0021H
	st	er0,	NEAR _Accel_PID_YPitch_kp
	st	er2,	NEAR _Accel_PID_YPitch_kp+02h

;;				Accel_PID_XRoll_ki = NewVar/2;
CLINEA 0000H 0001H 07E9H 0005H 0022H
	push	xr0
	mov	er0,	#0 
	mov	r2,	#00h
	mov	r3,	#040h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_PID_XRoll_ki
	st	er2,	NEAR _Accel_PID_XRoll_ki+02h

;;				Accel_PID_YPitch_ki = NewVar/2;
CLINEA 0000H 0001H 07EAH 0005H 0023H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#00h
	mov	r3,	#040h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_PID_YPitch_ki
	st	er2,	NEAR _Accel_PID_YPitch_ki+02h
CBLOCKEND 232 6 2027

;;			}
CLINEA 0000H 0000H 07EBH 0004H 0004H
_$L455 :
CBLOCKEND 232 5 2028

;;		if(RecWorld[0] == 0x70){		//if RECWORLD == "pb"
CLINEA 0000H 0001H 07EEH 0003H 0031H
	l	r0,	NEAR _RecWorld
	cmp	r0,	#070h
	beq	_$M30
	b	_$L459
_$M30 :
CBLOCK 232 7 2030

;;			if(RecWorld[1] == 0x62){
CLINEA 0000H 0001H 07EFH 0004H 001BH
	l	r0,	NEAR _RecWorld+01h
	cmp	r0,	#062h
	bne	_$L459
CBLOCK 232 8 2031

;;				NewVar_Str[0] = RecWorld[2];
CLINEA 0000H 0001H 07F0H 0005H 0020H
	l	r0,	NEAR _RecWorld+02h
	st	r0,	NEAR _NewVar_Str

;;				NewVar_Str[1] = RecWorld[3];
CLINEA 0000H 0001H 07F1H 0005H 0020H
	l	r0,	NEAR _RecWorld+03h
	st	r0,	NEAR _NewVar_Str+01h

;;				NewVar_Str[2] = RecWorld[4];
CLINEA 0000H 0001H 07F2H 0005H 0020H
	l	r0,	NEAR _RecWorld+04h
	st	r0,	NEAR _NewVar_Str+02h

;;				NewVar_Str[3] = RecWorld[5];
CLINEA 0000H 0001H 07F3H 0005H 0020H
	l	r0,	NEAR _RecWorld+05h
	st	r0,	NEAR _NewVar_Str+03h

;;				NewVar_Str[4] = RecWorld[6];
CLINEA 0000H 0001H 07F4H 0005H 0020H
	l	r0,	NEAR _RecWorld+06h
	st	r0,	NEAR _NewVar_Str+04h

;;				NewVar_Str[5] = RecWorld[7];
CLINEA 0000H 0001H 07F5H 0005H 0020H
	l	r0,	NEAR _RecWorld+07h
	st	r0,	NEAR _NewVar_Str+05h

;;				sscanf(NewVar_Str, "%f", &NewVar);
CLINEA 0000H 0001H 07F6H 0005H 0026H
	mov	r0,	#BYTE1 OFFSET _NewVar
	mov	r1,	#BYTE2 OFFSET _NewVar
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _NewVar_Str
	mov	r1,	#BYTE2 OFFSET _NewVar_Str
	push	er0
	bl	_sscanf_nn
	add	sp,	#6 

;;				Accel_PID_PBounds_Var_Pos = NewVar;
CLINEA 0000H 0001H 07F7H 0005H 0027H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	push	xr0
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	NEAR _Accel_PID_PBounds_Var_Pos

;;				Accel_PID_PBounds_Var_Neg = -1* NewVar;
CLINEA 0000H 0001H 07F8H 0005H 002BH
	l	er0,	NEAR _NewVar
	push	xr0
	mov	er0,	#0 
	mov	r2,	#080h
	mov	r3,	#0bfh
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	NEAR _Accel_PID_PBounds_Var_Neg
CBLOCKEND 232 8 2042

;;			}
CLINEA 0000H 0000H 07FAH 0004H 0004H
_$L459 :
CBLOCKEND 232 7 2043

;;		if(RecWorld[0] == 0x64){			//if RECWORLD == "db"
CLINEA 0000H 0001H 07FDH 0003H 0032H
	l	r0,	NEAR _RecWorld
	cmp	r0,	#064h
	beq	_$M31
	b	_$L463
_$M31 :
CBLOCK 232 9 2045

;;			if(RecWorld[1] == 0x62){
CLINEA 0000H 0001H 07FEH 0004H 001BH
	l	r0,	NEAR _RecWorld+01h
	cmp	r0,	#062h
	bne	_$L463
CBLOCK 232 10 2046

;;				NewVar_Str[0] = RecWorld[2];
CLINEA 0000H 0001H 07FFH 0005H 0020H
	l	r0,	NEAR _RecWorld+02h
	st	r0,	NEAR _NewVar_Str

;;				NewVar_Str[1] = RecWorld[3];
CLINEA 0000H 0001H 0800H 0005H 0020H
	l	r0,	NEAR _RecWorld+03h
	st	r0,	NEAR _NewVar_Str+01h

;;				NewVar_Str[2] = RecWorld[4];
CLINEA 0000H 0001H 0801H 0005H 0020H
	l	r0,	NEAR _RecWorld+04h
	st	r0,	NEAR _NewVar_Str+02h

;;				NewVar_Str[3] = RecWorld[5];
CLINEA 0000H 0001H 0802H 0005H 0020H
	l	r0,	NEAR _RecWorld+05h
	st	r0,	NEAR _NewVar_Str+03h

;;				NewVar_Str[4] = RecWorld[6];
CLINEA 0000H 0001H 0803H 0005H 0020H
	l	r0,	NEAR _RecWorld+06h
	st	r0,	NEAR _NewVar_Str+04h

;;				NewVar_Str[5] = RecWorld[7];
CLINEA 0000H 0001H 0804H 0005H 0020H
	l	r0,	NEAR _RecWorld+07h
	st	r0,	NEAR _NewVar_Str+05h

;;				sscanf(NewVar_Str, "%f", &NewVar);
CLINEA 0000H 0001H 0805H 0005H 0026H
	mov	r0,	#BYTE1 OFFSET _NewVar
	mov	r1,	#BYTE2 OFFSET _NewVar
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _NewVar_Str
	mov	r1,	#BYTE2 OFFSET _NewVar_Str
	push	er0
	bl	_sscanf_nn
	add	sp,	#6 

;;				Accel_PID_DBounds_Var_Pos = NewVar;
CLINEA 0000H 0001H 0806H 0005H 0027H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	push	xr0
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	NEAR _Accel_PID_DBounds_Var_Pos

;;				Accel_PID_DBounds_Var_Neg = -1 * NewVar;
CLINEA 0000H 0001H 0807H 0005H 002CH
	l	er0,	NEAR _NewVar
	push	xr0
	mov	er0,	#0 
	mov	r2,	#080h
	mov	r3,	#0bfh
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	NEAR _Accel_PID_DBounds_Var_Neg
CBLOCKEND 232 10 2057

;;			}
CLINEA 0000H 0000H 0809H 0004H 0004H
_$L463 :
CBLOCKEND 232 9 2058

;;		if(RecWorld[0] == 0x6B){			//if RECWORLD == "kp"
CLINEA 0000H 0001H 080CH 0003H 0032H
	l	r0,	NEAR _RecWorld
	cmp	r0,	#06bh
	bne	_$L467
CBLOCK 232 11 2060

;;			if(RecWorld[1] == 0x70){
CLINEA 0000H 0001H 080DH 0004H 001BH
	l	r0,	NEAR _RecWorld+01h
	cmp	r0,	#070h
	bne	_$L467
CBLOCK 232 12 2061

;;				NewVar_Str[0] = RecWorld[2];
CLINEA 0000H 0001H 080EH 0005H 0020H
	l	r0,	NEAR _RecWorld+02h
	st	r0,	NEAR _NewVar_Str

;;				NewVar_Str[1] = RecWorld[3];
CLINEA 0000H 0001H 080FH 0005H 0020H
	l	r0,	NEAR _RecWorld+03h
	st	r0,	NEAR _NewVar_Str+01h

;;				NewVar_Str[2] = RecWorld[4];
CLINEA 0000H 0001H 0810H 0005H 0020H
	l	r0,	NEAR _RecWorld+04h
	st	r0,	NEAR _NewVar_Str+02h

;;				NewVar_Str[3] = RecWorld[5];
CLINEA 0000H 0001H 0811H 0005H 0020H
	l	r0,	NEAR _RecWorld+05h
	st	r0,	NEAR _NewVar_Str+03h

;;				NewVar_Str[4] = RecWorld[6];
CLINEA 0000H 0001H 0812H 0005H 0020H
	l	r0,	NEAR _RecWorld+06h
	st	r0,	NEAR _NewVar_Str+04h

;;				NewVar_Str[5] = RecWorld[7];
CLINEA 0000H 0001H 0813H 0005H 0020H
	l	r0,	NEAR _RecWorld+07h
	st	r0,	NEAR _NewVar_Str+05h

;;				sscanf(NewVar_Str, "%f", &NewVar);
CLINEA 0000H 0001H 0814H 0005H 0026H
	mov	r0,	#BYTE1 OFFSET _NewVar
	mov	r1,	#BYTE2 OFFSET _NewVar
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _NewVar_Str
	mov	r1,	#BYTE2 OFFSET _NewVar_Str
	push	er0
	bl	_sscanf_nn
	add	sp,	#6 

;;				Accel_PID_XRoll_kp = NewVar;
CLINEA 0000H 0001H 0815H 0005H 0020H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	st	er0,	NEAR _Accel_PID_XRoll_kp
	st	er2,	NEAR _Accel_PID_XRoll_kp+02h

;;				Accel_PID_YPitch_kp = NewVar;
CLINEA 0000H 0001H 0816H 0005H 0021H
	st	er0,	NEAR _Accel_PID_YPitch_kp
	st	er2,	NEAR _Accel_PID_YPitch_kp+02h
CBLOCKEND 232 12 2071

;;			}
CLINEA 0000H 0000H 0817H 0004H 0004H
_$L467 :
CBLOCKEND 232 11 2072

;;		if(RecWorld[0] == 0x6B){			//if RECWORLD == "ki"
CLINEA 0000H 0001H 081AH 0003H 0032H
	l	r0,	NEAR _RecWorld
	cmp	r0,	#06bh
	bne	_$L471
CBLOCK 232 13 2074

;;			if(RecWorld[1] == 0x69){
CLINEA 0000H 0001H 081BH 0004H 001BH
	l	r0,	NEAR _RecWorld+01h
	cmp	r0,	#069h
	bne	_$L471
CBLOCK 232 14 2075

;;				NewVar_Str[0] = RecWorld[2];
CLINEA 0000H 0001H 081CH 0005H 0020H
	l	r0,	NEAR _RecWorld+02h
	st	r0,	NEAR _NewVar_Str

;;				NewVar_Str[1] = RecWorld[3];
CLINEA 0000H 0001H 081DH 0005H 0020H
	l	r0,	NEAR _RecWorld+03h
	st	r0,	NEAR _NewVar_Str+01h

;;				NewVar_Str[2] = RecWorld[4];
CLINEA 0000H 0001H 081EH 0005H 0020H
	l	r0,	NEAR _RecWorld+04h
	st	r0,	NEAR _NewVar_Str+02h

;;				NewVar_Str[3] = RecWorld[5];
CLINEA 0000H 0001H 081FH 0005H 0020H
	l	r0,	NEAR _RecWorld+05h
	st	r0,	NEAR _NewVar_Str+03h

;;				NewVar_Str[4] = RecWorld[6];
CLINEA 0000H 0001H 0820H 0005H 0020H
	l	r0,	NEAR _RecWorld+06h
	st	r0,	NEAR _NewVar_Str+04h

;;				NewVar_Str[5] = RecWorld[7];
CLINEA 0000H 0001H 0821H 0005H 0020H
	l	r0,	NEAR _RecWorld+07h
	st	r0,	NEAR _NewVar_Str+05h

;;				sscanf(NewVar_Str, "%f", &NewVar);
CLINEA 0000H 0001H 0822H 0005H 0026H
	mov	r0,	#BYTE1 OFFSET _NewVar
	mov	r1,	#BYTE2 OFFSET _NewVar
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _NewVar_Str
	mov	r1,	#BYTE2 OFFSET _NewVar_Str
	push	er0
	bl	_sscanf_nn
	add	sp,	#6 

;;				Accel_PID_XRoll_ki = NewVar;
CLINEA 0000H 0001H 0823H 0005H 0020H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	st	er0,	NEAR _Accel_PID_XRoll_ki
	st	er2,	NEAR _Accel_PID_XRoll_ki+02h

;;				Accel_PID_YPitch_ki = NewVar;
CLINEA 0000H 0001H 0824H 0005H 0021H
	st	er0,	NEAR _Accel_PID_YPitch_ki
	st	er2,	NEAR _Accel_PID_YPitch_ki+02h
CBLOCKEND 232 14 2085

;;			}
CLINEA 0000H 0000H 0825H 0004H 0004H
_$L471 :
CBLOCKEND 232 13 2086

;;		if(RecWorld[0] == 0x6B){			//if RECWORLD == "kd"
CLINEA 0000H 0001H 0828H 0003H 0032H
	l	r0,	NEAR _RecWorld
	cmp	r0,	#06bh
	bne	_$L475
CBLOCK 232 15 2088

;;			if(RecWorld[1] == 0x64){
CLINEA 0000H 0001H 0829H 0004H 001BH
	l	r0,	NEAR _RecWorld+01h
	cmp	r0,	#064h
	bne	_$L475
CBLOCK 232 16 2089

;;				NewVar_Str[0] = RecWorld[2];
CLINEA 0000H 0001H 082AH 0005H 0020H
	l	r0,	NEAR _RecWorld+02h
	st	r0,	NEAR _NewVar_Str

;;				NewVar_Str[1] = RecWorld[3];
CLINEA 0000H 0001H 082BH 0005H 0020H
	l	r0,	NEAR _RecWorld+03h
	st	r0,	NEAR _NewVar_Str+01h

;;				NewVar_Str[2] = RecWorld[4];
CLINEA 0000H 0001H 082CH 0005H 0020H
	l	r0,	NEAR _RecWorld+04h
	st	r0,	NEAR _NewVar_Str+02h

;;				NewVar_Str[3] = RecWorld[5];
CLINEA 0000H 0001H 082DH 0005H 0020H
	l	r0,	NEAR _RecWorld+05h
	st	r0,	NEAR _NewVar_Str+03h

;;				NewVar_Str[4] = RecWorld[6];
CLINEA 0000H 0001H 082EH 0005H 0020H
	l	r0,	NEAR _RecWorld+06h
	st	r0,	NEAR _NewVar_Str+04h

;;				NewVar_Str[5] = RecWorld[7];
CLINEA 0000H 0001H 082FH 0005H 0020H
	l	r0,	NEAR _RecWorld+07h
	st	r0,	NEAR _NewVar_Str+05h

;;				sscanf(NewVar_Str, "%f", &NewVar);
CLINEA 0000H 0001H 0830H 0005H 0026H
	mov	r0,	#BYTE1 OFFSET _NewVar
	mov	r1,	#BYTE2 OFFSET _NewVar
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _NewVar_Str
	mov	r1,	#BYTE2 OFFSET _NewVar_Str
	push	er0
	bl	_sscanf_nn
	add	sp,	#6 

;;				Accel_PID_XRoll_kd = NewVar;
CLINEA 0000H 0001H 0831H 0005H 0020H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	st	er0,	NEAR _Accel_PID_XRoll_kd
	st	er2,	NEAR _Accel_PID_XRoll_kd+02h

;;				Accel_PID_YPitch_kd = NewVar;
CLINEA 0000H 0001H 0832H 0005H 0021H
	st	er0,	NEAR _Accel_PID_YPitch_kd
	st	er2,	NEAR _Accel_PID_YPitch_kd+02h
CBLOCKEND 232 16 2099

;;			}
CLINEA 0000H 0000H 0833H 0004H 0004H
_$L475 :
CBLOCKEND 232 15 2100

;;		if(RecWorld[0] == 0x61){			//if RECWORLD == "a1"
CLINEA 0000H 0001H 0836H 0003H 0032H
	l	r0,	NEAR _RecWorld
	cmp	r0,	#061h
	beq	_$M32
	b	_$L479
_$M32 :
CBLOCK 232 17 2102

;;			if(RecWorld[1] == 0x31){
CLINEA 0000H 0001H 0837H 0004H 001BH
	l	r0,	NEAR _RecWorld+01h
	cmp	r0,	#031h
	bne	_$L479
CBLOCK 232 18 2103

;;				NewVar_Str[0] = RecWorld[2];
CLINEA 0000H 0001H 0838H 0005H 0020H
	l	r0,	NEAR _RecWorld+02h
	st	r0,	NEAR _NewVar_Str

;;				NewVar_Str[1] = RecWorld[3];
CLINEA 0000H 0001H 0839H 0005H 0020H
	l	r0,	NEAR _RecWorld+03h
	st	r0,	NEAR _NewVar_Str+01h

;;				NewVar_Str[2] = RecWorld[4];
CLINEA 0000H 0001H 083AH 0005H 0020H
	l	r0,	NEAR _RecWorld+04h
	st	r0,	NEAR _NewVar_Str+02h

;;				NewVar_Str[3] = RecWorld[5];
CLINEA 0000H 0001H 083BH 0005H 0020H
	l	r0,	NEAR _RecWorld+05h
	st	r0,	NEAR _NewVar_Str+03h

;;				NewVar_Str[4] = RecWorld[6];
CLINEA 0000H 0001H 083CH 0005H 0020H
	l	r0,	NEAR _RecWorld+06h
	st	r0,	NEAR _NewVar_Str+04h

;;				NewVar_Str[5] = RecWorld[7];
CLINEA 0000H 0001H 083DH 0005H 0020H
	l	r0,	NEAR _RecWorld+07h
	st	r0,	NEAR _NewVar_Str+05h

;;				sscanf(NewVar_Str, "%f", &NewVar);
CLINEA 0000H 0001H 083EH 0005H 0026H
	mov	r0,	#BYTE1 OFFSET _NewVar
	mov	r1,	#BYTE2 OFFSET _NewVar
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _NewVar_Str
	mov	r1,	#BYTE2 OFFSET _NewVar_Str
	push	er0
	bl	_sscanf_nn
	add	sp,	#6 

;;				CF_HPF = NewVar;
CLINEA 0000H 0001H 083FH 0005H 0014H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	st	er0,	NEAR _CF_HPF
	st	er2,	NEAR _CF_HPF+02h

;;				CF_LPF = 1-NewVar;
CLINEA 0000H 0001H 0840H 0005H 0016H
	mov	er0,	#0 
	mov	r2,	#080h
	mov	r3,	#03fh
	push	xr0
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_LPF
	st	er2,	NEAR _CF_LPF+02h
CBLOCKEND 232 18 2113

;;			}
CLINEA 0000H 0000H 0841H 0004H 0004H
_$L479 :
CBLOCKEND 232 17 2114

;;		if(RecWorld[0] == 0x61){			//if RECWORLD == "a2"
CLINEA 0000H 0001H 0844H 0003H 0032H
	l	r0,	NEAR _RecWorld
	cmp	r0,	#061h
	beq	_$M33
	b	_$L483
_$M33 :
CBLOCK 232 19 2116

;;			if(RecWorld[1] == 0x32){
CLINEA 0000H 0001H 0845H 0004H 001BH
	l	r0,	NEAR _RecWorld+01h
	cmp	r0,	#032h
	bne	_$L483
CBLOCK 232 20 2117

;;				NewVar_Str[0] = RecWorld[2];
CLINEA 0000H 0001H 0846H 0005H 0020H
	l	r0,	NEAR _RecWorld+02h
	st	r0,	NEAR _NewVar_Str

;;				NewVar_Str[1] = RecWorld[3];
CLINEA 0000H 0001H 0847H 0005H 0020H
	l	r0,	NEAR _RecWorld+03h
	st	r0,	NEAR _NewVar_Str+01h

;;				NewVar_Str[2] = RecWorld[4];
CLINEA 0000H 0001H 0848H 0005H 0020H
	l	r0,	NEAR _RecWorld+04h
	st	r0,	NEAR _NewVar_Str+02h

;;				NewVar_Str[3] = RecWorld[5];
CLINEA 0000H 0001H 0849H 0005H 0020H
	l	r0,	NEAR _RecWorld+05h
	st	r0,	NEAR _NewVar_Str+03h

;;				NewVar_Str[4] = RecWorld[6];
CLINEA 0000H 0001H 084AH 0005H 0020H
	l	r0,	NEAR _RecWorld+06h
	st	r0,	NEAR _NewVar_Str+04h

;;				NewVar_Str[5] = RecWorld[7];
CLINEA 0000H 0001H 084BH 0005H 0020H
	l	r0,	NEAR _RecWorld+07h
	st	r0,	NEAR _NewVar_Str+05h

;;				sscanf(NewVar_Str, "%f", &NewVar);
CLINEA 0000H 0001H 084CH 0005H 0026H
	mov	r0,	#BYTE1 OFFSET _NewVar
	mov	r1,	#BYTE2 OFFSET _NewVar
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S269
	mov	r1,	#BYTE2 OFFSET $$S269
	push	er0
	mov	r0,	#BYTE1 OFFSET _NewVar_Str
	mov	r1,	#BYTE2 OFFSET _NewVar_Str
	push	er0
	bl	_sscanf_nn
	add	sp,	#6 

;;				CF_HPF = 1-NewVar;
CLINEA 0000H 0001H 084DH 0005H 0016H
	mov	er0,	#0 
	mov	r2,	#080h
	mov	r3,	#03fh
	push	xr0
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_HPF
	st	er2,	NEAR _CF_HPF+02h

;;				CF_LPF = NewVar;
CLINEA 0000H 0001H 084EH 0005H 0014H
	l	er0,	NEAR _NewVar
	l	er2,	NEAR _NewVar+02h
	st	er0,	NEAR _CF_LPF
	st	er2,	NEAR _CF_LPF+02h
CBLOCKEND 232 20 2127

;;			}
CLINEA 0000H 0000H 084FH 0004H 0004H
_$L483 :
CBLOCKEND 232 19 2128

;;		for(k = 0; k<150; k++)
CLINEA 0000H 0001H 0852H 0007H 000CH
	mov	er0,	#0 

;;		for(k = 0; k<150; k++)
CLINEA 0000H 0000H 0852H 0015H 0017H
_$L487 :
CBLOCK 232 21 2131

;;			SensorReturn[k] = 0x20;
CLINEA 0000H 0001H 0854H 0004H 001AH
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 232 21 2133

;;		for(k = 0; k<150; k++)
CLINEA 0000H 0000H 0852H 0015H 0017H
	add	er0,	#1 

;;		for(k = 0; k<150; k++)
CLINEA 0000H 0000H 0852H 000EH 0013H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L487

;;		sprintf(SensorReturn, "    New Settings: kp=%f,ki=%f,kd=%f,a1=%f,a2=%f,Pb=%u,Db=%u", Accel_PID_XRoll_kp, Accel_PID_XRoll_ki, Accel_PID_XRoll_kd, CF_HPF, CF_LPF,Accel_PID_PBounds_Var_Pos,Accel_PID_DBounds_Var_Pos);
CLINEA 0000H 0001H 0857H 0003H 00D7H
	l	er0,	NEAR _Accel_PID_DBounds_Var_Pos
	push	er0
	l	er0,	NEAR _Accel_PID_PBounds_Var_Pos
	push	er0
	l	er0,	NEAR _CF_LPF
	l	er2,	NEAR _CF_LPF+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _CF_HPF
	l	er2,	NEAR _CF_HPF+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_PID_XRoll_kd
	l	er2,	NEAR _Accel_PID_XRoll_kd+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_PID_XRoll_ki
	l	er2,	NEAR _Accel_PID_XRoll_ki+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Accel_PID_XRoll_kp
	l	er2,	NEAR _Accel_PID_XRoll_kp+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	r0,	#BYTE1 OFFSET $$S491
	mov	r1,	#BYTE2 OFFSET $$S491
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#48

;;		SensorReturn[148] = 0x0D;	//CR
CLINEA 0000H 0001H 0859H 0003H 0020H
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;		SensorReturn[149] = 0x0A;	//LF
CLINEA 0000H 0001H 085AH 0003H 0020H
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;		_flgUartFin = 0;
CLINEA 0000H 0001H 085DH 0003H 0012H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;		uart_stop();
CLINEA 0000H 0001H 085EH 0003H 000EH
	bl	_uart_stop

;;		uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 085FH 0003H 0032H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0860H 0001H 0001H
	bal	_$L497

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0860H 0003H 001AH
_$L494 :
CBLOCK 232 22 2144

;;			main_clrWDT();
CLINEA 0000H 0001H 0861H 0004H 0011H
	bl	_main_clrWDT
CBLOCKEND 232 22 2146

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0860H 0001H 0001H
_$L497 :

;;		while(_flgUartFin != 1){
CLINEA 0000H 0000H 0860H 000EH 0013H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L494

;;		ETM8 = 1;	//Turn TIMER8/9 ISR Back ON
CLINEA 0000H 0001H 0864H 0003H 0027H
	sb	0f013h.2

;;		ETM9 = 1;	//Turn TIMER8/9 ISR Back ON		
CLINEA 0000H 0001H 0865H 0003H 0029H
	sb	0f013h.3
CBLOCKEND 232 2 2150

;;}
CLINEA 0000H 0001H 0866H 0001H 0001H
	pop	pc
CBLOCKEND 232 1 2150
CFUNCTIONEND 232


	rseg $$SoftStart$main
CFUNCTION 233

_SoftStart	:
CBLOCK 233 1 2154

;;{
CLINEA 0000H 0001H 086AH 0001H 0001H
	push	lr
CBLOCK 233 2 2154
CRET 0000H

;;	PWED += PWMtoRPMOffset_Mot2;	
CLINEA 0000H 0001H 086EH 0002H 001EH
	l	er0,	0f932h
	l	er2,	NEAR _PWMtoRPMOffset_Mot2
	add	er0,	er2
	st	er0,	0f932h

;;	PWDD += PWMtoRPMOffset_Mot3;	
CLINEA 0000H 0001H 086FH 0002H 001EH
	l	er0,	0f922h
	l	er2,	NEAR _PWMtoRPMOffset_Mot3
	add	er0,	er2
	st	er0,	0f922h

;;	PWCD += PWMtoRPMOffset_Mot4;
CLINEA 0000H 0001H 0870H 0002H 001DH
	l	er0,	0f912h
	l	er2,	NEAR _PWMtoRPMOffset_Mot4
	add	er0,	er2
	st	er0,	0f912h

;;	while(PWF0D < PWMIdleDutyRun){
CLINEA 0000H 0001H 0871H 0002H 001FH
	bal	_$L499
_$L501 :
CBLOCK 233 3 2161

;;		NOPms(50);
CLINEA 0000H 0001H 0872H 0003H 000CH
	mov	er0,	#50
	bl	_NOPms

;;		PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0873H 0003H 001BH
	rb	0f973h.0

;;		PERUN = 0;
CLINEA 0000H 0001H 0874H 0003H 000CH
	rb	0f937h.0

;;		PDRUN = 0;
CLINEA 0000H 0001H 0875H 0003H 000CH
	rb	0f927h.0

;;		PCRUN = 0;
CLINEA 0000H 0001H 0876H 0003H 000CH
	rb	0f917h.0

;;		PWF0D += 1; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0877H 0003H 0041H
	l	er0,	0f962h
	add	er0,	#1 
	st	er0,	0f962h

;;		PWED += 1;	
CLINEA 0000H 0001H 0878H 0003H 000DH
	l	er0,	0f932h
	add	er0,	#1 
	st	er0,	0f932h

;;		PWDD += 1;	
CLINEA 0000H 0001H 0879H 0003H 000DH
	l	er0,	0f922h
	add	er0,	#1 
	st	er0,	0f922h

;;		PWCD += 1;
CLINEA 0000H 0001H 087AH 0003H 000CH
	l	er0,	0f912h
	add	er0,	#1 
	st	er0,	0f912h

;;		PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 087CH 0003H 001AH
	sb	0f973h.0

;;		PERUN = 1;
CLINEA 0000H 0001H 087DH 0003H 000CH
	sb	0f937h.0

;;		PDRUN = 1;
CLINEA 0000H 0001H 087EH 0003H 000CH
	sb	0f927h.0

;;		PCRUN = 1;
CLINEA 0000H 0001H 087FH 0003H 000CH
	sb	0f917h.0
CBLOCKEND 233 3 2176

;;	}
CLINEA 0000H 0000H 0880H 0002H 0002H
_$L499 :

;;	while(PWF0D < PWMIdleDutyRun){
CLINEA 0000H 0000H 0871H 000EH 0013H
	l	er0,	0f962h
	l	er2,	NEAR _PWMIdleDutyRun
	cmp	er0,	er2
	blt	_$L501

;;	while(PrePIDCount < 10){
CLINEA 0000H 0000H 0881H 0001H 0001H
	bal	_$L513

;;	while(PrePIDCount < 10){
CLINEA 0000H 0000H 0881H 0002H 0019H
_$L505 :
CBLOCK 233 4 2177

;;		if(AccGyro_ReadFlag >= 1){		//Triggered by External Interrupt (flag set in AccelGyroDataReady_ISR)
CLINEA 0000H 0001H 0882H 0003H 0064H
	l	r0,	NEAR _AccGyro_ReadFlag
	cmp	r0,	#01h
	blt	_$L507
CBLOCK 233 5 2178

;;			Get_AccGyroData();
CLINEA 0000H 0001H 0884H 0004H 0015H
	bl	_Get_AccGyroData

;;			AccGyro_ReadFlag = 0;
CLINEA 0000H 0001H 0886H 0004H 0018H
	mov	r0,	#00h
	st	r0,	NEAR _AccGyro_ReadFlag
CBLOCKEND 233 5 2183

;;		}
CLINEA 0000H 0000H 0887H 0003H 0003H
_$L507 :

;;		if(AccGyro_CF_FlagCounter > 0){	//This Value is incremented after Get_AccGyroData(); is called
CLINEA 0000H 0001H 0888H 0003H 0060H
	l	r0,	NEAR _AccGyro_CF_FlagCounter
	cmp	r0,	#00h
	ble	_$L509
CBLOCK 233 6 2184

;;			Run_AccGyroCF();
CLINEA 0000H 0001H 088AH 0004H 0013H
	bl	_Run_AccGyroCF

;;			AccGyro_CF_FlagCounter--;	//Decremented because this value is not a static 1/0... number shows number of items in buffer that have not gone though the CF yet
CLINEA 0000H 0000H 088CH 0004H 00A0H
	lea	OFFSET _AccGyro_CF_FlagCounter
	dec	[ea]
CBLOCKEND 233 6 2189

;;		}
CLINEA 0000H 0000H 088DH 0003H 0003H
_$L509 :

;;		if(Accel_PID_GoCounter>= 1){		//This increments in the Run_AccGyroCF()... I don't know if this is the best trigger.. but for now, it works.  Calls GetAccGyroData and AccGyroCF once within the routine.
CLINEA 0000H 0001H 088EH 0003H 00CAH
	l	r0,	NEAR _Accel_PID_GoCounter
	cmp	r0,	#01h
	blt	_$L511
CBLOCK 233 7 2190

;;			AccelSensorControlPID_P(); 		
CLINEA 0000H 0001H 0890H 0004H 0020H
	bl	_AccelSensorControlPID_P

;;			AccelSensorControlPID_I(); 		
CLINEA 0000H 0001H 0891H 0004H 0020H
	bl	_AccelSensorControlPID_I

;;			AccelSensorControlPID_D(); 		
CLINEA 0000H 0001H 0892H 0004H 0020H
	bl	_AccelSensorControlPID_D

;;			Accel_PID_GoCounter = 0;
CLINEA 0000H 0001H 0894H 0004H 001BH
	mov	r0,	#00h
	st	r0,	NEAR _Accel_PID_GoCounter

;;			PrePIDCount++;			//Comment this out to always loop (i.e.: no shut-down...)
CLINEA 0000H 0000H 0895H 0004H 004DH
	lea	OFFSET _PrePIDCount
	inc	[ea]
CBLOCKEND 233 7 2198

;;		}
CLINEA 0000H 0000H 0896H 0003H 0003H
_$L511 :

;;		main_clrWDT();
CLINEA 0000H 0001H 0897H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 233 4 2200

;;	while(PrePIDCount < 10){
CLINEA 0000H 0000H 0881H 0001H 0001H
_$L513 :

;;	while(PrePIDCount < 10){
CLINEA 0000H 0000H 0881H 000EH 0013H
	l	r0,	NEAR _PrePIDCount
	cmp	r0,	#0ah
	blt	_$L505

;;	Accel_PID_XRollErrSum = 0;
CLINEA 0000H 0001H 0899H 0002H 001BH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_XRollErrSum
	st	er0,	NEAR _Accel_PID_XRollErrSum+02h

;;	Accel_PID_YPitchErrSum = 0;	
CLINEA 0000H 0001H 089AH 0002H 001DH
	st	er0,	NEAR _Accel_PID_YPitchErrSum
	st	er0,	NEAR _Accel_PID_YPitchErrSum+02h
CBLOCKEND 233 2 2204

;;}
CLINEA 0000H 0001H 089CH 0001H 0001H
	pop	pc
CBLOCKEND 233 1 2204
CFUNCTIONEND 233


	rseg $$RampUpMotorTest$main
CFUNCTION 234

_RampUpMotorTest	:
CBLOCK 234 1 2209

;;void RampUpMotorTest(void){
CLINEA 0000H 0001H 08A1H 0001H 001BH
CBLOCK 234 2 2209

;;	if(PWMCounter < PWMSensorResPerInc){
CLINEA 0000H 0001H 08A2H 0002H 0025H
	l	r0,	NEAR _PWMCounter
	l	r1,	NEAR _PWMSensorResPerInc
	cmp	r0,	r1
	bge	_$L515
CBLOCK 234 3 2210

;;		PWMCounter++;
CLINEA 0000H 0000H 08A3H 0003H 000FH
	add	r0,	#01h
	st	r0,	NEAR _PWMCounter
CBLOCKEND 234 3 2212

;;	else{
CLINEA 0000H 0001H 08A5H 0002H 0006H
	rt
_$L515 :
CBLOCK 234 4 2213

;;		if(PWED < PWMUpperDutyLimitCalib){
CLINEA 0000H 0001H 08A6H 0003H 0024H
	l	er0,	0f932h
	l	er2,	NEAR _PWMUpperDutyLimitCalib
	cmp	er0,	er2
	blt	_$M36
	b	_$L524
_$M36 :
CBLOCK 234 5 2214

;;			if(PWMflag == 0){
CLINEA 0000H 0001H 08A7H 0004H 0014H
	l	r0,	NEAR _PWMflag
	bne	_$L520
CBLOCK 234 6 2215

;;				PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 08A8H 0005H 001DH
	rb	0f973h.0

;;				PERUN = 0;
CLINEA 0000H 0001H 08A9H 0005H 000EH
	rb	0f937h.0

;;				PDRUN = 0;
CLINEA 0000H 0001H 08AAH 0005H 000EH
	rb	0f927h.0

;;				PCRUN = 0;
CLINEA 0000H 0001H 08ABH 0005H 000EH
	rb	0f917h.0

;;				PWF0D += MotorStep; //Can't be running to change (Only this variable)
CLINEA 0000H 0001H 08ACH 0005H 0049H
	l	er0,	0f962h
	l	er2,	NEAR _MotorStep
	add	er0,	er2
	st	er0,	0f962h

;;				PWED += MotorStep;
CLINEA 0000H 0001H 08ADH 0005H 0016H
	l	er0,	0f932h
	add	er0,	er2
	st	er0,	0f932h

;;				PWDD += MotorStep;
CLINEA 0000H 0001H 08AEH 0005H 0016H
	l	er0,	0f922h
	add	er0,	er2
	st	er0,	0f922h

;;				PWCD += MotorStep;
CLINEA 0000H 0001H 08AFH 0005H 0016H
	l	er0,	0f912h
	add	er0,	er2
	st	er0,	0f912h

;;				PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 08B0H 0005H 001CH
	sb	0f973h.0

;;				PERUN = 1;
CLINEA 0000H 0001H 08B1H 0005H 000EH
	sb	0f937h.0

;;				PDRUN = 1;
CLINEA 0000H 0001H 08B2H 0005H 000EH
	sb	0f927h.0

;;				PCRUN = 1;
CLINEA 0000H 0001H 08B3H 0005H 000EH
	sb	0f917h.0
CBLOCKEND 234 6 2228

;;			}
CLINEA 0000H 0000H 08B4H 0004H 0004H
_$L520 :

;;			if(PWMflag == 1){
CLINEA 0000H 0001H 08B5H 0004H 0014H
	l	r0,	NEAR _PWMflag
	cmp	r0,	#01h
	bne	_$L524
CBLOCK 234 7 2229

;;				PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 08B6H 0005H 001DH
	rb	0f973h.0

;;				PERUN = 0;
CLINEA 0000H 0001H 08B7H 0005H 000EH
	rb	0f937h.0

;;				PDRUN = 0;
CLINEA 0000H 0001H 08B8H 0005H 000EH
	rb	0f927h.0

;;				PCRUN = 0;
CLINEA 0000H 0001H 08B9H 0005H 000EH
	rb	0f917h.0

;;				PWF0D -= MotorStep; //Can't be running to change (Only this variable)
CLINEA 0000H 0001H 08BAH 0005H 0049H
	l	er0,	0f962h
	l	er2,	NEAR _MotorStep
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f962h

;;				PWED -= MotorStep;
CLINEA 0000H 0001H 08BBH 0005H 0016H
	l	er0,	0f932h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f932h

;;				PWDD -= MotorStep;
CLINEA 0000H 0001H 08BCH 0005H 0016H
	l	er0,	0f922h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f922h

;;				PWCD -= MotorStep;
CLINEA 0000H 0001H 08BDH 0005H 0016H
	l	er0,	0f912h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f912h

;;				PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 08BEH 0005H 001CH
	sb	0f973h.0

;;				PERUN = 1;
CLINEA 0000H 0001H 08BFH 0005H 000EH
	sb	0f937h.0

;;				PDRUN = 1;
CLINEA 0000H 0001H 08C0H 0005H 000EH
	sb	0f927h.0

;;				PCRUN = 1;
CLINEA 0000H 0001H 08C1H 0005H 000EH
	sb	0f917h.0

;;				if(PWED <= PWMSafeDuty){
CLINEA 0000H 0001H 08C2H 0005H 001CH
	l	er0,	0f932h
	l	er2,	NEAR _PWMSafeDuty
	cmp	er0,	er2
	bgt	_$L524
CBLOCK 234 8 2242

;;					PWMflag = 2;
CLINEA 0000H 0001H 08C3H 0006H 0011H
	mov	r0,	#02h
	st	r0,	NEAR _PWMflag
CBLOCKEND 234 8 2244

;;				}
CLINEA 0000H 0000H 08C4H 0005H 0005H
_$L524 :
CBLOCKEND 234 7 2245
CBLOCKEND 234 5 2246

;;		if(PWED >= PWMUpperDutyLimitCalib){
CLINEA 0000H 0001H 08C7H 0003H 0025H
	l	er0,	0f932h
	l	er2,	NEAR _PWMUpperDutyLimitCalib
	cmp	er0,	er2
	blt	_$L526
CBLOCK 234 9 2247

;;			PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 08C8H 0004H 001CH
	rb	0f973h.0

;;			PERUN = 0;
CLINEA 0000H 0001H 08C9H 0004H 000DH
	rb	0f937h.0

;;			PDRUN = 0;
CLINEA 0000H 0001H 08CAH 0004H 000DH
	rb	0f927h.0

;;			PCRUN = 0;
CLINEA 0000H 0001H 08CBH 0004H 000DH
	rb	0f917h.0

;;			PWF0D -= MotorStep; //Can't be running to change (Only this variable)
CLINEA 0000H 0001H 08CCH 0004H 0048H
	l	er0,	0f962h
	l	er2,	NEAR _MotorStep
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f962h

;;			PWED -= MotorStep;
CLINEA 0000H 0001H 08CDH 0004H 0015H
	l	er0,	0f932h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f932h

;;			PWDD -= MotorStep;
CLINEA 0000H 0001H 08CEH 0004H 0015H
	l	er0,	0f922h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f922h

;;			PWCD -= MotorStep;
CLINEA 0000H 0001H 08CFH 0004H 0015H
	l	er0,	0f912h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f912h

;;			PWMflag = 1;
CLINEA 0000H 0001H 08D0H 0004H 000FH
	mov	r0,	#01h
	st	r0,	NEAR _PWMflag

;;			PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 08D1H 0004H 001BH
	sb	0f973h.0

;;			PERUN = 1;
CLINEA 0000H 0001H 08D2H 0004H 000DH
	sb	0f937h.0

;;			PDRUN = 1;
CLINEA 0000H 0001H 08D3H 0004H 000DH
	sb	0f927h.0

;;			PCRUN = 1;
CLINEA 0000H 0001H 08D4H 0004H 000DH
	sb	0f917h.0
CBLOCKEND 234 9 2261

;;		}
CLINEA 0000H 0000H 08D5H 0003H 0003H
_$L526 :

;;		PWMCounter = 0;
CLINEA 0000H 0001H 08D6H 0003H 0011H
	mov	r0,	#00h
	st	r0,	NEAR _PWMCounter
CBLOCKEND 234 4 2263

;;	}
CLINEA 0000H 0000H 08D7H 0002H 0002H
CBLOCKEND 234 2 2264

;;}
CLINEA 0000H 0001H 08D8H 0001H 0001H
	rt
CBLOCKEND 234 1 2264
CFUNCTIONEND 234


	rseg $$DistanceSensorControl$main
CFUNCTION 235

_DistanceSensorControl	:
CBLOCK 235 1 2265

;;void DistanceSensorControl(void){
CLINEA 0000H 0001H 08D9H 0001H 0021H
	push	lr
CBLOCK 235 2 2265
CRET 0000H

;;	if((Range_out < Range_ZHiThres)||(Range_out > Range_Ceiling)){	//65 = 4Ft Level, 240 accounts for sensor error when too close to ground.
CLINEA 0000H 0001H 08DAH 0002H 0089H
	l	er0,	NEAR _Range_out
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Range_ZHiThres
	l	er2,	NEAR _Range_ZHiThres+02h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$L530
	l	er0,	NEAR _Range_out
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Range_Ceiling
	l	er2,	NEAR _Range_Ceiling+02h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L529
_$L530 :
CBLOCK 235 3 2266

;;		PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 08DBH 0003H 001BH
	rb	0f973h.0

;;		PERUN = 0;
CLINEA 0000H 0001H 08DCH 0003H 000CH
	rb	0f937h.0

;;		PDRUN = 0;
CLINEA 0000H 0001H 08DDH 0003H 000CH
	rb	0f927h.0

;;		PCRUN = 0;
CLINEA 0000H 0001H 08DEH 0003H 000CH
	rb	0f917h.0

;;		PWF0D += MotorStep; //Can't be running to change (Only this variable)
CLINEA 0000H 0001H 08DFH 0003H 0047H
	l	er0,	0f962h
	l	er2,	NEAR _MotorStep
	add	er0,	er2
	st	er0,	0f962h

;;		PWED += MotorStep;
CLINEA 0000H 0001H 08E0H 0003H 0014H
	l	er0,	0f932h
	add	er0,	er2
	st	er0,	0f932h

;;		PWDD += MotorStep;
CLINEA 0000H 0001H 08E1H 0003H 0014H
	l	er0,	0f922h
	add	er0,	er2
	st	er0,	0f922h

;;		PWCD += MotorStep;
CLINEA 0000H 0001H 08E2H 0003H 0014H
	l	er0,	0f912h
	add	er0,	er2
	st	er0,	0f912h

;;		PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 08E3H 0003H 001AH
	sb	0f973h.0

;;		PERUN = 1;
CLINEA 0000H 0001H 08E4H 0003H 000CH
	sb	0f937h.0

;;		PDRUN = 1;
CLINEA 0000H 0001H 08E5H 0003H 000CH
	sb	0f927h.0

;;		PCRUN = 1;
CLINEA 0000H 0001H 08E6H 0003H 000CH
	sb	0f917h.0
CBLOCKEND 235 3 2279

;;	}			
CLINEA 0000H 0000H 08E7H 0002H 0005H
_$L529 :

;;	if(Range_out > 75){	//4Ft Level
CLINEA 0000H 0001H 08E8H 0002H 0020H
	l	er0,	NEAR _Range_out
	cmp	r0,	#04bh
	cmpc	r1,	#00h
	ble	_$L536
CBLOCK 235 4 2280

;;		PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 08E9H 0003H 001BH
	rb	0f973h.0

;;		PERUN = 0;
CLINEA 0000H 0001H 08EAH 0003H 000CH
	rb	0f937h.0

;;		PDRUN = 0;
CLINEA 0000H 0001H 08EBH 0003H 000CH
	rb	0f927h.0

;;		PCRUN = 0;
CLINEA 0000H 0001H 08ECH 0003H 000CH
	rb	0f917h.0

;;		PWF0D -= MotorStep; //Can't be running to change (Only this variable)
CLINEA 0000H 0001H 08EDH 0003H 0047H
	l	er0,	0f962h
	l	er2,	NEAR _MotorStep
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f962h

;;		PWED -= MotorStep;
CLINEA 0000H 0001H 08EEH 0003H 0014H
	l	er0,	0f932h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f932h

;;		PWDD -= MotorStep;
CLINEA 0000H 0001H 08EFH 0003H 0014H
	l	er0,	0f922h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f922h

;;		PWCD -= MotorStep;
CLINEA 0000H 0001H 08F0H 0003H 0014H
	l	er0,	0f912h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f912h

;;		PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 08F1H 0003H 001AH
	sb	0f973h.0

;;		PERUN = 1;
CLINEA 0000H 0001H 08F2H 0003H 000CH
	sb	0f937h.0

;;		PDRUN = 1;
CLINEA 0000H 0001H 08F3H 0003H 000CH
	sb	0f927h.0

;;		PCRUN = 1;
CLINEA 0000H 0001H 08F4H 0003H 000CH
	sb	0f917h.0
CBLOCKEND 235 4 2293

;;	}
CLINEA 0000H 0000H 08F5H 0002H 0002H
_$L536 :
CBLOCKEND 235 2 2337

;;}
CLINEA 0000H 0001H 0921H 0001H 0001H
	pop	pc
CBLOCKEND 235 1 2337
CFUNCTIONEND 235


	rseg $$MagSensorControl$main
CFUNCTION 236

_MagSensorControl	:
CBLOCK 236 1 2400

;;void MagSensorControl(void){
CLINEA 0000H 0001H 0960H 0001H 001CH
	push	lr
CBLOCK 236 2 2400
CRET 0000H

;;	if((Mag_Angle > Mag_CWThres)&&(Mag_Angle < Mag_OpposingPole)){
CLINEA 0000H 0001H 0961H 0002H 003FH
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	l	er0,	NEAR _Mag_CWThres
	l	er2,	NEAR _Mag_CWThres+02h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L539
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	l	er0,	NEAR _Mag_OpposingPole
	l	er2,	NEAR _Mag_OpposingPole+02h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L539
CBLOCK 236 3 2401

;;		PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0962H 0003H 001BH
	rb	0f973h.0

;;		PERUN = 0;
CLINEA 0000H 0001H 0963H 0003H 000CH
	rb	0f937h.0

;;		PDRUN = 0;
CLINEA 0000H 0001H 0964H 0003H 000CH
	rb	0f927h.0

;;		PCRUN = 0;
CLINEA 0000H 0001H 0965H 0003H 000CH
	rb	0f917h.0

;;		PWF0D += Mag_MotorStep; //Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0966H 0003H 004BH
	l	er0,	0f962h
	l	er2,	NEAR _Mag_MotorStep
	add	er0,	er2
	st	er0,	0f962h

;;		PWED -= Mag_MotorStep;
CLINEA 0000H 0001H 0967H 0003H 0018H
	l	er0,	0f932h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f932h

;;		PWDD -= Mag_MotorStep;
CLINEA 0000H 0001H 0968H 0003H 0018H
	l	er0,	0f922h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f922h

;;		PWCD += Mag_MotorStep;
CLINEA 0000H 0001H 0969H 0003H 0018H
	l	er0,	0f912h
	add	er0,	er2
	st	er0,	0f912h

;;		PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 096AH 0003H 001AH
	sb	0f973h.0

;;		PERUN = 1;
CLINEA 0000H 0001H 096BH 0003H 000CH
	sb	0f937h.0

;;		PDRUN = 1;
CLINEA 0000H 0001H 096CH 0003H 000CH
	sb	0f927h.0

;;		PCRUN = 1;
CLINEA 0000H 0001H 096DH 0003H 000CH
	sb	0f917h.0
CBLOCKEND 236 3 2414

;;	}
CLINEA 0000H 0000H 096EH 0002H 0002H
_$L539 :

;;	if((Mag_Angle < Mag_CCWThres)&&(Mag_Angle > Mag_OpposingPole)){
CLINEA 0000H 0001H 096FH 0002H 0040H
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	l	er0,	NEAR _Mag_CCWThres
	l	er2,	NEAR _Mag_CCWThres+02h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L546
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	l	er0,	NEAR _Mag_OpposingPole
	l	er2,	NEAR _Mag_OpposingPole+02h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L546
CBLOCK 236 4 2415

;;		PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0970H 0003H 001BH
	rb	0f973h.0

;;		PERUN = 0;
CLINEA 0000H 0001H 0971H 0003H 000CH
	rb	0f937h.0

;;		PDRUN = 0;
CLINEA 0000H 0001H 0972H 0003H 000CH
	rb	0f927h.0

;;		PCRUN = 0;
CLINEA 0000H 0001H 0973H 0003H 000CH
	rb	0f917h.0

;;		PWF0D -= Mag_MotorStep; //Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0974H 0003H 004BH
	l	er0,	0f962h
	l	er2,	NEAR _Mag_MotorStep
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f962h

;;		PWED += Mag_MotorStep;
CLINEA 0000H 0001H 0975H 0003H 0018H
	l	er0,	0f932h
	add	er0,	er2
	st	er0,	0f932h

;;		PWDD += Mag_MotorStep;
CLINEA 0000H 0001H 0976H 0003H 0018H
	l	er0,	0f922h
	add	er0,	er2
	st	er0,	0f922h

;;		PWCD -= Mag_MotorStep;
CLINEA 0000H 0001H 0977H 0003H 0018H
	l	er0,	0f912h
	sub	r0,	r2
	subc	r1,	r3
	st	er0,	0f912h

;;		PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0978H 0003H 001AH
	sb	0f973h.0

;;		PERUN = 1;
CLINEA 0000H 0001H 0979H 0003H 000CH
	sb	0f937h.0

;;		PDRUN = 1;
CLINEA 0000H 0001H 097AH 0003H 000CH
	sb	0f927h.0

;;		PCRUN = 1;
CLINEA 0000H 0001H 097BH 0003H 000CH
	sb	0f917h.0
CBLOCKEND 236 4 2428

;;	}
CLINEA 0000H 0000H 097CH 0002H 0002H
_$L546 :
CBLOCKEND 236 2 2429

;;}
CLINEA 0000H 0001H 097DH 0001H 0001H
	pop	pc
CBLOCKEND 236 1 2429
CFUNCTIONEND 236


	rseg $$MagSensorControlPID$main
CFUNCTION 237

_MagSensorControlPID	:
CBLOCK 237 1 2431

;;void MagSensorControlPID(void){
CLINEA 0000H 0001H 097FH 0001H 001FH
	push	lr
	push	xr4
CBLOCK 237 2 2431
CRET 0004H
CLOCAL 47H 0002H 0024H 0002H "i" 02H 00H 01H

;;	if(Mag_PIDSetpoint > 180){
CLINEA 0000H 0001H 0984H 0002H 001BH
	l	er0,	NEAR _Mag_PIDSetpoint
	l	er2,	NEAR _Mag_PIDSetpoint+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#034h
	mov	r3,	#043h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L554
CBLOCK 237 3 2436

;;		Mag_PIDCorrectionFactor = 360-Mag_PIDSetpoint;
CLINEA 0000H 0001H 0985H 0003H 0030H
	mov	er0,	#0 
	mov	r2,	#0b4h
	mov	r3,	#043h
	push	xr0
	l	er0,	NEAR _Mag_PIDSetpoint
	l	er2,	NEAR _Mag_PIDSetpoint+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_PIDCorrectionFactor
	st	er2,	NEAR _Mag_PIDCorrectionFactor+02h

;;		Mag_PIDAngleScaled = Mag_Angle + Mag_PIDCorrectionFactor;
CLINEA 0000H 0001H 0986H 0003H 003BH
	push	xr0
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_PIDAngleScaled
	st	er2,	NEAR _Mag_PIDAngleScaled+02h

;;		if(Mag_PIDAngleScaled > 180){
CLINEA 0000H 0001H 0987H 0003H 001FH
	push	xr0
	mov	er0,	#0 
	mov	r2,	#034h
	mov	r3,	#043h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L556
CBLOCK 237 4 2439

;;			Mag_PIDError = Mag_PIDAngleScaled - 360;
CLINEA 0000H 0001H 0988H 0004H 002BH
	l	er0,	NEAR _Mag_PIDAngleScaled
	l	er2,	NEAR _Mag_PIDAngleScaled+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#0b4h
	mov	r3,	#0c3h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
CBLOCKEND 237 4 2442

;;		else{
CLINEA 0000H 0001H 098BH 0003H 0007H
	bal	_$L558
_$L556 :
CBLOCK 237 5 2443

;;			Mag_PIDError= Mag_PIDAngleScaled;
CLINEA 0000H 0001H 098CH 0004H 0024H
	l	er0,	NEAR _Mag_PIDAngleScaled
	l	er2,	NEAR _Mag_PIDAngleScaled+02h
CBLOCKEND 237 5 2445

;;		}
CLINEA 0000H 0000H 098DH 0003H 0003H
_$L558 :

;;	else{
CLINEA 0000H 0001H 098FH 0002H 0006H
	bal	_$L562
_$L554 :
CBLOCK 237 6 2447

;;		Mag_PIDCorrectionFactor = Mag_PIDSetpoint;					
CLINEA 0000H 0001H 0990H 0003H 0031H
	l	er0,	NEAR _Mag_PIDSetpoint
	l	er2,	NEAR _Mag_PIDSetpoint+02h
	st	er0,	NEAR _Mag_PIDCorrectionFactor
	st	er2,	NEAR _Mag_PIDCorrectionFactor+02h

;;		Mag_PIDAngleScaled = Mag_Angle - Mag_PIDCorrectionFactor;
CLINEA 0000H 0001H 0992H 0003H 003BH
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	l	er0,	NEAR _Mag_PIDSetpoint
	l	er2,	NEAR _Mag_PIDSetpoint+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_PIDAngleScaled
	st	er2,	NEAR _Mag_PIDAngleScaled+02h

;;		if(Mag_PIDAngleScaled > 180){
CLINEA 0000H 0001H 0993H 0003H 001FH
	push	xr0
	mov	er0,	#0 
	mov	r2,	#034h
	mov	r3,	#043h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L560
CBLOCK 237 7 2451

;;			Mag_PIDError = Mag_PIDAngleScaled - 360;
CLINEA 0000H 0001H 0994H 0004H 002BH
	l	er0,	NEAR _Mag_PIDAngleScaled
	l	er2,	NEAR _Mag_PIDAngleScaled+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#0b4h
	mov	r3,	#0c3h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
CBLOCKEND 237 7 2454

;;		else{
CLINEA 0000H 0001H 0997H 0003H 0007H
	bal	_$L562
_$L560 :
CBLOCK 237 8 2455

;;			Mag_PIDError = Mag_PIDAngleScaled;
CLINEA 0000H 0001H 0998H 0004H 0025H
	l	er0,	NEAR _Mag_PIDAngleScaled
	l	er2,	NEAR _Mag_PIDAngleScaled+02h
CBLOCKEND 237 8 2457

;;		}
CLINEA 0000H 0000H 0999H 0003H 0003H
_$L562 :
	st	er0,	NEAR _Mag_PIDError
	st	er2,	NEAR _Mag_PIDError+02h
CBLOCKEND 237 6 2458

;;	Mag_PIDError *= -1;
CLINEA 0000H 0001H 099BH 0002H 0014H
	push	xr0
	mov	er0,	#0 
	mov	r2,	#080h
	mov	r3,	#0bfh
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_PIDError
	st	er2,	NEAR _Mag_PIDError+02h

;;	Mag_PIDCurrentCount = Mag_PIDCounter * .001;		//Timer in Seconds (.007 used to convert 128Hz TBC to seconds)
CLINEA 0000H 0001H 09A1H 0002H 006DH
	l	er0,	NEAR _Mag_PIDCounter
	mov	er2,	#0 
	push	xr0
	add	sp,	#-4
	bl	__dildu8sw
	mov	r0,	#0fch
	mov	r1,	#0a9h
	mov	r2,	#0f1h
	mov	r3,	#0d2h
	mov	r4,	#04dh
	mov	r5,	#062h
	mov	r6,	#050h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_PIDCurrentCount
	st	er2,	NEAR _Mag_PIDCurrentCount+02h

;;	Mag_PIDCounter = 0;
CLINEA 0000H 0001H 09A2H 0002H 0014H
	mov	er0,	#0 
	st	er0,	NEAR _Mag_PIDCounter

;;	Mag_PIDErrSum += (Mag_PIDError * Mag_PIDCurrentCount);
CLINEA 0000H 0001H 09A5H 0002H 0037H
	l	er0,	NEAR _Mag_PIDCurrentCount
	push	xr0
	l	er0,	NEAR _Mag_PIDError
	l	er2,	NEAR _Mag_PIDError+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	l	er0,	NEAR _Mag_PIDErrSum
	l	er2,	NEAR _Mag_PIDErrSum+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_PIDErrSum
	st	er2,	NEAR _Mag_PIDErrSum+02h

;;	Mag_PIDdErr	/= Mag_PIDCurrentCount;
CLINEA 0000H 0001H 09A9H 0002H 0024H
	l	er0,	NEAR _Mag_PIDError
	l	er2,	NEAR _Mag_PIDError+02h
	push	xr0
	l	er0,	NEAR _Mag_PIDErrPrev
	l	er2,	NEAR _Mag_PIDErrPrev+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	l	er0,	NEAR _Mag_PIDCurrentCount
	l	er2,	NEAR _Mag_PIDCurrentCount+02h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_PIDdErr
	st	er2,	NEAR _Mag_PIDdErr+02h

;;	Mag_PIDErrPrev = Mag_PIDError;
CLINEA 0000H 0001H 09AAH 0002H 001FH
	l	er0,	NEAR _Mag_PIDError
	l	er2,	NEAR _Mag_PIDError+02h
	st	er0,	NEAR _Mag_PIDErrPrev
	st	er2,	NEAR _Mag_PIDErrPrev+02h

;;	Mag_PIDOutput = (Mag_PID_kp*Mag_PIDError) + (Mag_PID_ki*Mag_PIDErrSum) + (Mag_PID_kd*Mag_PIDdErr);
CLINEA 0000H 0001H 09ADH 0002H 0063H
	push	xr0
	l	er0,	NEAR _Mag_PID_kp
	l	er2,	NEAR _Mag_PID_kp+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Mag_PIDErrSum
	l	er6,	NEAR _Mag_PIDErrSum+02h
	push	xr4
	l	er4,	NEAR _Mag_PID_ki
	l	er6,	NEAR _Mag_PID_ki+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Mag_PID_kd
	l	er6,	NEAR _Mag_PID_kd+02h
	push	xr4
	l	er4,	NEAR _Mag_PIDdErr
	l	er6,	NEAR _Mag_PIDdErr+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Mag_PIDOutput
	st	er2,	NEAR _Mag_PIDOutput+02h

;;	PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 09B1H 0002H 001AH
	rb	0f973h.0

;;	PERUN = 0;
CLINEA 0000H 0001H 09B2H 0002H 000BH
	rb	0f937h.0

;;	PDRUN = 0;
CLINEA 0000H 0001H 09B3H 0002H 000BH
	rb	0f927h.0

;;	PCRUN = 0;
CLINEA 0000H 0001H 09B4H 0002H 000BH
	rb	0f917h.0

;;	PWF0D -= Mag_PIDOutput; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 09B6H 0002H 004CH
	l	er0,	0f962h
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Mag_PIDOutput
	l	er2,	NEAR _Mag_PIDOutput+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f962h

;;	PWED += Mag_PIDOutput;	//CCW motor, spin to move CW
CLINEA 0000H 0001H 09B7H 0002H 0034H
	l	er0,	0f932h
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Mag_PIDOutput
	l	er2,	NEAR _Mag_PIDOutput+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f932h

;;	PWDD += Mag_PIDOutput;	//CCW motor, spin to move CW
CLINEA 0000H 0001H 09B8H 0002H 0034H
	l	er0,	0f922h
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Mag_PIDOutput
	l	er2,	NEAR _Mag_PIDOutput+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f922h

;;	PWCD -= Mag_PIDOutput;
CLINEA 0000H 0001H 09B9H 0002H 0017H
	l	er0,	0f912h
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Mag_PIDOutput
	l	er2,	NEAR _Mag_PIDOutput+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f912h

;;	CheckSafetyLimit();
CLINEA 0000H 0001H 09BAH 0002H 0014H
	bl	_CheckSafetyLimit
CBLOCKEND 237 3 2517

;;	PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 09BBH 0002H 0019H
	sb	0f973h.0

;;	PERUN = 1;
CLINEA 0000H 0001H 09BCH 0002H 000BH
	sb	0f937h.0

;;	PDRUN = 1;
CLINEA 0000H 0001H 09BDH 0002H 000BH
	sb	0f927h.0

;;	PCRUN = 1;
CLINEA 0000H 0001H 09BEH 0002H 000BH
	sb	0f917h.0

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 09C2H 0002H 0017H
	mov	er0,	#0 
_$L565 :
CBLOCK 237 9 2499

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 09C4H 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 237 9 2501

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 09C2H 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 09C2H 000EH 0013H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L565

;;	sprintf(SensorReturn, "%f,%f,%f,%f", Mag_Angle, Mag_PIDOutput, Mag_PID_kd, Mag_PID_kp);
CLINEA 0000H 0001H 09C8H 0002H 0058H
	l	er0,	NEAR _Mag_PID_kp
	l	er2,	NEAR _Mag_PID_kp+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Mag_PID_kd
	l	er2,	NEAR _Mag_PID_kd+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Mag_PIDOutput
	l	er2,	NEAR _Mag_PIDOutput+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Mag_Angle
	l	er2,	NEAR _Mag_Angle+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	mov	r0,	#BYTE1 OFFSET $$S569
	mov	r1,	#BYTE2 OFFSET $$S569
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#36

;;	SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 09CAH 0002H 001AH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 09CBH 0002H 001AH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 09CEH 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 09CFH 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 09D0H 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 09D1H 0001H 0001H
	bal	_$L574

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 09D1H 0002H 0019H
_$L572 :
CBLOCK 237 10 2513

;;		NOP1000();
CLINEA 0000H 0001H 09D2H 0003H 000CH
	bl	_NOP1000

;;		main_clrWDT();
CLINEA 0000H 0001H 09D3H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 237 10 2516

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 09D1H 0001H 0001H
_$L574 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 09D1H 000EH 0013H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L572
CBLOCKEND 237 2 2517

;;}
CLINEA 0000H 0001H 09D5H 0001H 0001H
	pop	xr4
	pop	pc
CBLOCKEND 237 1 2517
CFUNCTIONEND 237


	rseg $$AccelSensorControlPID_P$main
CFUNCTION 238

_AccelSensorControlPID_P	:
CBLOCK 238 1 2519

;;void AccelSensorControlPID_P(void){
CLINEA 0000H 0001H 09D7H 0001H 0023H
	push	lr
	push	xr4
CBLOCK 238 2 2519
CRET 0004H
CLOCAL 4BH 0002H 0000H 0002H "i" 02H 00H 01H
CSLOCAL 43H 0004H 0003H 0002H "Accel_PID_XRollOutput" 02H 00H 03H
CSLOCAL 43H 0004H 0004H 0002H "Accel_PID_YPitchOutput" 02H 00H 03H

;;		Accel_PID_XRollError = -CF_XRoll;	//Setpoint - Error (in this case setpoint is 0)
CLINEA 0000H 0001H 09ECH 0003H 0053H
	l	er0,	NEAR _CF_XRoll
	l	er2,	NEAR _CF_XRoll+02h
	push	xr0
	bl	__fnegu8sw
	pop	xr0
	st	er0,	NEAR _Accel_PID_XRollError
	st	er2,	NEAR _Accel_PID_XRollError+02h

;;		testP = Accel_PID_XRollOutput;
CLINEA 0000H 0001H 09F6H 0003H 0020H
	push	xr0
	l	er0,	NEAR _Accel_PID_XRoll_kp
	l	er2,	NEAR _Accel_PID_XRoll_kp+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	push	xr0
	bl	__ftolu8sw
	pop	er4
	add	sp,	#2 
	st	er4,	NEAR _testP

;;		Accel_PID_XRollOutput += (Accel_PID_XRoll_ki*Accel_PID_XRollErrSum);
CLINEA 0000H 0001H 09F7H 0003H 0046H
	l	er4,	NEAR _Accel_PID_XRollErrSum
	l	er6,	NEAR _Accel_PID_XRollErrSum+02h
	push	xr4
	l	er4,	NEAR _Accel_PID_XRoll_ki
	l	er6,	NEAR _Accel_PID_XRoll_ki+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST3
	st	er2,	NEAR _$ST3+02h

;;		Accel_PID_YPitchError = -CF_YPitch;		//Setpoint - Error (in this case setpoint is 0)
CLINEA 0000H 0001H 09FCH 0003H 0056H
	l	er0,	NEAR _CF_YPitch
	l	er2,	NEAR _CF_YPitch+02h
	push	xr0
	bl	__fnegu8sw
	pop	xr0
	st	er0,	NEAR _Accel_PID_YPitchError
	st	er2,	NEAR _Accel_PID_YPitchError+02h

;;		Accel_PID_YPitchOutput = (Accel_PID_YPitch_kp*Accel_PID_YPitchError) + (Accel_PID_YPitch_ki*Accel_PID_YPitchErrSum);
CLINEA 0000H 0001H 0A07H 0003H 0076H
	push	xr0
	l	er0,	NEAR _Accel_PID_YPitch_kp
	l	er2,	NEAR _Accel_PID_YPitch_kp+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Accel_PID_YPitchErrSum
	l	er6,	NEAR _Accel_PID_YPitchErrSum+02h
	push	xr4
	l	er4,	NEAR _Accel_PID_YPitch_ki
	l	er6,	NEAR _Accel_PID_YPitch_ki+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST4
	st	er2,	NEAR _$ST4+02h

;;		if(PrePIDCount >= 10){
CLINEA 0000H 0001H 0A09H 0003H 0018H
	l	r0,	NEAR _PrePIDCount
	cmp	r0,	#0ah
	bge	_$M41
	b	_$L583
_$M41 :
CBLOCK 238 3 2569

;;			if(Accel_PID_XRollError > 0){
CLINEA 0000H 0001H 0A0AH 0004H 0020H
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L578
CBLOCK 238 4 2570

;;				PERUN = 0;
CLINEA 0000H 0001H 0A0CH 0005H 000EH
	rb	0f937h.0

;;				PDRUN = 0;
CLINEA 0000H 0001H 0A0DH 0005H 000EH
	rb	0f927h.0

;;				PWED = PWMIdleDutyRun + Accel_PID_XRollOutput + PWMtoRPMOffset_Mot2;	
CLINEA 0000H 0001H 0A10H 0005H 0049H
	l	er0,	NEAR _PWMIdleDutyRun
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST3
	l	er2,	NEAR _$ST3+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot2
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f932h

;;				PWDD = PWMIdleDutyRun;
CLINEA 0000H 0001H 0A13H 0005H 001AH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f922h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0A14H 0005H 0017H
	bl	_CheckSafetyLimit

;;				PDRUN = 1;
CLINEA 0000H 0001H 0A17H 0005H 000EH
CBLOCKEND 238 4 2585

;;			else{
CLINEA 0000H 0001H 0A1AH 0004H 0008H
	bal	_$L580
_$L578 :
CBLOCK 238 5 2586

;;				PERUN = 0;
CLINEA 0000H 0001H 0A1CH 0005H 000EH
	rb	0f937h.0

;;				PDRUN = 0;
CLINEA 0000H 0001H 0A1DH 0005H 000EH
	rb	0f927h.0

;;				PWED = PWMIdleDutyRun;	
CLINEA 0000H 0001H 0A20H 0005H 001BH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f932h

;;				PWDD = PWMIdleDutyRun - Accel_PID_XRollOutput + PWMtoRPMOffset_Mot4;
CLINEA 0000H 0001H 0A22H 0005H 0048H
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST3
	l	er2,	NEAR _$ST3+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot4
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f922h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0A23H 0005H 0017H
	bl	_CheckSafetyLimit

;;				PDRUN = 1;
CLINEA 0000H 0001H 0A26H 0005H 000EH
CBLOCKEND 238 5 2600

;;			}
CLINEA 0000H 0000H 0A28H 0004H 0004H
_$L580 :
	sb	0f937h.0
	sb	0f927h.0

;;			if(Accel_PID_YPitchError > 0){
CLINEA 0000H 0001H 0A29H 0004H 0021H
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L581
CBLOCK 238 6 2601

;;				PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0A2AH 0005H 001DH
	rb	0f973h.0

;;				PCRUN = 0;
CLINEA 0000H 0001H 0A2DH 0005H 000EH
	rb	0f917h.0

;;				PWF0D = PWMIdleDutyRun + Accel_PID_YPitchOutput; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0A2EH 0005H 0068H
	l	er0,	NEAR _PWMIdleDutyRun
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST4
	l	er2,	NEAR _$ST4+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f962h

;;				PWCD = PWMIdleDutyRun;	
CLINEA 0000H 0001H 0A30H 0005H 001BH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f912h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0A32H 0005H 0017H
	bl	_CheckSafetyLimit

;;				PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0A33H 0005H 001CH
	sb	0f973h.0

;;				PCRUN = 1;
CLINEA 0000H 0001H 0A36H 0005H 000EH
	sb	0f917h.0
CBLOCKEND 238 6 2615

;;			else{
CLINEA 0000H 0001H 0A38H 0004H 0008H
	bal	_$L583
_$L581 :
CBLOCK 238 7 2616

;;				PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0A39H 0005H 001DH
	rb	0f973h.0

;;				PCRUN = 0;
CLINEA 0000H 0001H 0A3CH 0005H 000EH
	rb	0f917h.0

;;				PWF0D = PWMIdleDutyRun; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0A3DH 0005H 004FH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f962h

;;				PWCD = PWMIdleDutyRun - Accel_PID_YPitchOutput + PWMtoRPMOffset_Mot3;	
CLINEA 0000H 0001H 0A3FH 0005H 004AH
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST4
	l	er2,	NEAR _$ST4+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot3
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f912h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0A41H 0005H 0017H
	bl	_CheckSafetyLimit

;;				PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0A42H 0005H 001CH
	sb	0f973h.0

;;				PCRUN = 1;
CLINEA 0000H 0001H 0A45H 0005H 000EH
	sb	0f917h.0
CBLOCKEND 238 7 2630

;;			}
CLINEA 0000H 0000H 0A46H 0004H 0004H
_$L583 :
CBLOCKEND 238 3 2631
CBLOCKEND 238 2 2660

;;}
CLINEA 0000H 0001H 0A64H 0001H 0001H
	pop	xr4
	pop	pc
CBLOCKEND 238 1 2660
CFUNCTIONEND 238


	rseg $$AccelSensorControlPID_I$main
CFUNCTION 239

_AccelSensorControlPID_I	:
CBLOCK 239 1 2662

;;void AccelSensorControlPID_I(void){
CLINEA 0000H 0001H 0A66H 0001H 0023H
	push	lr
	push	xr4
CBLOCK 239 2 2662
CRET 0004H
CLOCAL 4BH 0002H 0000H 0002H "i" 02H 00H 01H
CSLOCAL 43H 0004H 0005H 0002H "Accel_PID_XRollCurrentCount" 02H 00H 03H
CSLOCAL 43H 0004H 0006H 0002H "Accel_PID_XRollOutput" 02H 00H 03H
CSLOCAL 43H 0004H 0007H 0002H "Accel_PID_YPitchCurrentCount" 02H 00H 03H
CSLOCAL 43H 0004H 0008H 0002H "Accel_PID_YPitchOutput" 02H 00H 03H

;;		Accel_PID_XRollCurrentCount = Accel_PID_XRollCounter_I * .001;	//Timer in Seconds
CLINEA 0000H 0001H 0A7BH 0003H 0053H
	l	er0,	NEAR _Accel_PID_XRollCounter_I
	mov	er2,	#0 
	push	xr0
	add	sp,	#-4
	bl	__dildu8sw
	mov	r0,	#0fch
	mov	r1,	#0a9h
	mov	r2,	#0f1h
	mov	r3,	#0d2h
	mov	r4,	#04dh
	mov	r5,	#062h
	mov	r6,	#050h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST5
	st	er2,	NEAR _$ST5+02h

;;		Accel_PID_XRollCounter_I = 0;
CLINEA 0000H 0001H 0A7CH 0003H 001FH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_XRollCounter_I

;;		Accel_PID_XRollErrSum += (Accel_PID_XRollError * Accel_PID_XRollCurrentCount);
CLINEA 0000H 0001H 0A7FH 0003H 0050H
	l	er0,	NEAR _$ST5
	push	xr0
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	l	er0,	NEAR _Accel_PID_XRollErrSum
	l	er2,	NEAR _Accel_PID_XRollErrSum+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_PID_XRollErrSum
	st	er2,	NEAR _Accel_PID_XRollErrSum+02h

;;		testI = (Accel_PID_XRoll_ki*Accel_PID_XRollErrSum);
CLINEA 0000H 0001H 0A83H 0003H 0035H
	push	xr0
	l	er0,	NEAR _Accel_PID_XRoll_ki
	l	er2,	NEAR _Accel_PID_XRoll_ki+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	NEAR _testI

;;		Accel_PID_XRollOutput += testI;
CLINEA 0000H 0001H 0A84H 0003H 0021H
	l	er4,	NEAR _Accel_PID_XRollError
	l	er6,	NEAR _Accel_PID_XRollError+02h
	push	xr4
	l	er4,	NEAR _Accel_PID_XRoll_kp
	l	er6,	NEAR _Accel_PID_XRoll_kp+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	mov	r2,	r1
	extbw	er2
	mov	r2,	r3
	push	xr0
	bl	__fildu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST6
	st	er2,	NEAR _$ST6+02h

;;		Accel_PID_YPitchCurrentCount = Accel_PID_YPitchCounter_I * .001;		//Timer in Seconds
CLINEA 0000H 0001H 0A89H 0003H 0056H
	l	er0,	NEAR _Accel_PID_YPitchCounter_I
	mov	er2,	#0 
	push	xr0
	add	sp,	#-4
	bl	__dildu8sw
	mov	r0,	#0fch
	mov	r1,	#0a9h
	mov	r2,	#0f1h
	mov	r3,	#0d2h
	mov	r4,	#04dh
	mov	r5,	#062h
	mov	r6,	#050h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST7
	st	er2,	NEAR _$ST7+02h

;;		Accel_PID_YPitchCounter_I = 0;
CLINEA 0000H 0001H 0A8AH 0003H 0020H
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_YPitchCounter_I

;;		Accel_PID_YPitchErrSum += (Accel_PID_YPitchError * Accel_PID_YPitchCurrentCount);
CLINEA 0000H 0001H 0A8EH 0003H 0053H
	l	er0,	NEAR _$ST7
	push	xr0
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	l	er0,	NEAR _Accel_PID_YPitchErrSum
	l	er2,	NEAR _Accel_PID_YPitchErrSum+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_PID_YPitchErrSum
	st	er2,	NEAR _Accel_PID_YPitchErrSum+02h

;;		Accel_PID_YPitchOutput = (Accel_PID_YPitch_kp*Accel_PID_YPitchError) + (Accel_PID_YPitch_ki*Accel_PID_YPitchErrSum);
CLINEA 0000H 0001H 0A92H 0003H 0076H
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	push	xr0
	l	er0,	NEAR _Accel_PID_YPitch_kp
	l	er2,	NEAR _Accel_PID_YPitch_kp+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Accel_PID_YPitchErrSum
	l	er6,	NEAR _Accel_PID_YPitchErrSum+02h
	push	xr4
	l	er4,	NEAR _Accel_PID_YPitch_ki
	l	er6,	NEAR _Accel_PID_YPitch_ki+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST8
	st	er2,	NEAR _$ST8+02h

;;		if(PrePIDCount >= 10){
CLINEA 0000H 0001H 0A94H 0003H 0018H
	l	r0,	NEAR _PrePIDCount
	cmp	r0,	#0ah
	bge	_$M43
	b	_$L592
_$M43 :
CBLOCK 239 3 2708

;;			if(Accel_PID_XRollError > 0){
CLINEA 0000H 0001H 0A95H 0004H 0020H
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L587
CBLOCK 239 4 2709

;;				PERUN = 0;
CLINEA 0000H 0001H 0A97H 0005H 000EH
	rb	0f937h.0

;;				PDRUN = 0;
CLINEA 0000H 0001H 0A98H 0005H 000EH
	rb	0f927h.0

;;				PWED = PWMIdleDutyRun + Accel_PID_XRollOutput + PWMtoRPMOffset_Mot2;	
CLINEA 0000H 0001H 0A9BH 0005H 0049H
	l	er0,	NEAR _PWMIdleDutyRun
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST6
	l	er2,	NEAR _$ST6+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot2
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f932h

;;				PWDD = PWMIdleDutyRun;
CLINEA 0000H 0001H 0A9EH 0005H 001AH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f922h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0A9FH 0005H 0017H
	bl	_CheckSafetyLimit

;;				PDRUN = 1;
CLINEA 0000H 0001H 0AA2H 0005H 000EH
CBLOCKEND 239 4 2724

;;			else{
CLINEA 0000H 0001H 0AA5H 0004H 0008H
	bal	_$L589
_$L587 :
CBLOCK 239 5 2725

;;				PERUN = 0;
CLINEA 0000H 0001H 0AA7H 0005H 000EH
	rb	0f937h.0

;;				PDRUN = 0;
CLINEA 0000H 0001H 0AA8H 0005H 000EH
	rb	0f927h.0

;;				PWED = PWMIdleDutyRun;	
CLINEA 0000H 0001H 0AABH 0005H 001BH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f932h

;;				PWDD = PWMIdleDutyRun - Accel_PID_XRollOutput + PWMtoRPMOffset_Mot4;
CLINEA 0000H 0001H 0AADH 0005H 0048H
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST6
	l	er2,	NEAR _$ST6+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot4
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f922h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0AAEH 0005H 0017H
	bl	_CheckSafetyLimit

;;				PDRUN = 1;
CLINEA 0000H 0001H 0AB1H 0005H 000EH
CBLOCKEND 239 5 2739

;;			}
CLINEA 0000H 0000H 0AB3H 0004H 0004H
_$L589 :
	sb	0f937h.0
	sb	0f927h.0

;;			if(Accel_PID_YPitchError > 0){
CLINEA 0000H 0001H 0AB4H 0004H 0021H
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L590
CBLOCK 239 6 2740

;;				PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0AB5H 0005H 001DH
	rb	0f973h.0

;;				PCRUN = 0;
CLINEA 0000H 0001H 0AB8H 0005H 000EH
	rb	0f917h.0

;;				PWF0D = PWMIdleDutyRun + Accel_PID_YPitchOutput; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0AB9H 0005H 0068H
	l	er0,	NEAR _PWMIdleDutyRun
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST8
	l	er2,	NEAR _$ST8+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f962h

;;				PWCD = PWMIdleDutyRun;	
CLINEA 0000H 0001H 0ABBH 0005H 001BH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f912h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0ABDH 0005H 0017H
	bl	_CheckSafetyLimit

;;				PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0ABEH 0005H 001CH
	sb	0f973h.0

;;				PCRUN = 1;
CLINEA 0000H 0001H 0AC1H 0005H 000EH
	sb	0f917h.0
CBLOCKEND 239 6 2754

;;			else{
CLINEA 0000H 0001H 0AC3H 0004H 0008H
	bal	_$L592
_$L590 :
CBLOCK 239 7 2755

;;				PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0AC4H 0005H 001DH
	rb	0f973h.0

;;				PCRUN = 0;
CLINEA 0000H 0001H 0AC7H 0005H 000EH
	rb	0f917h.0

;;				PWF0D = PWMIdleDutyRun; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0AC8H 0005H 004FH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f962h

;;				PWCD = PWMIdleDutyRun - Accel_PID_YPitchOutput + PWMtoRPMOffset_Mot3;	
CLINEA 0000H 0001H 0ACAH 0005H 004AH
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST8
	l	er2,	NEAR _$ST8+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot3
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f912h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0ACCH 0005H 0017H
	bl	_CheckSafetyLimit

;;				PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0ACDH 0005H 001CH
	sb	0f973h.0

;;				PCRUN = 1;
CLINEA 0000H 0001H 0AD0H 0005H 000EH
	sb	0f917h.0
CBLOCKEND 239 7 2769

;;			}
CLINEA 0000H 0000H 0AD1H 0004H 0004H
_$L592 :
CBLOCKEND 239 3 2770
CBLOCKEND 239 2 2799

;;}
CLINEA 0000H 0001H 0AEFH 0001H 0001H
	pop	xr4
	pop	pc
CBLOCKEND 239 1 2799
CFUNCTIONEND 239


	rseg $$AccelSensorControlPID_D$main
CFUNCTION 240

_AccelSensorControlPID_D	:
CBLOCK 240 1 2801

;;void AccelSensorControlPID_D(void){
CLINEA 0000H 0001H 0AF1H 0001H 0023H
	push	lr
	push	xr8
	push	xr4
CBLOCK 240 2 2801
CRET 0008H
CLOCAL 4BH 0002H 0000H 0002H "i" 02H 00H 01H
CSLOCAL 43H 0004H 0009H 0002H "Accel_PID_XRollCurrentCount" 02H 00H 03H
CSLOCAL 43H 0004H 000AH 0002H "Accel_PID_XRollOutput" 02H 00H 03H
CSLOCAL 43H 0004H 000BH 0002H "Accel_PID_YPitchCurrentCount" 02H 00H 03H
CSLOCAL 43H 0004H 000CH 0002H "Accel_PID_YPitchOutput" 02H 00H 03H

;;		Accel_PID_XRollCurrentCount = Accel_PID_XRollCounter_D * .001;	//Timer in Seconds
CLINEA 0000H 0001H 0B07H 0003H 0053H
	l	er0,	NEAR _Accel_PID_XRollCounter_D
	mov	er2,	#0 
	push	xr0
	add	sp,	#-4
	bl	__dildu8sw
	mov	r0,	#0fch
	mov	r1,	#0a9h
	mov	r2,	#0f1h
	mov	r3,	#0d2h
	mov	r4,	#04dh
	mov	r5,	#062h
	mov	r6,	#050h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST9
	st	er2,	NEAR _$ST9+02h

;;		Accel_PID_XRollCounter_D = 0;
CLINEA 0000H 0001H 0B08H 0003H 001FH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_XRollCounter_D

;;		Accel_PID_XRolldErr	/= Accel_PID_XRollCurrentCount;
CLINEA 0000H 0001H 0B0CH 0003H 0035H
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	push	xr0
	l	er0,	NEAR _Accel_PID_XRollErrPrev
	l	er2,	NEAR _Accel_PID_XRollErrPrev+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	l	er0,	NEAR _$ST9
	l	er2,	NEAR _$ST9+02h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_PID_XRolldErr
	st	er2,	NEAR _Accel_PID_XRolldErr+02h

;;		if( Accel_PID_XRollError<0)
CLINEA 0000H 0001H 0B0EH 0003H 001DH
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L596
CBLOCK 240 3 2831

;;			if(Accel_PID_XRollErrPrev>=0)
CLINEA 0000H 0001H 0B10H 0004H 0020H
	l	er0,	NEAR _Accel_PID_XRollErrPrev
	l	er2,	NEAR _Accel_PID_XRollErrPrev+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$L596
CBLOCK 240 4 2833

;;				Accel_PID_XRollErrSum = 0;
CLINEA 0000H 0001H 0B12H 0005H 001EH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_XRollErrSum
	st	er0,	NEAR _Accel_PID_XRollErrSum+02h
CBLOCKEND 240 4 2835

;;			}
CLINEA 0000H 0000H 0B13H 0004H 0004H
_$L596 :
CBLOCKEND 240 3 2836

;;		if( Accel_PID_XRollError>=0)
CLINEA 0000H 0001H 0B16H 0003H 001EH
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$L600
CBLOCK 240 5 2839

;;			if(Accel_PID_XRollErrPrev<0)
CLINEA 0000H 0001H 0B18H 0004H 001FH
	l	er0,	NEAR _Accel_PID_XRollErrPrev
	l	er2,	NEAR _Accel_PID_XRollErrPrev+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L600
CBLOCK 240 6 2841

;;				Accel_PID_XRollErrSum = 0;
CLINEA 0000H 0001H 0B1AH 0005H 001EH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_XRollErrSum
	st	er0,	NEAR _Accel_PID_XRollErrSum+02h
CBLOCKEND 240 6 2843

;;			}
CLINEA 0000H 0000H 0B1BH 0004H 0004H
_$L600 :
CBLOCKEND 240 5 2844

;;		Accel_PID_XRollErrPrev = Accel_PID_XRollError;
CLINEA 0000H 0001H 0B1EH 0003H 0030H
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	st	er0,	NEAR _Accel_PID_XRollErrPrev
	st	er2,	NEAR _Accel_PID_XRollErrPrev+02h

;;		testD = (Accel_PID_XRoll_kd*Accel_PID_XRolldErr);
CLINEA 0000H 0001H 0B2BH 0003H 0033H
	l	er0,	NEAR _Accel_PID_XRoll_kd
	l	er2,	NEAR _Accel_PID_XRoll_kd+02h
	push	xr0
	l	er0,	NEAR _Accel_PID_XRolldErr
	l	er2,	NEAR _Accel_PID_XRolldErr+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er8
	add	sp,	#2 
	st	er8,	NEAR _testD

;;		Accel_PID_XRollOutput += testD;
CLINEA 0000H 0001H 0B2DH 0003H 0021H
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	push	xr0
	l	er0,	NEAR _Accel_PID_XRoll_kp
	l	er2,	NEAR _Accel_PID_XRoll_kp+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Accel_PID_XRollErrSum
	l	er6,	NEAR _Accel_PID_XRollErrSum+02h
	push	xr4
	l	er4,	NEAR _Accel_PID_XRoll_ki
	l	er6,	NEAR _Accel_PID_XRoll_ki+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr4
	mov	r2,	r9
	extbw	er2
	mov	r2,	r3
	mov	er10,	er2
	push	xr8
	bl	__fildu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST10
	st	er2,	NEAR _$ST10+02h

;;		Accel_PID_YPitchCurrentCount = Accel_PID_YPitchCounter_D * .001;		//Timer in Seconds
CLINEA 0000H 0001H 0B31H 0003H 0056H
	l	er0,	NEAR _Accel_PID_YPitchCounter_D
	mov	er2,	#0 
	push	xr0
	add	sp,	#-4
	bl	__dildu8sw
	mov	r0,	#0fch
	mov	r1,	#0a9h
	mov	r2,	#0f1h
	mov	r3,	#0d2h
	mov	r4,	#04dh
	mov	r5,	#062h
	mov	r6,	#050h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST11
	st	er2,	NEAR _$ST11+02h

;;		Accel_PID_YPitchCounter_D = 0;
CLINEA 0000H 0001H 0B32H 0003H 0020H
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_YPitchCounter_D

;;		Accel_PID_YPitchdErr /= Accel_PID_YPitchCurrentCount;
CLINEA 0000H 0001H 0B37H 0003H 0037H
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	push	xr0
	l	er0,	NEAR _Accel_PID_YPitchErrPrev
	l	er2,	NEAR _Accel_PID_YPitchErrPrev+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	l	er0,	NEAR _$ST11
	l	er2,	NEAR _$ST11+02h
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Accel_PID_YPitchdErr
	st	er2,	NEAR _Accel_PID_YPitchdErr+02h

;;		if( Accel_PID_YPitchError<0)
CLINEA 0000H 0001H 0B39H 0003H 001EH
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L604
CBLOCK 240 7 2874

;;			if(Accel_PID_YPitchErrPrev>=0) 
CLINEA 0000H 0001H 0B3BH 0004H 0022H
	l	er0,	NEAR _Accel_PID_YPitchErrPrev
	l	er2,	NEAR _Accel_PID_YPitchErrPrev+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$L604
CBLOCK 240 8 2876

;;				Accel_PID_YPitchErrSum = 0;
CLINEA 0000H 0001H 0B3DH 0005H 001FH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_YPitchErrSum
	st	er0,	NEAR _Accel_PID_YPitchErrSum+02h
CBLOCKEND 240 8 2878

;;			}
CLINEA 0000H 0000H 0B3EH 0004H 0004H
_$L604 :
CBLOCKEND 240 7 2879

;;		if( Accel_PID_YPitchError>=0)
CLINEA 0000H 0001H 0B40H 0003H 001FH
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$L608
CBLOCK 240 9 2881

;;			if(Accel_PID_YPitchErrPrev<0)
CLINEA 0000H 0001H 0B42H 0004H 0020H
	l	er0,	NEAR _Accel_PID_YPitchErrPrev
	l	er2,	NEAR _Accel_PID_YPitchErrPrev+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L608
CBLOCK 240 10 2883

;;				Accel_PID_YPitchErrSum = 0;
CLINEA 0000H 0001H 0B44H 0005H 001FH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_YPitchErrSum
	st	er0,	NEAR _Accel_PID_YPitchErrSum+02h
CBLOCKEND 240 10 2885

;;			}
CLINEA 0000H 0000H 0B45H 0004H 0004H
_$L608 :
CBLOCKEND 240 9 2886

;;		Accel_PID_YPitchErrPrev = Accel_PID_YPitchError;
CLINEA 0000H 0001H 0B48H 0003H 0032H
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	st	er0,	NEAR _Accel_PID_YPitchErrPrev
	st	er2,	NEAR _Accel_PID_YPitchErrPrev+02h

;;		Accel_PID_YPitchOutput = (Accel_PID_YPitch_kp*Accel_PID_YPitchError) + (Accel_PID_YPitch_ki*Accel_PID_YPitchErrSum) + (Accel_PID_YPitch_kd*Accel_PID_YPitchdErr);
CLINEA 0000H 0001H 0B53H 0003H 00A3H
	push	xr0
	l	er0,	NEAR _Accel_PID_YPitch_kp
	l	er2,	NEAR _Accel_PID_YPitch_kp+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Accel_PID_YPitchErrSum
	l	er6,	NEAR _Accel_PID_YPitchErrSum+02h
	push	xr4
	l	er4,	NEAR _Accel_PID_YPitch_ki
	l	er6,	NEAR _Accel_PID_YPitch_ki+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Accel_PID_YPitch_kd
	l	er6,	NEAR _Accel_PID_YPitch_kd+02h
	push	xr4
	l	er4,	NEAR _Accel_PID_YPitchdErr
	l	er6,	NEAR _Accel_PID_YPitchdErr+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _$ST12
	st	er2,	NEAR _$ST12+02h

;;		if(PrePIDCount >= 10){
CLINEA 0000H 0001H 0B55H 0003H 0018H
	l	r0,	NEAR _PrePIDCount
	cmp	r0,	#0ah
	bge	_$M45
	b	_$L617
_$M45 :
CBLOCK 240 11 2901

;;			if(Accel_PID_XRollError > 0){
CLINEA 0000H 0001H 0B56H 0004H 0020H
	l	er0,	NEAR _Accel_PID_XRollError
	l	er2,	NEAR _Accel_PID_XRollError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L612
CBLOCK 240 12 2902

;;				PERUN = 0;
CLINEA 0000H 0001H 0B58H 0005H 000EH
	rb	0f937h.0

;;				PDRUN = 0;
CLINEA 0000H 0001H 0B59H 0005H 000EH
	rb	0f927h.0

;;				PWED = PWMIdleDutyRun + Accel_PID_XRollOutput + PWMtoRPMOffset_Mot2;	
CLINEA 0000H 0001H 0B5CH 0005H 0049H
	l	er0,	NEAR _PWMIdleDutyRun
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST10
	l	er2,	NEAR _$ST10+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot2
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f932h

;;				PWDD = PWMIdleDutyRun;
CLINEA 0000H 0001H 0B5FH 0005H 001AH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f922h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0B60H 0005H 0017H
	bl	_CheckSafetyLimit

;;				PDRUN = 1;
CLINEA 0000H 0001H 0B63H 0005H 000EH
CBLOCKEND 240 12 2917

;;			else{
CLINEA 0000H 0001H 0B66H 0004H 0008H
	bal	_$L614
_$L612 :
CBLOCK 240 13 2918

;;				PERUN = 0;
CLINEA 0000H 0001H 0B68H 0005H 000EH
	rb	0f937h.0

;;				PDRUN = 0;
CLINEA 0000H 0001H 0B69H 0005H 000EH
	rb	0f927h.0

;;				PWED = PWMIdleDutyRun;	
CLINEA 0000H 0001H 0B6CH 0005H 001BH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f932h

;;				PWDD = PWMIdleDutyRun - Accel_PID_XRollOutput + PWMtoRPMOffset_Mot4;
CLINEA 0000H 0001H 0B6EH 0005H 0048H
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST10
	l	er2,	NEAR _$ST10+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot4
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f922h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0B6FH 0005H 0017H
	bl	_CheckSafetyLimit

;;				PDRUN = 1;
CLINEA 0000H 0001H 0B72H 0005H 000EH
CBLOCKEND 240 13 2932

;;			}
CLINEA 0000H 0000H 0B74H 0004H 0004H
_$L614 :
	sb	0f937h.0
	sb	0f927h.0

;;			if(Accel_PID_YPitchError > 0){
CLINEA 0000H 0001H 0B75H 0004H 0021H
	l	er0,	NEAR _Accel_PID_YPitchError
	l	er2,	NEAR _Accel_PID_YPitchError+02h
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L615
CBLOCK 240 14 2933

;;				PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0B76H 0005H 001DH
	rb	0f973h.0

;;				PCRUN = 0;
CLINEA 0000H 0001H 0B79H 0005H 000EH
	rb	0f917h.0

;;				PWF0D = PWMIdleDutyRun + Accel_PID_YPitchOutput; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0B7AH 0005H 0068H
	l	er0,	NEAR _PWMIdleDutyRun
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST12
	l	er2,	NEAR _$ST12+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f962h

;;				PWCD = PWMIdleDutyRun;	
CLINEA 0000H 0001H 0B7CH 0005H 001BH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f912h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0B7EH 0005H 0017H
	bl	_CheckSafetyLimit

;;				PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0B7FH 0005H 001CH
	sb	0f973h.0

;;				PCRUN = 1;
CLINEA 0000H 0001H 0B82H 0005H 000EH
	sb	0f917h.0
CBLOCKEND 240 14 2947

;;			else{
CLINEA 0000H 0001H 0B84H 0004H 0008H
	bal	_$L617
_$L615 :
CBLOCK 240 15 2948

;;				PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0B85H 0005H 001DH
	rb	0f973h.0

;;				PCRUN = 0;
CLINEA 0000H 0001H 0B88H 0005H 000EH
	rb	0f917h.0

;;				PWF0D = PWMIdleDutyRun; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0B89H 0005H 004FH
	l	er0,	NEAR _PWMIdleDutyRun
	st	er0,	0f962h

;;				PWCD = PWMIdleDutyRun - Accel_PID_YPitchOutput + PWMtoRPMOffset_Mot3;	
CLINEA 0000H 0001H 0B8BH 0005H 004AH
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _$ST12
	l	er2,	NEAR _$ST12+02h
	push	xr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr4
	l	er0,	NEAR _PWMtoRPMOffset_Mot3
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	push	qr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f912h

;;				CheckSafetyLimit();
CLINEA 0000H 0001H 0B8DH 0005H 0017H
	bl	_CheckSafetyLimit

;;				PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0B8EH 0005H 001CH
	sb	0f973h.0

;;				PCRUN = 1;
CLINEA 0000H 0001H 0B91H 0005H 000EH
	sb	0f917h.0
CBLOCKEND 240 15 2962

;;			}
CLINEA 0000H 0000H 0B92H 0004H 0004H
_$L617 :
CBLOCKEND 240 11 2963
CBLOCKEND 240 2 2993

;;}
CLINEA 0000H 0001H 0BB1H 0001H 0001H
	pop	xr4
	pop	xr8
	pop	pc
CBLOCKEND 240 1 2993
CFUNCTIONEND 240


	rseg $$RangeSensorControlPID$main
CFUNCTION 241

_RangeSensorControlPID	:
CBLOCK 241 1 2994

;;void RangeSensorControlPID(void){
CLINEA 0000H 0001H 0BB2H 0001H 0021H
	push	lr
	push	xr8
	push	xr4
CBLOCK 241 2 2994
CRET 0008H
CLOCAL 47H 0002H 0024H 0002H "i" 02H 00H 01H

;;	Range_PIDError = Range_PIDSetpoint - Range_out;
CLINEA 0000H 0001H 0BB7H 0002H 0030H
	l	er0,	NEAR _Range_out
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	pop	xr0
	l	er4,	NEAR _Range_PIDSetpoint
	l	er6,	NEAR _Range_PIDSetpoint+02h
	push	qr0
	bl	__fsubu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Range_PIDError
	st	er2,	NEAR _Range_PIDError+02h

;;	Range_PIDCurrentCount = Range_PIDCounter * .007;		//Timer in Seconds (.007 used to convert 128Hz TBC to seconds)
CLINEA 0000H 0001H 0BBAH 0002H 0071H
	l	er4,	NEAR _Range_PIDCounter
	mov	er6,	#0 
	push	xr4
	add	sp,	#-4
	bl	__dildu8sw
	mov	r4,	#079h
	mov	r5,	#0e9h
	mov	r6,	#026h
	mov	r7,	#031h
	mov	r8,	#08h
	mov	r9,	#0ach
	mov	r10,	#07ch
	mov	r11,	#03fh
	push	xr8
	push	xr4
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr4
	st	er4,	NEAR _Range_PIDCurrentCount
	st	er6,	NEAR _Range_PIDCurrentCount+02h

;;	Range_PIDCounter = 0;
CLINEA 0000H 0001H 0BBBH 0002H 0016H
	mov	er4,	#0 
	st	er4,	NEAR _Range_PIDCounter

;;	Range_PIDErrSum += (Range_PIDError * Range_PIDCurrentCount);
CLINEA 0000H 0001H 0BBEH 0002H 003DH
	push	xr0
	l	er4,	NEAR _Range_PIDCurrentCount
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	l	er4,	NEAR _Range_PIDErrSum
	l	er6,	NEAR _Range_PIDErrSum+02h
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr4
	st	er4,	NEAR _Range_PIDErrSum
	st	er6,	NEAR _Range_PIDErrSum+02h

;;	Range_PIDdErr	/= Range_PIDCurrentCount;
CLINEA 0000H 0001H 0BC2H 0002H 0028H
	push	xr0
	l	er4,	NEAR _Range_PIDErrPrev
	l	er6,	NEAR _Range_PIDErrPrev+02h
	push	xr4
	bl	__fsubu8sw
	add	sp,	#4 
	l	er4,	NEAR _Range_PIDCurrentCount
	l	er6,	NEAR _Range_PIDCurrentCount+02h
	push	xr4
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr4
	st	er4,	NEAR _Range_PIDdErr
	st	er6,	NEAR _Range_PIDdErr+02h

;;	Range_PIDErrPrev = Range_PIDError;
CLINEA 0000H 0001H 0BC3H 0002H 0023H
	st	er0,	NEAR _Range_PIDErrPrev
	st	er2,	NEAR _Range_PIDErrPrev+02h

;;	Range_PIDOutput = (Range_PID_kp*Range_PIDError) + (Range_PID_ki*Range_PIDErrSum) + (Range_PID_kd*Range_PIDdErr);
CLINEA 0000H 0001H 0BC6H 0002H 0071H
	push	xr0
	l	er0,	NEAR _Range_PID_kp
	l	er2,	NEAR _Range_PID_kp+02h
	push	xr0
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Range_PIDErrSum
	l	er6,	NEAR _Range_PIDErrSum+02h
	push	xr4
	l	er4,	NEAR _Range_PID_ki
	l	er6,	NEAR _Range_PID_ki+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	l	er4,	NEAR _Range_PID_kd
	l	er6,	NEAR _Range_PID_kd+02h
	push	xr4
	l	er4,	NEAR _Range_PIDdErr
	l	er6,	NEAR _Range_PIDdErr+02h
	push	xr4
	bl	__fmulu8sw
	add	sp,	#4 
	pop	xr4
	push	xr0
	push	xr4
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _Range_PIDOutput
	st	er2,	NEAR _Range_PIDOutput+02h

;;	PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0BCAH 0002H 001AH
	rb	0f973h.0

;;	PERUN = 0;
CLINEA 0000H 0001H 0BCBH 0002H 000BH
	rb	0f937h.0

;;	PDRUN = 0;
CLINEA 0000H 0001H 0BCCH 0002H 000BH
	rb	0f927h.0

;;	PCRUN = 0;
CLINEA 0000H 0001H 0BCDH 0002H 000BH
	rb	0f917h.0

;;	PWF0D += Range_PIDOutput; 		//Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0BCEH 0002H 004EH
	l	er0,	0f962h
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Range_PIDOutput
	l	er2,	NEAR _Range_PIDOutput+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f962h

;;	PWED += Range_PIDOutput;	
CLINEA 0000H 0001H 0BCFH 0002H 001AH
	l	er0,	0f932h
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Range_PIDOutput
	l	er2,	NEAR _Range_PIDOutput+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f932h

;;	PWDD += Range_PIDOutput;	
CLINEA 0000H 0001H 0BD0H 0002H 001AH
	l	er0,	0f922h
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Range_PIDOutput
	l	er2,	NEAR _Range_PIDOutput+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f922h

;;	PWCD += Range_PIDOutput;
CLINEA 0000H 0001H 0BD1H 0002H 0019H
	l	er0,	0f912h
	mov	er2,	#0 
	push	xr0
	bl	__fuldu8sw
	l	er0,	NEAR _Range_PIDOutput
	l	er2,	NEAR _Range_PIDOutput+02h
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	bl	__ftolu8sw
	pop	er0
	add	sp,	#2 
	st	er0,	0f912h

;;	CheckSafetyLimit();
CLINEA 0000H 0001H 0BD2H 0002H 0014H
	bl	_CheckSafetyLimit

;;	PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0BD3H 0002H 0019H
	sb	0f973h.0

;;	PERUN = 1;
CLINEA 0000H 0001H 0BD4H 0002H 000BH
	sb	0f937h.0

;;	PDRUN = 1;
CLINEA 0000H 0001H 0BD5H 0002H 000BH
	sb	0f927h.0

;;	PCRUN = 1;
CLINEA 0000H 0001H 0BD6H 0002H 000BH
	sb	0f917h.0

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0001H 0BD8H 0002H 0017H
	mov	er0,	#0 
_$L621 :
CBLOCK 241 3 3033

;;		SensorReturn[i] = 0x20;
CLINEA 0000H 0001H 0BDAH 0003H 0019H
	mov	r2,	#020h
	st	r2,	NEAR _SensorReturn[er0]
CBLOCKEND 241 3 3035

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0BD8H 0002H 0017H
	add	er0,	#1 

;;	for(i = 0; i<150; i++)
CLINEA 0000H 0000H 0BD8H 000EH 0013H
	cmp	r0,	#096h
	cmpc	r1,	#00h
	blts	_$L621

;;	sprintf(SensorReturn, "%f,%f,%f", Range_out, Range_PIDCurrentCount,Range_PIDOutput);
CLINEA 0000H 0001H 0BDEH 0002H 0055H
	l	er0,	NEAR _Range_PIDOutput
	l	er2,	NEAR _Range_PIDOutput+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Range_PIDCurrentCount
	l	er2,	NEAR _Range_PIDCurrentCount+02h
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	l	er0,	NEAR _Range_out
	push	er0
	mov	r0,	#BYTE1 OFFSET $$S256
	mov	r1,	#BYTE2 OFFSET $$S256
	push	er0
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	push	er0
	bl	_sprintf_nn
	add	sp,	#22

;;	SensorReturn[148] = 0x0D;
CLINEA 0000H 0001H 0BE0H 0002H 001AH
	mov	r0,	#0dh
	st	r0,	NEAR _SensorReturn+094h

;;	SensorReturn[149] = 0x0A;
CLINEA 0000H 0001H 0BE1H 0002H 001AH
	mov	r0,	#0ah
	st	r0,	NEAR _SensorReturn+095h

;;	_flgUartFin = 0;
CLINEA 0000H 0001H 0BE4H 0002H 0011H
	mov	r0,	#00h
	st	r0,	NEAR __flgUartFin

;;	uart_stop();
CLINEA 0000H 0001H 0BE5H 0002H 000DH
	bl	_uart_stop

;;	uart_startSend(SensorReturn, 150, _funcUartFin);
CLINEA 0000H 0001H 0BE6H 0002H 0031H
	mov	r0,	#BYTE1 OFFSET __funcUartFin
	mov	r1,	#BYTE2 OFFSET __funcUartFin
	push	er0
	mov	r2,	#096h
	mov	r3,	#00h
	mov	r0,	#BYTE1 OFFSET _SensorReturn
	mov	r1,	#BYTE2 OFFSET _SensorReturn
	bl	_uart_startSend
	add	sp,	#2 

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0BE7H 0001H 0001H
	bal	_$L629

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0BE7H 0002H 0019H
_$L627 :
CBLOCK 241 4 3047

;;		main_clrWDT();
CLINEA 0000H 0001H 0BE8H 0003H 0010H
	bl	_main_clrWDT
CBLOCKEND 241 4 3049

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0BE7H 0001H 0001H
_$L629 :

;;	while(_flgUartFin != 1){
CLINEA 0000H 0000H 0BE7H 000EH 0013H
	l	r0,	NEAR __flgUartFin
	cmp	r0,	#01h
	bne	_$L627
CBLOCKEND 241 2 3051

;;}
CLINEA 0000H 0001H 0BEBH 0001H 0001H
	pop	xr4
	pop	xr8
	pop	pc
CBLOCKEND 241 1 3051
CFUNCTIONEND 241


	rseg $$CheckSafetyLimit$main
CFUNCTION 242

_CheckSafetyLimit	:
CBLOCK 242 1 3053

;;void CheckSafetyLimit(void){	
CLINEA 0000H 0001H 0BEDH 0001H 001DH
CBLOCK 242 2 3053

;;	if(PWED > PWMUpperDutyLimitRun){
CLINEA 0000H 0001H 0BEFH 0002H 0021H
	l	er0,	0f932h
	l	er2,	NEAR _PWMUpperDutyLimitRun
	cmp	er0,	er2
	ble	_$L631
CBLOCK 242 3 3055

;;		PWED = PWMUpperDutyLimitRun;
CLINEA 0000H 0001H 0BF0H 0003H 001EH
	st	er2,	0f932h
CBLOCKEND 242 3 3057

;;	}
CLINEA 0000H 0000H 0BF1H 0002H 0002H
_$L631 :

;;	if(PWED < PWMLowerDutyLimitRun){
CLINEA 0000H 0001H 0BF2H 0002H 0021H
	l	er0,	0f932h
	l	er2,	NEAR _PWMLowerDutyLimitRun
	cmp	er0,	er2
	bge	_$L633
CBLOCK 242 4 3058

;;		PWED = PWMLowerDutyLimitRun;
CLINEA 0000H 0001H 0BF3H 0003H 001EH
	st	er2,	0f932h
CBLOCKEND 242 4 3060

;;	}
CLINEA 0000H 0000H 0BF4H 0002H 0002H
_$L633 :

;;	if(PWF0D > PWMUpperDutyLimitRun){
CLINEA 0000H 0001H 0BF5H 0002H 0022H
	l	er0,	0f962h
	l	er2,	NEAR _PWMUpperDutyLimitRun
	cmp	er0,	er2
	ble	_$L635
CBLOCK 242 5 3061

;;		PWF0D = PWMUpperDutyLimitRun;
CLINEA 0000H 0001H 0BF6H 0003H 001FH
	st	er2,	0f962h
CBLOCKEND 242 5 3063

;;	}
CLINEA 0000H 0000H 0BF7H 0002H 0002H
_$L635 :

;;	if(PWF0D < PWMLowerDutyLimitRun){
CLINEA 0000H 0001H 0BF8H 0002H 0022H
	l	er0,	0f962h
	l	er2,	NEAR _PWMLowerDutyLimitRun
	cmp	er0,	er2
	bge	_$L637
CBLOCK 242 6 3064

;;		PWF0D = PWMLowerDutyLimitRun;
CLINEA 0000H 0001H 0BF9H 0003H 001FH
	st	er2,	0f962h
CBLOCKEND 242 6 3066

;;	}
CLINEA 0000H 0000H 0BFAH 0002H 0002H
_$L637 :

;;	if(PWDD > PWMUpperDutyLimitRun){
CLINEA 0000H 0001H 0BFBH 0002H 0021H
	l	er0,	0f922h
	l	er2,	NEAR _PWMUpperDutyLimitRun
	cmp	er0,	er2
	ble	_$L639
CBLOCK 242 7 3067

;;		PWDD = PWMUpperDutyLimitRun;
CLINEA 0000H 0001H 0BFCH 0003H 001EH
	st	er2,	0f922h
CBLOCKEND 242 7 3069

;;	}
CLINEA 0000H 0000H 0BFDH 0002H 0002H
_$L639 :

;;	if(PWDD < PWMLowerDutyLimitRun){
CLINEA 0000H 0001H 0BFEH 0002H 0021H
	l	er0,	0f922h
	l	er2,	NEAR _PWMLowerDutyLimitRun
	cmp	er0,	er2
	bge	_$L641
CBLOCK 242 8 3070

;;		PWDD = PWMLowerDutyLimitRun;
CLINEA 0000H 0001H 0BFFH 0003H 001EH
	st	er2,	0f922h
CBLOCKEND 242 8 3072

;;	}
CLINEA 0000H 0000H 0C00H 0002H 0002H
_$L641 :

;;	if(PWCD > PWMUpperDutyLimitRun){
CLINEA 0000H 0001H 0C01H 0002H 0021H
	l	er0,	0f912h
	l	er2,	NEAR _PWMUpperDutyLimitRun
	cmp	er0,	er2
	ble	_$L643
CBLOCK 242 9 3073

;;		PWCD = PWMUpperDutyLimitRun;
CLINEA 0000H 0001H 0C02H 0003H 001EH
	st	er2,	0f912h
CBLOCKEND 242 9 3075

;;	}
CLINEA 0000H 0000H 0C03H 0002H 0002H
_$L643 :

;;	if(PWCD < PWMLowerDutyLimitRun){
CLINEA 0000H 0001H 0C04H 0002H 0021H
	l	er0,	0f912h
	l	er2,	NEAR _PWMLowerDutyLimitRun
	cmp	er0,	er2
	bge	_$L645
CBLOCK 242 10 3076

;;		PWCD = PWMLowerDutyLimitRun;
CLINEA 0000H 0001H 0C05H 0003H 001EH
	st	er2,	0f912h
CBLOCKEND 242 10 3078

;;	}
CLINEA 0000H 0000H 0C06H 0002H 0002H
_$L645 :
CBLOCKEND 242 2 3079

;;}
CLINEA 0000H 0001H 0C07H 0001H 0001H
	rt
CBLOCKEND 242 1 3079
CFUNCTIONEND 242


	rseg $$CheckSafetyLimitUnscaled$main
CFUNCTION 243

_CheckSafetyLimitUnscaled	:
CBLOCK 243 1 3081

;;void CheckSafetyLimitUnscaled(void){	
CLINEA 0000H 0001H 0C09H 0001H 0025H
CBLOCK 243 2 3081

;;	if(Accel_PID_Motor1 > (49151)){
CLINEA 0000H 0001H 0C0BH 0002H 0020H
	l	er0,	NEAR _Accel_PID_Motor1
	mov	er2,	#0 
	cmp	r0,	#0ffh
	cmpc	r1,	#0bfh
	cmpc	r2,	#00h
	cmpc	r3,	#00h
	bles	_$L648
CBLOCK 243 3 3083

;;		Accel_PID_Motor1 = 49151;
CLINEA 0000H 0001H 0C0CH 0003H 001BH
	mov	r0,	#0ffh
	mov	r1,	#0bfh
	st	er0,	NEAR _Accel_PID_Motor1
CBLOCKEND 243 3 3085

;;	}
CLINEA 0000H 0000H 0C0DH 0002H 0002H
_$L648 :

;;	if(Accel_PID_Motor1 < 16383){
CLINEA 0000H 0001H 0C0EH 0002H 001EH
	l	er0,	NEAR _Accel_PID_Motor1
	cmp	r0,	#0ffh
	cmpc	r1,	#03fh
	bge	_$L650
CBLOCK 243 4 3086

;;		Accel_PID_Motor1 = 16383;
CLINEA 0000H 0001H 0C0FH 0003H 001BH
	mov	r0,	#0ffh
	mov	r1,	#03fh
	st	er0,	NEAR _Accel_PID_Motor1
CBLOCKEND 243 4 3088

;;	}
CLINEA 0000H 0000H 0C10H 0002H 0002H
_$L650 :

;;	if(Accel_PID_Motor2 > (49151)){
CLINEA 0000H 0001H 0C11H 0002H 0020H
	l	er0,	NEAR _Accel_PID_Motor2
	mov	er2,	#0 
	cmp	r0,	#0ffh
	cmpc	r1,	#0bfh
	cmpc	r2,	#00h
	cmpc	r3,	#00h
	bles	_$L652
CBLOCK 243 5 3089

;;		Accel_PID_Motor2 = 49151;
CLINEA 0000H 0001H 0C12H 0003H 001BH
	mov	r0,	#0ffh
	mov	r1,	#0bfh
	st	er0,	NEAR _Accel_PID_Motor2
CBLOCKEND 243 5 3091

;;	}
CLINEA 0000H 0000H 0C13H 0002H 0002H
_$L652 :

;;	if(Accel_PID_Motor2 < (16383)){
CLINEA 0000H 0001H 0C14H 0002H 0020H
	l	er0,	NEAR _Accel_PID_Motor2
	cmp	r0,	#0ffh
	cmpc	r1,	#03fh
	bge	_$L654
CBLOCK 243 6 3092

;;		Accel_PID_Motor2 = 16383;
CLINEA 0000H 0001H 0C15H 0003H 001BH
	mov	r0,	#0ffh
	mov	r1,	#03fh
	st	er0,	NEAR _Accel_PID_Motor2
CBLOCKEND 243 6 3094

;;	}
CLINEA 0000H 0000H 0C16H 0002H 0002H
_$L654 :

;;	if(Accel_PID_Motor3 > (49151)){
CLINEA 0000H 0001H 0C17H 0002H 0020H
	l	er0,	NEAR _Accel_PID_Motor3
	mov	er2,	#0 
	cmp	r0,	#0ffh
	cmpc	r1,	#0bfh
	cmpc	r2,	#00h
	cmpc	r3,	#00h
	bles	_$L656
CBLOCK 243 7 3095

;;		Accel_PID_Motor3 = 49151;
CLINEA 0000H 0001H 0C18H 0003H 001BH
	mov	r0,	#0ffh
	mov	r1,	#0bfh
	st	er0,	NEAR _Accel_PID_Motor3
CBLOCKEND 243 7 3097

;;	}
CLINEA 0000H 0000H 0C19H 0002H 0002H
_$L656 :

;;	if(Accel_PID_Motor3 < (16383)){
CLINEA 0000H 0001H 0C1AH 0002H 0020H
	l	er0,	NEAR _Accel_PID_Motor3
	cmp	r0,	#0ffh
	cmpc	r1,	#03fh
	bge	_$L658
CBLOCK 243 8 3098

;;		Accel_PID_Motor3 = 16383;
CLINEA 0000H 0001H 0C1BH 0003H 001BH
	mov	r0,	#0ffh
	mov	r1,	#03fh
	st	er0,	NEAR _Accel_PID_Motor3
CBLOCKEND 243 8 3100

;;	}
CLINEA 0000H 0000H 0C1CH 0002H 0002H
_$L658 :

;;	if(Accel_PID_Motor4 > (49151)){
CLINEA 0000H 0001H 0C1DH 0002H 0020H
	l	er0,	NEAR _Accel_PID_Motor4
	mov	er2,	#0 
	cmp	r0,	#0ffh
	cmpc	r1,	#0bfh
	cmpc	r2,	#00h
	cmpc	r3,	#00h
	bles	_$L660
CBLOCK 243 9 3101

;;		Accel_PID_Motor4 = 49151;
CLINEA 0000H 0001H 0C1EH 0003H 001BH
	mov	r0,	#0ffh
	mov	r1,	#0bfh
	st	er0,	NEAR _Accel_PID_Motor4
CBLOCKEND 243 9 3103

;;	}
CLINEA 0000H 0000H 0C1FH 0002H 0002H
_$L660 :

;;	if(Accel_PID_Motor4 < (16383)){
CLINEA 0000H 0001H 0C20H 0002H 0020H
	l	er0,	NEAR _Accel_PID_Motor4
	cmp	r0,	#0ffh
	cmpc	r1,	#03fh
	bge	_$L662
CBLOCK 243 10 3104

;;		Accel_PID_Motor4 = 16383;
CLINEA 0000H 0001H 0C21H 0003H 001BH
	mov	r0,	#0ffh
	mov	r1,	#03fh
	st	er0,	NEAR _Accel_PID_Motor4
CBLOCKEND 243 10 3106

;;	}
CLINEA 0000H 0000H 0C22H 0002H 0002H
_$L662 :
CBLOCKEND 243 2 3107

;;}
CLINEA 0000H 0001H 0C23H 0001H 0001H
	rt
CBLOCKEND 243 1 3107
CFUNCTIONEND 243


	rseg $$Shutdown$main
CFUNCTION 244

_Shutdown	:
CBLOCK 244 1 3109

;;void Shutdown(void){
CLINEA 0000H 0001H 0C25H 0001H 0014H
	push	lr
CBLOCK 244 2 3109
CRET 0000H

;;	if((PWED > PWMSafeDuty)||(PWF0D > PWMSafeDuty)||(PWDD > PWMSafeDuty)||(PWCD > PWMSafeDuty)){
CLINEA 0000H 0001H 0C26H 0002H 005DH
	l	er0,	0f932h
	l	er2,	NEAR _PWMSafeDuty
	cmp	er0,	er2
	bgt	_$L666
	l	er0,	0f962h
	cmp	er0,	er2
	bgt	_$L666
	l	er0,	0f922h
	cmp	er0,	er2
	bgt	_$L666
	l	er0,	0f912h
	cmp	er0,	er2
	bgt	_$M50
	b	_$L679
_$M50 :
_$L666 :
CBLOCK 244 3 3110
CBLOCK 244 4 3111

;;			main_clrWDT();					
CLINEA 0000H 0001H 0C28H 0004H 0016H
	bl	_main_clrWDT

;;			PFRUN = 0;	//Turn OFF PWM
CLINEA 0000H 0001H 0C29H 0004H 001CH
	rb	0f973h.0

;;			PERUN = 0;
CLINEA 0000H 0001H 0C2AH 0004H 000DH
	rb	0f937h.0

;;			PDRUN = 0;
CLINEA 0000H 0001H 0C2BH 0004H 000DH
	rb	0f927h.0

;;			PCRUN = 0;
CLINEA 0000H 0001H 0C2CH 0004H 000DH
	rb	0f917h.0

;;			PWF0D -= 10; //Can't be running to change (Only this variable)
CLINEA 0000H 0001H 0C2DH 0004H 0041H
	l	er0,	0f962h
	add	er0,	#-10
	st	er0,	0f962h

;;			PWED -= 10;
CLINEA 0000H 0001H 0C2EH 0004H 000EH
	l	er0,	0f932h
	add	er0,	#-10
	st	er0,	0f932h

;;			PWDD -= 10;
CLINEA 0000H 0001H 0C2FH 0004H 000EH
	l	er0,	0f922h
	add	er0,	#-10
	st	er0,	0f922h

;;			PWCD -= 10;
CLINEA 0000H 0001H 0C30H 0004H 000EH
	l	er0,	0f912h
	add	er0,	#-10
	st	er0,	0f912h

;;			PFRUN = 1;	//Turn ON PWM
CLINEA 0000H 0001H 0C31H 0004H 001BH
	sb	0f973h.0

;;			PERUN = 1;
CLINEA 0000H 0001H 0C32H 0004H 000DH
	sb	0f937h.0

;;			PDRUN = 1;
CLINEA 0000H 0001H 0C33H 0004H 000DH
	sb	0f927h.0

;;			PCRUN = 1;
CLINEA 0000H 0001H 0C34H 0004H 000DH
	sb	0f917h.0

;;			NOPms(100);
CLINEA 0000H 0001H 0C35H 0004H 000EH
	mov	r0,	#064h
	mov	r1,	#00h
	bl	_NOPms

;;			if(PWED <= PWMSafeDuty){
CLINEA 0000H 0001H 0C37H 0004H 001BH
	l	er0,	0f932h
	l	er2,	NEAR _PWMSafeDuty
	cmp	er0,	er2
	bgt	_$L682
CBLOCK 244 5 3127

;;				PWED = PWMSafeDuty;
CLINEA 0000H 0001H 0C38H 0005H 0017H
	st	er2,	0f932h
CBLOCKEND 244 5 3129

;;			}
CLINEA 0000H 0000H 0C39H 0004H 0004H
_$L682 :

;;			if(PWF0D <= PWMSafeDuty){
CLINEA 0000H 0001H 0C3AH 0004H 001CH
	l	er0,	0f962h
	cmp	er0,	er2
	bgt	_$L684
CBLOCK 244 6 3130

;;				PWF0D = PWMSafeDuty;
CLINEA 0000H 0001H 0C3BH 0005H 0018H
	st	er2,	0f962h
CBLOCKEND 244 6 3132

;;			}
CLINEA 0000H 0000H 0C3CH 0004H 0004H
_$L684 :

;;			if(PWDD <= PWMSafeDuty){
CLINEA 0000H 0001H 0C3DH 0004H 001BH
	l	er0,	0f922h
	cmp	er0,	er2
	bgt	_$L686
CBLOCK 244 7 3133

;;				PWDD = PWMSafeDuty;
CLINEA 0000H 0001H 0C3EH 0005H 0017H
	st	er2,	0f922h
CBLOCKEND 244 7 3135

;;			}
CLINEA 0000H 0000H 0C3FH 0004H 0004H
_$L686 :

;;			if(PWCD <= PWMSafeDuty){
CLINEA 0000H 0001H 0C40H 0004H 001BH
	l	er0,	0f912h
	cmp	er0,	er2
	bgt	_$L688
CBLOCK 244 8 3136

;;				PWCD = PWMSafeDuty;
CLINEA 0000H 0001H 0C41H 0005H 0017H
	st	er2,	0f912h
CBLOCKEND 244 8 3138

;;			}
CLINEA 0000H 0000H 0C42H 0004H 0004H
_$L688 :
CBLOCKEND 244 4 3140

;;		}while((PWED > PWMSafeDuty)||(PWF0D > PWMSafeDuty)||(PWDD > PWMSafeDuty)||(PWCD > PWMSafeDuty));
CLINEA 0000H 0000H 0C44H 0003H 0062H
	l	er0,	0f932h
	cmp	er0,	er2
	ble	_$M51
	b	_$L666
_$M51 :
	l	er0,	0f962h
	cmp	er0,	er2
	ble	_$M52
	b	_$L666
_$M52 :
	l	er0,	0f922h
	cmp	er0,	er2
	ble	_$M53
	b	_$L666
_$M53 :
	l	er0,	0f912h
	cmp	er0,	er2
	ble	_$M54
	b	_$L666
_$M54 :
_$L679 :
CBLOCKEND 244 3 3141

;;	Accel_PID_Motor1 = 16383;
CLINEA 0000H 0001H 0C46H 0002H 001AH
	mov	r0,	#0ffh
	mov	r1,	#03fh
	st	er0,	NEAR _Accel_PID_Motor1

;;	Accel_PID_Motor2 = 16383;
CLINEA 0000H 0001H 0C47H 0002H 001AH
	st	er0,	NEAR _Accel_PID_Motor2

;;	Accel_PID_Motor3 = 16383;
CLINEA 0000H 0001H 0C48H 0002H 001AH
	st	er0,	NEAR _Accel_PID_Motor3

;;	Accel_PID_Motor4 = 16383;
CLINEA 0000H 0001H 0C49H 0002H 001AH
	st	er0,	NEAR _Accel_PID_Motor4
CBLOCKEND 244 2 3147

;;}
CLINEA 0000H 0001H 0C4BH 0001H 0001H
	pop	pc
CBLOCKEND 244 1 3147
CFUNCTIONEND 244


	rseg $$ESC1_PWM$main
CFUNCTION 215

_ESC1_PWM	:
CBLOCK 215 1 3151

;;void ESC1_PWM(void){
CLINEA 0000H 0001H 0C4FH 0001H 0014H
CBLOCK 215 2 3151

;;      PC0DIR = 0;       // PortB Bit0 set to Output Mode...
CLINEA 0000H 0001H 0C5EH 0007H 003BH
	rb	0f261h.0

;;      PC0C1  = 1;       // PortB Bit0 set to CMOS Output...
CLINEA 0000H 0001H 0C61H 0007H 003BH
	sb	0f263h.0

;;      PC0C0  = 1;       
CLINEA 0000H 0001H 0C62H 0007H 0018H
	sb	0f262h.0

;;      PC0MD1  = 1;            // PortC Bit0 set to PWM Output (1,0)...
CLINEA 0000H 0001H 0C65H 0007H 0046H
	sb	0f265h.0

;;      PC0MD0  = 0;      
CLINEA 0000H 0001H 0C66H 0007H 0018H
	rb	0f264h.0

;;      PFCS1 = 0;        //00= LS; 01=HS; 10=PLL
CLINEA 0000H 0001H 0C6AH 0007H 002FH
	rb	0f972h.1

;;      PFCS0 = 1;
CLINEA 0000H 0001H 0C6BH 0007H 0010H
	sb	0f972h.0

;;      PWFP = PWMPeriod;            // Init Period to (1=255kHz; 10=46kHz; 50=10kHz; 200=2.5kH; ; 3185 = 160Hz; 3400=150Hz; 4250=120Hz; 5000=102Hz)
CLINEA 0000H 0001H 0C6EH 0007H 0092H
	l	er0,	NEAR _PWMPeriod
	st	er0,	0f960h

;;      PWF0D =    PWMSafeDuty;           //12    ~  0.25 % duty cycle @ 160Hz
CLINEA 0000H 0001H 0C78H 0007H 004CH
	l	er0,	NEAR _PWMSafeDuty
	st	er0,	0f962h

;;      PFRUN = 0;        // OFF to start
CLINEA 0000H 0001H 0C7AH 0007H 0027H
	rb	0f973h.0
CBLOCKEND 215 2 3195

;;}
CLINEA 0000H 0001H 0C7BH 0001H 0001H
	rt
CBLOCKEND 215 1 3195
CFUNCTIONEND 215


	rseg $$ESC2_PWM$main
CFUNCTION 216

_ESC2_PWM	:
CBLOCK 216 1 3200

;;void ESC2_PWM(void){
CLINEA 0000H 0001H 0C80H 0001H 0014H
CBLOCK 216 2 3200

;;      PB2DIR = 0;       // PortB Bit0 set to Output Mode...
CLINEA 0000H 0001H 0C8FH 0007H 003BH
	rb	0f259h.2

;;      PB2C1  = 1;       // PortB Bit0 set to CMOS Output...
CLINEA 0000H 0001H 0C92H 0007H 003BH
	sb	0f25bh.2

;;      PB2C0  = 1;       
CLINEA 0000H 0001H 0C93H 0007H 0018H
	sb	0f25ah.2

;;      PB2MD1  = 0;            // PortB Bit0 set to PWM Output (0,1)...
CLINEA 0000H 0001H 0C96H 0007H 0046H
	rb	0f25dh.2

;;      PB2MD0  = 1;      
CLINEA 0000H 0001H 0C97H 0007H 0018H
	sb	0f25ch.2

;;      PECS1 = 0;        //00= LS; 01=HS; 10=PLL
CLINEA 0000H 0001H 0C9BH 0007H 002FH
	rb	0f936h.1

;;      PECS0 = 1;
CLINEA 0000H 0001H 0C9CH 0007H 0010H
	sb	0f936h.0

;;      PWEP = PWMPeriod;            // Init Period to (1=255kHz; 10=46kHz; 50=10kHz; 200=2.5kH; ; 3185 = 160Hz; 3400=150Hz; 4250=120Hz; 5000=102Hz)
CLINEA 0000H 0001H 0C9FH 0007H 0092H
	l	er0,	NEAR _PWMPeriod
	st	er0,	0f930h

;;      PWED =    PWMSafeDuty;           //12    ~  0.25 % duty cycle @ 160Hz
CLINEA 0000H 0001H 0CA9H 0007H 004BH
	l	er0,	NEAR _PWMSafeDuty
	st	er0,	0f932h

;;      PERUN = 0;        // OFF to start
CLINEA 0000H 0001H 0CABH 0007H 0027H
	rb	0f937h.0
CBLOCKEND 216 2 3244

;;}
CLINEA 0000H 0001H 0CACH 0001H 0001H
	rt
CBLOCKEND 216 1 3244
CFUNCTIONEND 216


	rseg $$ESC3_PWM$main
CFUNCTION 217

_ESC3_PWM	:
CBLOCK 217 1 3250

;;void ESC3_PWM(void){
CLINEA 0000H 0001H 0CB2H 0001H 0014H
CBLOCK 217 2 3250

;;      PA1DIR = 0;       // PortB Bit0 set to Output Mode...
CLINEA 0000H 0001H 0CC1H 0007H 003BH
	rb	0f251h.1

;;      PA1C1  = 1;       // PortB Bit0 set to CMOS Output...
CLINEA 0000H 0001H 0CC4H 0007H 003BH
	sb	0f253h.1

;;      PA1C0  = 1;       
CLINEA 0000H 0001H 0CC5H 0007H 0018H
	sb	0f252h.1

;;      PA1MD1  = 0;            // PortB Bit0 set to PWM Output (0,1)...
CLINEA 0000H 0001H 0CC8H 0007H 0046H
	rb	0f255h.1

;;      PA1MD0  = 1;      
CLINEA 0000H 0001H 0CC9H 0007H 0018H
	sb	0f254h.1

;;      PDCS1 = 0;        //00= LS; 01=HS; 10=PLL
CLINEA 0000H 0001H 0CCDH 0007H 002FH
	rb	0f926h.1

;;      PDCS0 = 1;
CLINEA 0000H 0001H 0CCEH 0007H 0010H
	sb	0f926h.0

;;      PWDP = PWMPeriod;            // Init Period to (1=255kHz; 10=46kHz; 50=10kHz; 200=2.5kH; ; 3185 = 160Hz; 3400=150Hz; 4250=120Hz; 5000=102Hz)
CLINEA 0000H 0001H 0CD1H 0007H 0092H
	l	er0,	NEAR _PWMPeriod
	st	er0,	0f920h

;;      PWDD =    PWMSafeDuty;           //12    ~  0.25 % duty cycle @ 160Hz
CLINEA 0000H 0001H 0CDBH 0007H 004BH
	l	er0,	NEAR _PWMSafeDuty
	st	er0,	0f922h

;;      PDRUN = 0;        // OFF to start
CLINEA 0000H 0001H 0CDDH 0007H 0027H
	rb	0f927h.0
CBLOCKEND 217 2 3294

;;}
CLINEA 0000H 0001H 0CDEH 0001H 0001H
	rt
CBLOCKEND 217 1 3294
CFUNCTIONEND 217


	rseg $$ESC4_PWM$main
CFUNCTION 218

_ESC4_PWM	:
CBLOCK 218 1 3301

;;void ESC4_PWM(void){
CLINEA 0000H 0001H 0CE5H 0001H 0014H
CBLOCK 218 2 3301

;;      PA0DIR = 0;       // PortB Bit0 set to Output Mode...
CLINEA 0000H 0001H 0CF4H 0007H 003BH
	rb	0f251h.0

;;      PA0C1  = 1;       // PortB Bit0 set to CMOS Output...
CLINEA 0000H 0001H 0CF7H 0007H 003BH
	sb	0f253h.0

;;      PA0C0  = 1;       
CLINEA 0000H 0001H 0CF8H 0007H 0018H
	sb	0f252h.0

;;      PA0MD1  = 0;            // PortB Bit0 set to PWM Output (0,1)...
CLINEA 0000H 0001H 0CFBH 0007H 0046H
	rb	0f255h.0

;;      PA0MD0  = 1;      
CLINEA 0000H 0001H 0CFCH 0007H 0018H
	sb	0f254h.0

;;      PCCS1 = 0;        //00= LS; 01=HS; 10=PLL
CLINEA 0000H 0001H 0D00H 0007H 002FH
	rb	0f916h.1

;;      PCCS0 = 1;
CLINEA 0000H 0001H 0D01H 0007H 0010H
	sb	0f916h.0

;;      PWCP = PWMPeriod;            // Init Period to (1=255kHz; 10=46kHz; 50=10kHz; 200=2.5kH; ; 3185 = 160Hz; 3400=150Hz; 4250=120Hz; 5000=102Hz)
CLINEA 0000H 0001H 0D04H 0007H 0092H
	l	er0,	NEAR _PWMPeriod
	st	er0,	0f910h

;;      PWCD =    PWMSafeDuty;           //12    ~  0.25 % duty cycle @ 160Hz
CLINEA 0000H 0001H 0D0FH 0007H 004BH
	l	er0,	NEAR _PWMSafeDuty
	st	er0,	0f912h

;;      PCRUN = 0;        // OFF to start
CLINEA 0000H 0001H 0D13H 0007H 0027H
	rb	0f917h.0
CBLOCKEND 218 2 3348

;;}
CLINEA 0000H 0001H 0D14H 0001H 0001H
	rt
CBLOCKEND 218 1 3348
CFUNCTIONEND 218


	rseg $$TBC_ISR$main
CFUNCTION 256

_TBC_ISR	:
CBLOCK 256 1 3353

;;{
CLINEA 0000H 0001H 0D19H 0001H 0001H
CBLOCK 256 2 3353

;;	E128H = 0;	//Turn OFF TBC Interrupt
CLINEA 0000H 0001H 0D1AH 0002H 0024H
	rb	0f016h.5

;;	E128H = 1;	//Turn ON TBC Interrupt
CLINEA 0000H 0001H 0D1BH 0002H 0023H
	sb	0f016h.5
CBLOCKEND 256 2 3356

;;}
CLINEA 0000H 0001H 0D1CH 0001H 0001H
	rt
CBLOCKEND 256 1 3356
CFUNCTIONEND 256


	rseg $$TMR89_ISR$main
CFUNCTION 257

_TMR89_ISR	:
CBLOCK 257 1 3361

;;{
CLINEA 0000H 0001H 0D21H 0001H 0001H
	push	lr
CBLOCK 257 2 3361
CRET 0000H

;;	LED_1 ^= 1;
CLINEA 0000H 0001H 0D22H 0002H 000CH
	tb	0f250h.2
	beq	_$M61
	rb	0f250h.2
	bal	_$M62
_$M61 :
	sb	0f250h.2
_$M62 :

;;	Accel_PID_XRollCounter_I++;
CLINEA 0000H 0000H 0D29H 0002H 001CH
	l	er0,	NEAR _Accel_PID_XRollCounter_I
	add	er0,	#1 
	st	er0,	NEAR _Accel_PID_XRollCounter_I

;;	if(Accel_PID_XRollCounter_I >= 65535){
CLINEA 0000H 0001H 0D2AH 0002H 0027H
	mov	er2,	#0 
	cmp	r0,	#0ffh
	cmpc	r1,	#0ffh
	cmpc	r2,	#00h
	cmpc	r3,	#00h
	blts	_$L707
CBLOCK 257 3 3370

;;		Accel_PID_XRollCounter_I = 0;
CLINEA 0000H 0001H 0D2BH 0003H 001FH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_XRollCounter_I
CBLOCKEND 257 3 3372

;;	}
CLINEA 0000H 0000H 0D2CH 0002H 0002H
_$L707 :

;;	Accel_PID_YPitchCounter_I++;
CLINEA 0000H 0000H 0D2DH 0002H 001DH
	l	er0,	NEAR _Accel_PID_YPitchCounter_I
	add	er0,	#1 
	st	er0,	NEAR _Accel_PID_YPitchCounter_I

;;	if(Accel_PID_YPitchCounter_I >= 65535){
CLINEA 0000H 0001H 0D2EH 0002H 0028H
	mov	er2,	#0 
	cmp	r0,	#0ffh
	cmpc	r1,	#0ffh
	cmpc	r2,	#00h
	cmpc	r3,	#00h
	blts	_$L709
CBLOCK 257 4 3374

;;		Accel_PID_YPitchCounter_I = 0;
CLINEA 0000H 0001H 0D2FH 0003H 0020H
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_YPitchCounter_I
CBLOCKEND 257 4 3376

;;	}
CLINEA 0000H 0000H 0D30H 0002H 0002H
_$L709 :

;;	Accel_PID_XRollCounter_D++;
CLINEA 0000H 0000H 0D31H 0002H 001CH
	l	er0,	NEAR _Accel_PID_XRollCounter_D
	add	er0,	#1 
	st	er0,	NEAR _Accel_PID_XRollCounter_D

;;	if(Accel_PID_XRollCounter_D >= 65535){
CLINEA 0000H 0001H 0D32H 0002H 0027H
	mov	er2,	#0 
	cmp	r0,	#0ffh
	cmpc	r1,	#0ffh
	cmpc	r2,	#00h
	cmpc	r3,	#00h
	blts	_$L711
CBLOCK 257 5 3378

;;		Accel_PID_XRollCounter_D = 0;
CLINEA 0000H 0001H 0D33H 0003H 001FH
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_XRollCounter_D
CBLOCKEND 257 5 3380

;;	}
CLINEA 0000H 0000H 0D34H 0002H 0002H
_$L711 :

;;	Accel_PID_YPitchCounter_D++;
CLINEA 0000H 0000H 0D35H 0002H 001DH
	l	er0,	NEAR _Accel_PID_YPitchCounter_D
	add	er0,	#1 
	st	er0,	NEAR _Accel_PID_YPitchCounter_D

;;	if(Accel_PID_YPitchCounter_D >= 65535){
CLINEA 0000H 0001H 0D36H 0002H 0028H
	mov	er2,	#0 
	cmp	r0,	#0ffh
	cmpc	r1,	#0ffh
	cmpc	r2,	#00h
	cmpc	r3,	#00h
	blts	_$L713
CBLOCK 257 6 3382

;;		Accel_PID_YPitchCounter_D = 0;
CLINEA 0000H 0001H 0D37H 0003H 0020H
	mov	er0,	#0 
	st	er0,	NEAR _Accel_PID_YPitchCounter_D
CBLOCKEND 257 6 3384

;;	}
CLINEA 0000H 0000H 0D38H 0002H 0002H
_$L713 :

;;	CF_Gyro_Counter++;
CLINEA 0000H 0000H 0D3FH 0002H 0013H
	l	er0,	NEAR _CF_Gyro_Counter
	l	er2,	NEAR _CF_Gyro_Counter+02h
	push	xr0
	mov	er0,	#0 
	mov	r2,	#080h
	mov	r3,	#03fh
	push	xr0
	bl	__faddu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	NEAR _CF_Gyro_Counter
	st	er2,	NEAR _CF_Gyro_Counter+02h

;;	if(CF_Gyro_Counter >= 65535){
CLINEA 0000H 0001H 0D40H 0002H 001EH
	push	xr0
	mov	r0,	#00h
	mov	r1,	#0ffh
	mov	r2,	#07fh
	mov	r3,	#047h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$L715
CBLOCK 257 7 3392

;;		CF_Gyro_Counter = 0;
CLINEA 0000H 0001H 0D41H 0003H 0016H
	mov	er0,	#0 
	st	er0,	NEAR _CF_Gyro_Counter
	st	er0,	NEAR _CF_Gyro_Counter+02h
CBLOCKEND 257 7 3394

;;	}
CLINEA 0000H 0000H 0D42H 0002H 0002H
_$L715 :
CBLOCKEND 257 2 3395

;;}
CLINEA 0000H 0001H 0D43H 0001H 0001H
	pop	pc
CBLOCKEND 257 1 3395
CFUNCTIONEND 257


	rseg $$AccelGyroDataReady_ISR$main
CFUNCTION 258

_AccelGyroDataReady_ISR	:
CBLOCK 258 1 3399

;;{
CLINEA 0000H 0001H 0D47H 0001H 0001H
CBLOCK 258 2 3399

;;	AccGyro_ReadFlag = 1;
CLINEA 0000H 0001H 0D48H 0002H 0016H
	mov	r0,	#01h
	st	r0,	NEAR _AccGyro_ReadFlag
CBLOCKEND 258 2 3401

;;}
CLINEA 0000H 0001H 0D49H 0001H 0001H
	rt
CBLOCKEND 258 1 3401
CFUNCTIONEND 258


	rseg $$_funcUartFin$main
CFUNCTION 245

__funcUartFin	:
CBLOCK 245 1 3412

;;{
CLINEA 0000H 0001H 0D54H 0001H 0001H
	push	lr
CBLOCK 245 2 3412
CRET 0000H
CARGUMENT 46H 0002H 0000H "size" 02H 00H 01H
CARGUMENT 46H 0001H 0000H "errStat" 02H 00H 00H

;;	uart_continue();					// Function in UART.c: process to continue send and receive...
CLINEA 0000H 0001H 0D55H 0002H 0054H
	bl	_uart_continue

;;	_flgUartFin = (unsigned char)FLG_SET;
CLINEA 0000H 0001H 0D56H 0002H 0026H
	mov	r0,	#01h
	st	r0,	NEAR __flgUartFin
CBLOCKEND 245 2 3416

;;}
CLINEA 0000H 0001H 0D58H 0001H 0001H
	pop	pc
CBLOCKEND 245 1 3416
CFUNCTIONEND 245


	rseg $$_funcI2CFin$main
CFUNCTION 246

__funcI2CFin	:
CBLOCK 246 1 3427

;;{
CLINEA 0000H 0001H 0D63H 0001H 0001H
	push	lr
CBLOCK 246 2 3427
CRET 0000H
CARGUMENT 46H 0002H 0000H "size" 02H 00H 01H
CARGUMENT 46H 0001H 0000H "errStat" 02H 00H 00H

;;	i2c_continue();					// Function in UART.c: process to continue send and receive...
CLINEA 0000H 0001H 0D64H 0002H 0053H
	bl	_i2c_continue

;;	_flgI2CFin = (unsigned char)FLG_SET;
CLINEA 0000H 0001H 0D65H 0002H 0025H
	mov	r0,	#01h
	st	r0,	NEAR __flgI2CFin
CBLOCKEND 246 2 3431

;;}
CLINEA 0000H 0001H 0D67H 0001H 0001H
	pop	pc
CBLOCKEND 246 1 3431
CFUNCTIONEND 246


	rseg $$_intI2c$main
CFUNCTION 250

__intI2c	:
CBLOCK 250 1 3441

;;{
CLINEA 0000H 0001H 0D71H 0001H 0001H
CBLOCK 250 2 3441

;;	i2c_continue();
CLINEA 0000H 0001H 0D72H 0002H 0010H
	b	_i2c_continue
CBLOCKEND 250 2 3444
CLINEA 0000H 0001H 0D74H 0001H 0001H
CBLOCKEND 250 1 3444
CFUNCTIONEND 250


	rseg $$checkI2C$main
CFUNCTION 247

_checkI2C	:
CBLOCK 247 1 3454

;;{
CLINEA 0000H 0001H 0D7EH 0001H 0001H
	push	lr
CBLOCK 247 2 3454
CRET 0000H
CLOCAL 47H 0002H 0024H 0002H "ret" 02H 00H 01H

;;	while (ret != 1) {
CLINEA 0000H 0000H 0D83H 0002H 0013H
_$L724 :
CBLOCK 247 3 3459

;;		ret = i2c_continue();
CLINEA 0000H 0000H 0D84H 0003H 0017H
	bl	_i2c_continue
CBLOCK 247 4 3461
CBLOCKEND 247 4 3463
CBLOCKEND 247 3 3464

;;	while (ret != 1) {
CLINEA 0000H 0000H 0D83H 000EH 0013H
	cmp	r0,	#01h
	cmpc	r1,	#00h
	bne	_$L724
CBLOCKEND 247 2 3465

;;}
CLINEA 0000H 0001H 0D89H 0001H 0001H
	pop	pc
CBLOCKEND 247 1 3465
CFUNCTIONEND 247


	rseg $$main_reqNotHalt$main
CFUNCTION 248

_main_reqNotHalt	:
CBLOCK 248 1 3475

;;{
CLINEA 0000H 0001H 0D93H 0001H 0001H
CBLOCK 248 2 3475

;;	_reqNotHalt = (unsigned char)FLG_SET;
CLINEA 0000H 0001H 0D94H 0002H 0026H
	mov	r0,	#01h
	st	r0,	NEAR __reqNotHalt
CBLOCKEND 248 2 3477

;;}
CLINEA 0000H 0001H 0D95H 0001H 0001H
	rt
CBLOCKEND 248 1 3477
CFUNCTIONEND 248


	rseg $$_intUart$main
CFUNCTION 249

__intUart	:
CBLOCK 249 1 3487

;;{
CLINEA 0000H 0001H 0D9FH 0001H 0001H
CBLOCK 249 2 3487

;;		uart_continue(); //in UART.c: process to continue send and receive...
CLINEA 0000H 0001H 0DA0H 0003H 0047H
	b	_uart_continue
CBLOCKEND 249 2 3489
CLINEA 0000H 0001H 0DA1H 0001H 0001H
CBLOCKEND 249 1 3489
CFUNCTIONEND 249


	rseg $$SetOSC$main
CFUNCTION 208

_SetOSC	:
CBLOCK 208 1 3494

;;static void SetOSC(void){
CLINEA 0000H 0001H 0DA6H 0001H 0019H
CBLOCK 208 2 3494

;;	SYSC0 = 0;			// Used to select the frequency of the HSCLK => 00=8.192MHz.
CLINEA 0000H 0001H 0DA9H 0002H 004AH
	rb	0f002h.0

;;	SYSC1 = 0;
CLINEA 0000H 0001H 0DAAH 0002H 000BH
	rb	0f002h.1

;;	OSCM1 = 1;			// 10 => Built-in PLL oscillation mode
CLINEA 0000H 0001H 0DACH 0002H 0034H
	sb	0f002h.3

;;	OSCM0 = 0;
CLINEA 0000H 0001H 0DADH 0002H 000BH
	rb	0f002h.2

;;	ENOSC = 1;			//1=Enable High Speed Oscillator...
CLINEA 0000H 0001H 0DAFH 0002H 0031H
	sb	0f003h.1

;;	SYSCLK = 1;			//1=HSCLK; 0=LSCLK 
CLINEA 0000H 0001H 0DB0H 0002H 0022H
	sb	0f003h.0

;;	LPLL = 1;			//1=Enables the use of PLL oscillation - ADDED 4/30/2013
CLINEA 0000H 0001H 0DB2H 0002H 0045H
	sb	0f003h.7

;;	__EI();			//INT enable
CLINEA 0000H 0001H 0DB4H 0002H 0017H
	ei
CBLOCKEND 208 2 3509

;;}
CLINEA 0000H 0001H 0DB5H 0001H 0001H
	rt
CBLOCKEND 208 1 3509
CFUNCTIONEND 208


	rseg $$analog_comparator$main
CFUNCTION 209

_analog_comparator	:
CBLOCK 209 1 3516

;;void analog_comparator(void){
CLINEA 0000H 0001H 0DBCH 0001H 001DH
CBLOCK 209 2 3516

;;	CMP0EN  = 0x01; 	// Comparator ON...
CLINEA 0000H 0001H 0DD2H 0002H 0025H
	sb	0f950h.0

;;	CMP0E1  = 0x00; 	// No Interupt...
CLINEA 0000H 0001H 0DD3H 0002H 0023H
	rb	0f951h.1

;;	CMP0E0  = 0x00;
CLINEA 0000H 0001H 0DD4H 0002H 0010H
	rb	0f951h.0

;;	CMP0SM1 = 0x00; 	// Detect without Sampling... 
CLINEA 0000H 0001H 0DD5H 0002H 0030H
	rb	0f951h.3

;;	CMP0RFS = 0x01; 	// Differential Input on B5
CLINEA 0000H 0001H 0DD6H 0002H 002DH
	sb	0f951h.4

;;	CMP0EN  = 0x00;
CLINEA 0000H 0001H 0DD9H 0002H 0010H
	rb	0f950h.0
CBLOCKEND 209 2 3548

;;}
CLINEA 0000H 0001H 0DDCH 0001H 0001H
	rt
CBLOCKEND 209 1 3548
CFUNCTIONEND 209


	rseg $$PortA_Low$main
CFUNCTION 210

_PortA_Low	:
CBLOCK 210 1 3556

;;void PortA_Low(void){
CLINEA 0000H 0001H 0DE4H 0001H 0015H
CBLOCK 210 2 3556

;;	PA0DIR = 0;		// PortA Bit0 set to Output Mode...
CLINEA 0000H 0001H 0DEEH 0002H 0031H
	rb	0f251h.0

;;	PA1DIR = 0;		// PortA Bit1 set to Output Mode...
CLINEA 0000H 0001H 0DEFH 0002H 0031H
	rb	0f251h.1

;;	PA2DIR = 0;		// PortA Bit2 set to Output Mode...
CLINEA 0000H 0001H 0DF0H 0002H 0031H
	rb	0f251h.2

;;	PA0C1  = 1;		// PortA Bit0 set to CMOS Output...
CLINEA 0000H 0001H 0DF3H 0002H 0031H
	sb	0f253h.0

;;	PA0C0  = 1;		
CLINEA 0000H 0001H 0DF4H 0002H 000EH
	sb	0f252h.0

;;	PA1C1  = 1;		// PortA Bit1 set to CMOS Output...
CLINEA 0000H 0001H 0DF5H 0002H 0031H
	sb	0f253h.1

;;	PA1C0  = 1;	
CLINEA 0000H 0001H 0DF6H 0002H 000DH
	sb	0f252h.1

;;	PA2C1  = 1;		// PortA Bit2 set to CMOS Output...
CLINEA 0000H 0001H 0DF7H 0002H 0031H
	sb	0f253h.2

;;	PA2C0  = 1;	
CLINEA 0000H 0001H 0DF8H 0002H 000DH
	sb	0f252h.2

;;	PA0MD1  = 0;	// PortA Bit0 set to General Purpose Output...
CLINEA 0000H 0001H 0DFBH 0002H 003CH
	rb	0f255h.0

;;	PA0MD0  = 0;	
CLINEA 0000H 0001H 0DFCH 0002H 000EH
	rb	0f254h.0

;;	PA1MD1  = 0;	// PortA Bit1 set to General Purpose Output...
CLINEA 0000H 0001H 0DFDH 0002H 003CH
	rb	0f255h.1

;;	PA1MD0  = 0;	
CLINEA 0000H 0001H 0DFEH 0002H 000EH
	rb	0f254h.1

;;	PA2MD1  = 0;	// PortA Bit2 set to General Purpose Output...
CLINEA 0000H 0001H 0DFFH 0002H 003CH
	rb	0f255h.2

;;	PA2MD0  = 0;	
CLINEA 0000H 0001H 0E00H 0002H 000EH
	rb	0f254h.2

;;	PA0D = 0;		// A.0 Output OFF....
CLINEA 0000H 0001H 0E03H 0002H 0021H
	rb	0f250h.0

;;	PA1D = 0;		// A.1 Output OFF....
CLINEA 0000H 0001H 0E04H 0002H 0021H
	rb	0f250h.1

;;	PA2D = 0;		// A.2 Output OFF....
CLINEA 0000H 0001H 0E05H 0002H 0021H
	rb	0f250h.2

;;	main_clrWDT(); 	// Clear WDT
CLINEA 0000H 0001H 0E07H 0002H 001DH
	b	_main_clrWDT
CBLOCKEND 210 2 3593
CLINEA 0000H 0001H 0E09H 0001H 0001H
CBLOCKEND 210 1 3593
CFUNCTIONEND 210


	rseg $$PortB_Low$main
CFUNCTION 211

_PortB_Low	:
CBLOCK 211 1 3599

;;void PortB_Low(void){
CLINEA 0000H 0001H 0E0FH 0001H 0015H
CBLOCK 211 2 3599

;;	PB0DIR = 0;		// PortB Bit0 set to Output Mode...
CLINEA 0000H 0001H 0E19H 0002H 0031H
	rb	0f259h.0

;;	PB1DIR = 0;		// PortB Bit1 set to Output Mode...
CLINEA 0000H 0001H 0E1AH 0002H 0031H
	rb	0f259h.1

;;	PB2DIR = 0;		// PortB Bit2 set to Output Mode...
CLINEA 0000H 0001H 0E1BH 0002H 0031H
	rb	0f259h.2

;;	PB3DIR = 0;		// PortB Bit3 set to Output Mode...
CLINEA 0000H 0001H 0E1CH 0002H 0031H
	rb	0f259h.3

;;	PB4DIR = 0;		// PortB Bit4 set to Output Mode...
CLINEA 0000H 0001H 0E1DH 0002H 0031H
	rb	0f259h.4

;;	PB5DIR = 0;		// PortB Bit5 set to Output Mode...
CLINEA 0000H 0001H 0E1EH 0002H 0031H
	rb	0f259h.5

;;	PB6DIR = 0;		// PortB Bit6 set to Output Mode...
CLINEA 0000H 0001H 0E1FH 0002H 0031H
	rb	0f259h.6

;;	PB7DIR = 0;		// PortB Bit7 set to Output Mode...
CLINEA 0000H 0001H 0E20H 0002H 0031H
	rb	0f259h.7

;;	PB0C1  = 1;		// PortB Bit0 set to CMOS Output...
CLINEA 0000H 0001H 0E23H 0002H 0031H
	sb	0f25bh.0

;;	PB0C0  = 1;		
CLINEA 0000H 0001H 0E24H 0002H 000EH
	sb	0f25ah.0

;;	PB1C1  = 1;		// PortB Bit1 set to CMOS Output...
CLINEA 0000H 0001H 0E25H 0002H 0031H
	sb	0f25bh.1

;;	PB1C0  = 1;	
CLINEA 0000H 0001H 0E26H 0002H 000DH
	sb	0f25ah.1

;;	PB2C1  = 1;		// PortB Bit2 set to CMOS Output...
CLINEA 0000H 0001H 0E27H 0002H 0031H
	sb	0f25bh.2

;;	PB2C0  = 1;	
CLINEA 0000H 0001H 0E28H 0002H 000DH
	sb	0f25ah.2

;;	PB3C1  = 1;		// PortB Bit3 set to CMOS Output...
CLINEA 0000H 0001H 0E29H 0002H 0031H
	sb	0f25bh.3

;;	PB3C0  = 1;		
CLINEA 0000H 0001H 0E2AH 0002H 000EH
	sb	0f25ah.3

;;	PB4C1  = 1;		// PortB Bit4 set to CMOS Output...
CLINEA 0000H 0001H 0E2BH 0002H 0031H
	sb	0f25bh.4

;;	PB4C0  = 1;	
CLINEA 0000H 0001H 0E2CH 0002H 000DH
	sb	0f25ah.4

;;	PB5C1  = 1;		// PortB Bit5 set to CMOS Output...
CLINEA 0000H 0001H 0E2DH 0002H 0031H
	sb	0f25bh.5

;;	PB5C0  = 1;	
CLINEA 0000H 0001H 0E2EH 0002H 000DH
	sb	0f25ah.5

;;	PB6C1  = 1;		// PortB Bit6 set to CMOS Output...
CLINEA 0000H 0001H 0E2FH 0002H 0031H
	sb	0f25bh.6

;;	PB6C0  = 1;	
CLINEA 0000H 0001H 0E30H 0002H 000DH
	sb	0f25ah.6

;;	PB7C1  = 1;		// PortB Bit7 set to CMOS Output...
CLINEA 0000H 0001H 0E31H 0002H 0031H
	sb	0f25bh.7

;;	PB7C0  = 1;	
CLINEA 0000H 0001H 0E32H 0002H 000DH
	sb	0f25ah.7

;;	PB0MD1  = 0;	// PortB Bit0 set to General Purpose Output...
CLINEA 0000H 0001H 0E35H 0002H 003CH
	rb	0f25dh.0

;;	PB0MD0  = 0;	
CLINEA 0000H 0001H 0E36H 0002H 000EH
	rb	0f25ch.0

;;	PB1MD1  = 0;	// PortB Bit1 set to General Purpose Output...
CLINEA 0000H 0001H 0E37H 0002H 003CH
	rb	0f25dh.1

;;	PB1MD0  = 0;	
CLINEA 0000H 0001H 0E38H 0002H 000EH
	rb	0f25ch.1

;;	PB2MD1  = 0;	// PortB Bit2 set to General Purpose Output...
CLINEA 0000H 0001H 0E39H 0002H 003CH
	rb	0f25dh.2

;;	PB2MD0  = 0;	
CLINEA 0000H 0001H 0E3AH 0002H 000EH
	rb	0f25ch.2

;;	PB3MD1  = 0;	// PortB Bit3 set to General Purpose Output...
CLINEA 0000H 0001H 0E3BH 0002H 003CH
	rb	0f25dh.3

;;	PB3MD0  = 0;	
CLINEA 0000H 0001H 0E3CH 0002H 000EH
	rb	0f25ch.3

;;	PB4MD1  = 0;	// PortB Bit4 set to General Purpose Output...
CLINEA 0000H 0001H 0E3DH 0002H 003CH
	rb	0f25dh.4

;;	PB4MD0  = 0;	
CLINEA 0000H 0001H 0E3EH 0002H 000EH
	rb	0f25ch.4

;;	PB5MD1  = 0;	// PortB Bit5 set to General Purpose Output...
CLINEA 0000H 0001H 0E3FH 0002H 003CH
	rb	0f25dh.5

;;	PB5MD0  = 0;
CLINEA 0000H 0001H 0E40H 0002H 000DH
	rb	0f25ch.5

;;	PB6MD1  = 0;	// PortB Bit6 set to General Purpose Output...
CLINEA 0000H 0001H 0E41H 0002H 003CH
	rb	0f25dh.6

;;	PB6MD0  = 0;	
CLINEA 0000H 0001H 0E42H 0002H 000EH
	rb	0f25ch.6

;;	PB7MD1  = 0;	// PortB Bit7 set to General Purpose Output...
CLINEA 0000H 0001H 0E43H 0002H 003CH
	rb	0f25dh.7

;;	PB7MD0  = 0;
CLINEA 0000H 0001H 0E44H 0002H 000DH
	rb	0f25ch.7

;;	PB0D = 0;		// B.0 Output OFF....
CLINEA 0000H 0001H 0E47H 0002H 0021H
	rb	0f258h.0

;;	PB1D = 0;		// B.1 Output OFF....
CLINEA 0000H 0001H 0E48H 0002H 0021H
	rb	0f258h.1

;;	PB2D = 0;		// B.2 Output OFF....
CLINEA 0000H 0001H 0E49H 0002H 0021H
	rb	0f258h.2

;;	PB3D = 0;		// B.3 Output OFF....
CLINEA 0000H 0001H 0E4AH 0002H 0021H
	rb	0f258h.3

;;	PB4D = 0;		// B.4 Output OFF....
CLINEA 0000H 0001H 0E4BH 0002H 0021H
	rb	0f258h.4

;;	PB5D = 0;		// B.5 Output OFF....
CLINEA 0000H 0001H 0E4CH 0002H 0021H
	rb	0f258h.5

;;	PB6D = 0;		// B.6 Output OFF....
CLINEA 0000H 0001H 0E4DH 0002H 0021H
	rb	0f258h.6

;;	PB7D = 0;		// B.7 Output OFF....
CLINEA 0000H 0001H 0E4EH 0002H 0021H
	rb	0f258h.7

;;	main_clrWDT(); 	// Clear WDT
CLINEA 0000H 0001H 0E50H 0002H 001DH
	b	_main_clrWDT
CBLOCKEND 211 2 3666
CLINEA 0000H 0001H 0E52H 0001H 0001H
CBLOCKEND 211 1 3666
CFUNCTIONEND 211


	rseg $$PortC_Low$main
CFUNCTION 212

_PortC_Low	:
CBLOCK 212 1 3672

;;void PortC_Low(void){
CLINEA 0000H 0001H 0E58H 0001H 0015H
CBLOCK 212 2 3672

;;	PC0DIR = 0;		// PortC Bit0 set to Output Mode...
CLINEA 0000H 0001H 0E62H 0002H 0031H
	rb	0f261h.0

;;	PC1DIR = 0;		// PortC Bit1 set to Output Mode...
CLINEA 0000H 0001H 0E63H 0002H 0031H
	rb	0f261h.1

;;	PC2DIR = 0;		// PortC Bit2 set to Output Mode...
CLINEA 0000H 0001H 0E64H 0002H 0031H
	rb	0f261h.2

;;	PC3DIR = 1;		// PortC Bit3 set to Output Mode...
CLINEA 0000H 0001H 0E65H 0002H 0031H
	sb	0f261h.3

;;	PC4DIR = 0;		// PortC Bit4 set to Output Mode...
CLINEA 0000H 0001H 0E66H 0002H 0031H
	rb	0f261h.4

;;	PC5DIR = 1;		// PortC Bit5 set to Output Mode...
CLINEA 0000H 0001H 0E67H 0002H 0031H
	sb	0f261h.5

;;	PC6DIR = 0;		// PortC Bit6 set to Output Mode...
CLINEA 0000H 0001H 0E68H 0002H 0031H
	rb	0f261h.6

;;	PC7DIR = 0;		// PortC Bit7 set to Output Mode...
CLINEA 0000H 0001H 0E69H 0002H 0031H
	rb	0f261h.7

;;	PC0C1  = 1;		// PortC Bit0 set to High-Impedance Output...
CLINEA 0000H 0001H 0E6CH 0002H 003BH
	sb	0f263h.0

;;	PC0C0  = 1;		
CLINEA 0000H 0001H 0E6DH 0002H 000EH
	sb	0f262h.0

;;	PC1C1  = 1;		// PortC Bit1 set to High-Impedance Output...
CLINEA 0000H 0001H 0E6EH 0002H 003BH
	sb	0f263h.1

;;	PC1C0  = 1;	
CLINEA 0000H 0001H 0E6FH 0002H 000DH
	sb	0f262h.1

;;	PC2C1  = 1;		// PortC Bit2 set to High-Impedance Output...
CLINEA 0000H 0001H 0E70H 0002H 003BH
	sb	0f263h.2

;;	PC2C0  = 1;	
CLINEA 0000H 0001H 0E71H 0002H 000DH
	sb	0f262h.2

;;	PC3C1  = 1;		// PortC Bit3 set to High-Impedance Output...
CLINEA 0000H 0001H 0E72H 0002H 003BH
	sb	0f263h.3

;;	PC3C0  = 1;		
CLINEA 0000H 0001H 0E73H 0002H 000EH
	sb	0f262h.3

;;	PC4C1  = 1;		// PortC Bit4 set to High-Impedance Output...
CLINEA 0000H 0001H 0E74H 0002H 003BH
	sb	0f263h.4

;;	PC4C0  = 1;	
CLINEA 0000H 0001H 0E75H 0002H 000DH
	sb	0f262h.4

;;	PC5C1  = 1;		// PortC Bit5 set to High-Impedance Output...
CLINEA 0000H 0001H 0E76H 0002H 003BH
	sb	0f263h.5

;;	PC5C0  = 1;	
CLINEA 0000H 0001H 0E77H 0002H 000DH
	sb	0f262h.5

;;	PC6C1  = 1;		// PortC Bit6 set to High-Impedance Output...
CLINEA 0000H 0001H 0E78H 0002H 003BH
	sb	0f263h.6

;;	PC6C0  = 1;	
CLINEA 0000H 0001H 0E79H 0002H 000DH
	sb	0f262h.6

;;	PC7C1  = 1;		// PortC Bit7 set to High-Impedance Output...
CLINEA 0000H 0001H 0E7AH 0002H 003BH
	sb	0f263h.7

;;	PC7C0  = 1;	
CLINEA 0000H 0001H 0E7BH 0002H 000DH
	sb	0f262h.7

;;	PC0MD1  = 0;	// PortC Bit0 set to General Purpose Output...
CLINEA 0000H 0001H 0E7EH 0002H 003CH
	rb	0f265h.0

;;	PC0MD0  = 0;	
CLINEA 0000H 0001H 0E7FH 0002H 000EH
	rb	0f264h.0

;;	PC1MD1  = 0;	// PortC Bit1 set to General Purpose Output...
CLINEA 0000H 0001H 0E80H 0002H 003CH
	rb	0f265h.1

;;	PC1MD0  = 0;	
CLINEA 0000H 0001H 0E81H 0002H 000EH
	rb	0f264h.1

;;	PC2MD1  = 0;	// PortC Bit2 set to General Purpose Output...
CLINEA 0000H 0001H 0E82H 0002H 003CH
	rb	0f265h.2

;;	PC2MD0  = 0;	
CLINEA 0000H 0001H 0E83H 0002H 000EH
	rb	0f264h.2

;;	PC3MD1  = 0;	// PortC Bit3 set to General Purpose Output...
CLINEA 0000H 0001H 0E84H 0002H 003CH
	rb	0f265h.3

;;	PC3MD0  = 0;	
CLINEA 0000H 0001H 0E85H 0002H 000EH
	rb	0f264h.3

;;	PC4MD1  = 0;	// PortC Bit4 set to General Purpose Output...
CLINEA 0000H 0001H 0E86H 0002H 003CH
	rb	0f265h.4

;;	PC4MD0  = 0;	
CLINEA 0000H 0001H 0E87H 0002H 000EH
	rb	0f264h.4

;;	PC5MD1  = 0;	// PortC Bit5 set to General Purpose Output...
CLINEA 0000H 0001H 0E88H 0002H 003CH
	rb	0f265h.5

;;	PC5MD0  = 0;
CLINEA 0000H 0001H 0E89H 0002H 000DH
	rb	0f264h.5

;;	PC6MD1  = 0;	// PortC Bit6 set to General Purpose Output...
CLINEA 0000H 0001H 0E8AH 0002H 003CH
	rb	0f265h.6

;;	PC6MD0  = 0;	
CLINEA 0000H 0001H 0E8BH 0002H 000EH
	rb	0f264h.6

;;	PC7MD1  = 0;	// PortC Bit7 set to General Purpose Output...
CLINEA 0000H 0001H 0E8CH 0002H 003CH
	rb	0f265h.7

;;	PC7MD0  = 0;
CLINEA 0000H 0001H 0E8DH 0002H 000DH
	rb	0f264h.7

;;	PC0D = 0;		// C.0 Output OFF....
CLINEA 0000H 0001H 0E90H 0002H 0021H
	rb	0f260h.0

;;	PC1D = 0;		// C.1 Output OFF....
CLINEA 0000H 0001H 0E91H 0002H 0021H
	rb	0f260h.1

;;	PC2D = 0;		// C.2 Output OFF....
CLINEA 0000H 0001H 0E92H 0002H 0021H
	rb	0f260h.2

;;	PC4D = 0;		// C.4 Output OFF....
CLINEA 0000H 0001H 0E94H 0002H 0021H
	rb	0f260h.4

;;	PC5D = 0;		// C.5 Output OFF....
CLINEA 0000H 0001H 0E95H 0002H 0021H
	rb	0f260h.5

;;	PC6D = 0;		// C.6 Output OFF....
CLINEA 0000H 0001H 0E96H 0002H 0021H
	rb	0f260h.6

;;	PC7D = 0;		// C.7 Output OFF....
CLINEA 0000H 0001H 0E97H 0002H 0021H
	rb	0f260h.7

;;	main_clrWDT(); 	// Clear WDT
CLINEA 0000H 0001H 0E99H 0002H 001DH
	b	_main_clrWDT
CBLOCKEND 212 2 3739
CLINEA 0000H 0001H 0E9BH 0001H 0001H
CBLOCKEND 212 1 3739
CFUNCTIONEND 212


	rseg $$PortD_Low$main
CFUNCTION 213

_PortD_Low	:
CBLOCK 213 1 3745

;;void PortD_Low(void){
CLINEA 0000H 0001H 0EA1H 0001H 0015H
CBLOCK 213 2 3745

;;	PD0DIR = 0;		// PortD Bit0 set to Output Mode...
CLINEA 0000H 0001H 0EAAH 0002H 0031H
	rb	0f269h.0

;;	PD1DIR = 0;		// PortD Bit1 set to Output Mode...
CLINEA 0000H 0001H 0EABH 0002H 0031H
	rb	0f269h.1

;;	PD2DIR = 0;		// PortD Bit2 set to Output Mode...
CLINEA 0000H 0001H 0EACH 0002H 0031H
	rb	0f269h.2

;;	PD3DIR = 0;		// PortD Bit3 set to Output Mode...
CLINEA 0000H 0001H 0EADH 0002H 0031H
	rb	0f269h.3

;;	PD4DIR = 0;		// PortD Bit4 set to Output Mode...
CLINEA 0000H 0001H 0EAEH 0002H 0031H
	rb	0f269h.4

;;	PD5DIR = 0;		// PortD Bit5 set to Output Mode...
CLINEA 0000H 0001H 0EAFH 0002H 0031H
	rb	0f269h.5

;;	PD0C1= 1;		// PortD Bit0 set to CMOS Output...
CLINEA 0000H 0001H 0EB2H 0002H 002FH
	sb	0f26bh.0

;;	PD0C0= 1;		
CLINEA 0000H 0001H 0EB3H 0002H 000CH
	sb	0f26ah.0

;;	PD1C1= 1;		// PortD Bit1 set to CMOS Output...
CLINEA 0000H 0001H 0EB4H 0002H 002FH
	sb	0f26bh.1

;;	PD1C0= 1;	
CLINEA 0000H 0001H 0EB5H 0002H 000BH
	sb	0f26ah.1

;;	PD2C1= 1;		// PortD Bit2 set to CMOS Output...
CLINEA 0000H 0001H 0EB6H 0002H 002FH
	sb	0f26bh.2

;;	PD2C0= 1;	
CLINEA 0000H 0001H 0EB7H 0002H 000BH
	sb	0f26ah.2

;;	PD3C1= 1;		// PortD Bit3 set to CMOS Output...
CLINEA 0000H 0001H 0EB8H 0002H 002FH
	sb	0f26bh.3

;;	PD3C0= 1;		
CLINEA 0000H 0001H 0EB9H 0002H 000CH
	sb	0f26ah.3

;;	PD4C1= 1;		// PortD Bit4 set to CMOS Output...
CLINEA 0000H 0001H 0EBAH 0002H 002FH
	sb	0f26bh.4

;;	PD4C0= 1;	
CLINEA 0000H 0001H 0EBBH 0002H 000BH
	sb	0f26ah.4

;;	PD5C1= 1;		// PortD Bit5 set to CMOS Output...
CLINEA 0000H 0001H 0EBCH 0002H 002FH
	sb	0f26bh.5

;;	PD5C0= 1;	
CLINEA 0000H 0001H 0EBDH 0002H 000BH
	sb	0f26ah.5

;;	PD0D = 0;		// D.0 Output OFF....
CLINEA 0000H 0001H 0EC0H 0002H 0021H
	rb	0f268h.0

;;	PD1D = 0;		// D.1 Output OFF....
CLINEA 0000H 0001H 0EC1H 0002H 0021H
	rb	0f268h.1

;;	PD2D = 0;		// D.2 Output OFF....
CLINEA 0000H 0001H 0EC2H 0002H 0021H
	rb	0f268h.2

;;	PD3D = 0;		// D.3 Output OFF....
CLINEA 0000H 0001H 0EC3H 0002H 0021H
	rb	0f268h.3

;;	PD4D = 0;		// D.4 Output OFF....
CLINEA 0000H 0001H 0EC4H 0002H 0021H
	rb	0f268h.4

;;	PD5D = 0;		// D.5 Output OFF....
CLINEA 0000H 0001H 0EC5H 0002H 0021H
	rb	0f268h.5

;;	main_clrWDT(); 	// Clear WDT
CLINEA 0000H 0001H 0EC8H 0002H 001DH
	b	_main_clrWDT
CBLOCKEND 213 2 3786
CLINEA 0000H 0001H 0ECAH 0001H 0001H
CBLOCKEND 213 1 3786
CFUNCTIONEND 213


	rseg $$PortA_Digital_Inputs$main
CFUNCTION 214

_PortA_Digital_Inputs	:
CBLOCK 214 1 3792

;;void PortA_Digital_Inputs(void){
CLINEA 0000H 0001H 0ED0H 0001H 0020H
CBLOCK 214 2 3792

;;	PA0DIR = 1;		// PortA Bit0 set to Input Mode...
CLINEA 0000H 0001H 0EDAH 0002H 0030H
	sb	0f251h.0

;;	PA1DIR = 1;		// PortA Bit1 set to Input Mode...
CLINEA 0000H 0001H 0EDBH 0002H 0030H
	sb	0f251h.1

;;	PA2DIR = 1;		// PortA Bit2 set to Input Mode...
CLINEA 0000H 0001H 0EDCH 0002H 0030H
	sb	0f251h.2

;;	PA0C1  = 1;		// PortA Bit0 set to Input with Pull-Up Resistor...
CLINEA 0000H 0001H 0EE0H 0002H 0041H
	sb	0f253h.0

;;	PA0C0  = 0;		
CLINEA 0000H 0001H 0EE1H 0002H 000EH
	rb	0f252h.0

;;	PA1C1  = 1;		// PortA Bit1 set to Input with Pull-Up Resistor...
CLINEA 0000H 0001H 0EE2H 0002H 0041H
	sb	0f253h.1

;;	PA1C0  = 0;	
CLINEA 0000H 0001H 0EE3H 0002H 000DH
	rb	0f252h.1

;;	PA2C1  = 1;		// PortA Bit2 set to Input with Pull-Up Resistor...
CLINEA 0000H 0001H 0EE4H 0002H 0041H
	sb	0f253h.2

;;	PA2C0  = 0;	
CLINEA 0000H 0001H 0EE5H 0002H 000DH
	rb	0f252h.2

;;	PA0MD1  = 0;	// PortA Bit0 set to General Purpose I/O...
CLINEA 0000H 0001H 0EE8H 0002H 0039H
	rb	0f255h.0

;;	PA0MD0  = 0;	
CLINEA 0000H 0001H 0EE9H 0002H 000EH
	rb	0f254h.0

;;	PA1MD1  = 0;	// PortA Bit1 set to General Purpose I/O...
CLINEA 0000H 0001H 0EEAH 0002H 0039H
	rb	0f255h.1

;;	PA1MD0  = 0;	
CLINEA 0000H 0001H 0EEBH 0002H 000EH
	rb	0f254h.1

;;	PA2MD1  = 0;	// PortA Bit2 set to General Purpose I/O...
CLINEA 0000H 0001H 0EECH 0002H 0039H
	rb	0f255h.2

;;	PA2MD0  = 0;	
CLINEA 0000H 0001H 0EEDH 0002H 000EH
	rb	0f254h.2

;;	main_clrWDT(); 	// Clear WDT
CLINEA 0000H 0001H 0EEFH 0002H 001DH
	b	_main_clrWDT
CBLOCKEND 214 2 3825
CLINEA 0000H 0001H 0EF1H 0001H 0001H
CBLOCKEND 214 1 3825
CFUNCTIONEND 214


	rseg $$NOP$main
CFUNCTION 251

_NOP	:
CBLOCK 251 1 3888

;;{
CLINEA 0000H 0001H 0F30H 0001H 0001H
	push	lr
	push	xr4
	push	er8
	mov	r8,	r0
CBLOCK 251 2 3888
CRET 0006H
CARGUMENT 46H 0001H 001CH "sec" 02H 00H 00H
CLOCAL 46H 0002H 0027H 0002H "timerThres" 02H 00H 01H
CLOCAL 46H 0001H 0018H 0002H "TimeFlag" 02H 00H 00H
CLOCAL 46H 0001H 0016H 0002H "TempSec" 02H 00H 00H
CLOCAL 46H 0002H 0024H 0002H "timer" 02H 00H 01H
CLOCAL 4AH 0002H 0000H 0002H "timertest" 02H 00H 01H

;;	tm_init(TM_CH_NO_AB);
CLINEA 0000H 0001H 0F37H 0002H 0016H
	mov	r0,	#01h
	bl	_tm_init

;;	TempSec = sec;
CLINEA 0000H 0001H 0F38H 0002H 000FH
	mov	r2,	r8

;;	TimeFlag = 0;
CLINEA 0000H 0001H 0F39H 0002H 000EH
	mov	r4,	#00h

;;	tm_setABSource(TM_CS_LSCLK);
CLINEA 0000H 0000H 018DH 0002H 0015H
	rb	0f8eah.0

;;	tm_setABSource(TM_CS_LSCLK);
CLINEA 0000H 0000H 018EH 0002H 001AH
	rb	0f8eah.1

;;	tm_setABData(0xffff);
CLINEA 0000H 0000H 0157H 0002H 0025H
	mov	r0,	#0ffh
	st	r0,	0f8e8h

;;	tm_setABData(0xffff);
CLINEA 0000H 0000H 0158H 0002H 0023H
	st	r0,	0f8ech

;;	if(sec == 1){
CLINEA 0000H 0001H 0F3EH 0002H 000EH
	cmp	r8,	#01h
	bne	_$L738
CBLOCK 251 3 3902

;;		timerThres = 0x7FFF;
CLINEA 0000H 0001H 0F3FH 0003H 0016H
	mov	r6,	#0ffh
	mov	r7,	#07fh

;;		TimeFlag = 0;
CLINEA 0000H 0001H 0F40H 0003H 000FH
CBLOCKEND 251 3 3905

;;	}
CLINEA 0000H 0000H 0F41H 0002H 0002H
_$L738 :

;;	if(sec == 2){
CLINEA 0000H 0001H 0F42H 0002H 000EH
	cmp	r8,	#02h
	bne	_$L740
CBLOCK 251 4 3906

;;		timerThres = 0xFFFF;
CLINEA 0000H 0001H 0F43H 0003H 0016H
	mov	er6,	#-1

;;		TimeFlag = 0;
CLINEA 0000H 0001H 0F44H 0003H 000FH
	mov	r4,	#00h
CBLOCKEND 251 4 3909

;;	}
CLINEA 0000H 0000H 0F45H 0002H 0002H
_$L740 :

;;	if(sec > 2){
CLINEA 0000H 0001H 0F46H 0002H 000DH
	cmp	r8,	#02h
	ble	_$L750
CBLOCK 251 5 3910

;;	while(TempSec > 1){
CLINEA 0000H 0000H 0F47H 0001H 0001H
	bal	_$L760

;;	while(TempSec > 1){
CLINEA 0000H 0000H 0F47H 0002H 0014H
_$L746 :
CBLOCK 251 6 3911

;;		TempSec -= 2;
CLINEA 0000H 0001H 0F48H 0003H 000FH
	add	r2,	#0feh

;;		TimeFlag++;
CLINEA 0000H 0000H 0F49H 0003H 000DH
	add	r4,	#01h
CBLOCKEND 251 6 3914

;;	while(TempSec > 1){
CLINEA 0000H 0000H 0F47H 0001H 0001H
_$L760 :

;;	while(TempSec > 1){
CLINEA 0000H 0000H 0F47H 000EH 0013H
	cmp	r2,	#01h
	bgt	_$L746

;;	if(TempSec == 1){
CLINEA 0000H 0001H 0F4BH 0002H 0012H
	cmp	r2,	#01h
	bne	_$L748
CBLOCK 251 7 3915

;;		timerThres = 0x7FFF;
CLINEA 0000H 0001H 0F4CH 0003H 0016H
	mov	r6,	#0ffh
	mov	r7,	#07fh
CBLOCKEND 251 7 3917

;;	else{
CLINEA 0000H 0001H 0F4EH 0002H 0006H
	bal	_$L750
_$L748 :
CBLOCK 251 8 3918

;;		timerThres = 0xFFFF;
CLINEA 0000H 0001H 0F4FH 0003H 0016H
	mov	er6,	#-1

;;		TimeFlag--;
CLINEA 0000H 0000H 0F50H 0003H 000DH
	add	r4,	#0ffh
CBLOCKEND 251 8 3921

;;	}
CLINEA 0000H 0000H 0F51H 0002H 0002H
_$L750 :
CBLOCKEND 251 5 3922

;;	main_clrWDT();	
CLINEA 0000H 0001H 0F55H 0002H 0010H
	bl	_main_clrWDT

;;	tm_startAB();
CLINEA 0000H 0001H 00D1H 0002H 000AH
	mov	r0,	#00h
	st	r0,	0f8e9h

;;	tm_startAB();
CLINEA 0000H 0000H 00D2H 0002H 000BH
	sb	0f8ebh.0

;;	timer = tm_getABCounter();
CLINEA 0000H 0000H 0120H 0002H 001BH
	l	r0,	0f8e9h
	mov	r1,	#00h
	mov	er2,	er0

;;	timer = tm_getABCounter();
CLINEA 0000H 0000H 0121H 0002H 0014H
	l	r0,	0f8edh
	or	r3,	r0

;;	timer = tm_getABCounter();
CLINEA 0000H 0000H 0122H 0002H 000CH
	mov	er0,	er2

;;	while(timer < timerThres){
CLINEA 0000H 0001H 0F59H 0002H 001BH
	bal	_$L753
_$L755 :
CBLOCK 251 9 3929

;;		timer = tm_getABCounter();
CLINEA 0000H 0000H 0120H 0002H 001BH
	l	r0,	0f8e9h
	mov	r1,	#00h
	mov	er2,	er0

;;		timer = tm_getABCounter();
CLINEA 0000H 0000H 0121H 0002H 0014H
	l	r0,	0f8edh
	or	r3,	r0

;;		timer = tm_getABCounter();
CLINEA 0000H 0000H 0122H 0002H 000CH
	mov	er0,	er2

;;		timer = tm_getABCounter();
CLINEA 0000H 0000H 0F5AH 0003H 001CH
CBLOCKEND 251 9 3932

;;	}
CLINEA 0000H 0000H 0F5CH 0002H 0002H
_$L753 :

;;	while(timer < timerThres){
CLINEA 0000H 0000H 0F59H 000EH 0013H
	cmp	er0,	er6
	blt	_$L755

;;	if(TimeFlag !=0){
CLINEA 0000H 0001H 0F5DH 0002H 0012H
	cmp	r4,	#00h
	beq	_$L758

;;		tm_stopAB();
CLINEA 0000H 0001H 0105H 0002H 000BH
	rb	0f8ebh.0

;;		TimeFlag--;
CLINEA 0000H 0000H 0F5FH 0003H 000DH
	add	r4,	#0ffh

;;		timerThres = 0xFFFF;
CLINEA 0000H 0001H 0F60H 0003H 0016H
	mov	er6,	#-1

;;		goto TimerRestart;
CLINEA 0000H 0001H 0F61H 0003H 0014H
	bal	_$L750

;;	}
CLINEA 0000H 0000H 0F62H 0002H 0002H
_$L758 :
CBLOCKEND 251 2 3939

;;}
CLINEA 0000H 0001H 0F63H 0001H 0001H
	pop	er8
	pop	xr4
	pop	pc
CBLOCKEND 251 1 3939
CFUNCTIONEND 251


	rseg $$NOPms$main
CFUNCTION 252

_NOPms	:
CBLOCK 252 1 3952

;;{
CLINEA 0000H 0001H 0F70H 0001H 0001H
	push	lr
	push	xr4
	push	bp
	push	er8
	mov	er8,	er0
CBLOCK 252 2 3952
CRET 0008H
CARGUMENT 46H 0002H 0028H "ms" 02H 00H 01H
CLOCAL 46H 0002H 002AH 0002H "timerThres" 02H 00H 01H
CLOCAL 46H 0001H 001AH 0002H "TimeFlag" 02H 00H 00H
CLOCAL 46H 0002H 0026H 0002H "TempSec" 02H 00H 01H
CLOCAL 46H 0002H 0024H 0002H "timer" 02H 00H 01H
CLOCAL 4AH 0002H 0000H 0002H "timertest" 02H 00H 01H

;;TempSec = ms;
CLINEA 0000H 0001H 0F77H 0001H 000DH
	mov	er4,	er0

;;TimeFlag = 0;
CLINEA 0000H 0001H 0F78H 0001H 000DH
	mov	r6,	#00h

;;tm_init(TM_CH_NO_AB);
CLINEA 0000H 0001H 0F7AH 0001H 0015H
	mov	r0,	#01h
	bl	_tm_init

;;tm_setABSource(TM_CS_HTBCLK);
CLINEA 0000H 0000H 018DH 0002H 0015H
	sb	0f8eah.0

;;tm_setABSource(TM_CS_HTBCLK);
CLINEA 0000H 0000H 018EH 0002H 001AH
	rb	0f8eah.1

;;tm_setABData(0xffff);
CLINEA 0000H 0000H 0157H 0002H 0025H
	mov	r0,	#0ffh
	st	r0,	0f8e8h

;;tm_setABData(0xffff);
CLINEA 0000H 0000H 0158H 0002H 0023H
	st	r0,	0f8ech

;;if(ms < 128){
CLINEA 0000H 0001H 0F7EH 0001H 000DH
	mov	er0,	er8
	cmp	r8,	#080h
	cmpc	r9,	#00h
	bge	_$L762
CBLOCK 252 3 3966

;;	timerThres = 0x1FF * ms;
CLINEA 0000H 0001H 0F7FH 0002H 0019H
	sllc	r1,	#07h
	sll	r0,	#07h
	sllc	r1,	#02h
	sll	r0,	#02h
	sub	r0,	r8
	subc	r1,	r9
	mov	bp,	er0

;;	TimeFlag = 0;
CLINEA 0000H 0001H 0F80H 0002H 000EH
CBLOCKEND 252 3 3969

;;}
CLINEA 0000H 0000H 0F81H 0001H 0001H
_$L762 :

;;if(ms == 128){
CLINEA 0000H 0001H 0F82H 0001H 000EH
	cmp	r8,	#080h
	cmpc	r9,	#00h
	bne	_$L764
CBLOCK 252 4 3970

;;	timerThres = 0xFFFF;
CLINEA 0000H 0001H 0F83H 0002H 0015H
	mov	bp,	#-1

;;	TimeFlag = 0;
CLINEA 0000H 0001H 0F84H 0002H 000EH
	mov	r6,	#00h
CBLOCKEND 252 4 3973

;;}
CLINEA 0000H 0000H 0F85H 0001H 0001H
_$L764 :

;;if(ms > 128){
CLINEA 0000H 0001H 0F86H 0001H 000DH
	cmp	r8,	#080h
	cmpc	r9,	#00h
	ble	_$L774
CBLOCK 252 5 3974

;;	while(TempSec > 128){
CLINEA 0000H 0000H 0F87H 0001H 0001H
	bal	_$L784

;;	while(TempSec > 128){
CLINEA 0000H 0000H 0F87H 0002H 0016H
_$L770 :
CBLOCK 252 6 3975

;;		TempSec -= 128;
CLINEA 0000H 0001H 0F88H 0003H 0011H
	add	r0,	#080h
	addc	r1,	#0ffh
	mov	er4,	er0

;;		TimeFlag++;
CLINEA 0000H 0000H 0F89H 0003H 000DH
	add	r6,	#01h
CBLOCKEND 252 6 3978

;;	while(TempSec > 128){
CLINEA 0000H 0000H 0F87H 0001H 0001H
_$L784 :

;;	while(TempSec > 128){
CLINEA 0000H 0000H 0F87H 000EH 0013H
	mov	er0,	er4
	cmp	r4,	#080h
	cmpc	r5,	#00h
	bgt	_$L770

;;	if(TempSec != 0){
CLINEA 0000H 0001H 0F8BH 0002H 0012H
	mov	er4,	er4
	beq	_$L772
CBLOCK 252 7 3979

;;		timerThres = 0x1FF * TempSec;
CLINEA 0000H 0001H 0F8CH 0003H 001FH
	sllc	r1,	#07h
	sll	r0,	#07h
	sllc	r1,	#02h
	sll	r0,	#02h
	sub	r0,	r4
	subc	r1,	r5
	mov	bp,	er0
CBLOCKEND 252 7 3981

;;	else{
CLINEA 0000H 0001H 0F8EH 0002H 0006H
	bal	_$L774
_$L772 :
CBLOCK 252 8 3982

;;		timerThres = 0xFFFF;
CLINEA 0000H 0001H 0F8FH 0003H 0016H
	mov	bp,	#-1

;;		TimeFlag--;
CLINEA 0000H 0000H 0F90H 0003H 000DH
	add	r6,	#0ffh
CBLOCKEND 252 8 3985

;;	}
CLINEA 0000H 0000H 0F91H 0002H 0002H
_$L774 :
CBLOCKEND 252 5 3986

;;	main_clrWDT();	
CLINEA 0000H 0001H 0F95H 0002H 0010H
	bl	_main_clrWDT

;;	tm_startAB();
CLINEA 0000H 0001H 00D1H 0002H 000AH
	mov	r0,	#00h
	st	r0,	0f8e9h

;;	tm_startAB();
CLINEA 0000H 0000H 00D2H 0002H 000BH
	sb	0f8ebh.0

;;	timer = tm_getABCounter();
CLINEA 0000H 0000H 0120H 0002H 001BH
	l	r0,	0f8e9h
	mov	r1,	#00h
	mov	er2,	er0

;;	timer = tm_getABCounter();
CLINEA 0000H 0000H 0121H 0002H 0014H
	l	r0,	0f8edh
	or	r3,	r0

;;	timer = tm_getABCounter();
CLINEA 0000H 0000H 0122H 0002H 000CH
	mov	er0,	er2

;;	while(timer < timerThres){
CLINEA 0000H 0001H 0F99H 0002H 001BH
	bal	_$L777
_$L779 :
CBLOCK 252 9 3993

;;		timer = tm_getABCounter();
CLINEA 0000H 0000H 0120H 0002H 001BH
	l	r0,	0f8e9h
	mov	r1,	#00h
	mov	er2,	er0

;;		timer = tm_getABCounter();
CLINEA 0000H 0000H 0121H 0002H 0014H
	l	r0,	0f8edh
	or	r3,	r0

;;		timer = tm_getABCounter();
CLINEA 0000H 0000H 0122H 0002H 000CH
	mov	er0,	er2

;;		timer = tm_getABCounter();
CLINEA 0000H 0000H 0F9AH 0003H 001CH
CBLOCKEND 252 9 3996

;;	}
CLINEA 0000H 0000H 0F9CH 0002H 0002H
_$L777 :

;;	while(timer < timerThres){
CLINEA 0000H 0000H 0F99H 000EH 0013H
	cmp	er0,	bp
	blt	_$L779

;;	if(TimeFlag !=0){
CLINEA 0000H 0001H 0F9DH 0002H 0012H
	cmp	r6,	#00h
	beq	_$L782

;;		tm_stopAB();
CLINEA 0000H 0001H 0105H 0002H 000BH
	rb	0f8ebh.0

;;		TimeFlag--;
CLINEA 0000H 0000H 0F9FH 0003H 000DH
	add	r6,	#0ffh

;;		timerThres = 0xFFFF;
CLINEA 0000H 0001H 0FA0H 0003H 0016H
	mov	bp,	#-1

;;		goto TimerRestart;
CLINEA 0000H 0001H 0FA1H 0003H 0014H
	bal	_$L774

;;	}
CLINEA 0000H 0000H 0FA2H 0002H 0002H
_$L782 :
CBLOCKEND 252 2 4004

;;}
CLINEA 0000H 0001H 0FA4H 0001H 0001H
	pop	er8
	pop	bp
	pop	xr4
	pop	pc
CBLOCKEND 252 1 4004
CFUNCTIONEND 252


	rseg $$NOPus$main
CFUNCTION 253

_NOPus	:
CBLOCK 253 1 4014

;;{
CLINEA 0000H 0001H 0FAEH 0001H 0001H
CBLOCK 253 2 4014

;;	timer_us = 0;
CLINEA 0000H 0001H 0FAFH 0002H 000EH
	mov	er0,	#0 
	st	er0,	NEAR _timer_us

;;	TM8C = 0x00;
CLINEA 0000H 0001H 0FB0H 0002H 000DH
	st	r0,	0f8e1h

;;	ETM8 = 1;
CLINEA 0000H 0001H 0FB1H 0002H 000AH
	sb	0f013h.2

;;	while(timer_us == 0);
CLINEA 0000H 0000H 0FB2H 0002H 0016H
_$L788 :

;;	while(timer_us == 0);
CLINEA 0000H 0000H 0FB2H 000EH 0013H
	l	er0,	NEAR _timer_us
	beq	_$L788
CBLOCKEND 253 2 4019

;;}
CLINEA 0000H 0001H 0FB3H 0001H 0001H
	rt
CBLOCKEND 253 1 4019
CFUNCTIONEND 253


	rseg $$NOP1000$main
CFUNCTION 254

_NOP1000	:
CBLOCK 254 1 4022

;;{
CLINEA 0000H 0001H 0FB6H 0001H 0001H
CBLOCK 254 2 4022
CLOCAL 4AH 0002H 0000H 0002H "ONCNT" 02H 00H 01H
CBLOCKEND 254 2 4028

;;}
CLINEA 0000H 0001H 0FBCH 0001H 0001H
	rt
CBLOCKEND 254 1 4028
CFUNCTIONEND 254


	rseg $$approx_arctan2$main
CFUNCTION 255

_approx_arctan2	:
CBLOCK 255 1 4031

;;{
CLINEA 0000H 0001H 0FBFH 0001H 0001H
	push	lr
	push	fp
	mov	fp,	sp
	add	sp,	#-028
	push	xr8
	push	xr4
	mov	er8,	er0
	mov	er10,	er2
CBLOCK 255 2 4031
CRET 0026H
CARGUMENT 47H 0004H 2928H "y" 02H 00H 03H
CARGUMENT 43H 0004H 0004H "x" 02H 00H 03H
CLOCAL 43H 0004H 001CH 0002H "YoverX" 02H 00H 03H
CLOCAL 47H 0004H 2726H 0002H "result" 02H 00H 03H

;;	float YoverX = y/x;
CLINEA 0000H 0001H 0FC0H 0002H 0014H
	push	xr0
	l	er0,	4[fp]
	l	er2,	6[fp]
	push	xr0
	bl	__fdivu8sw
	add	sp,	#4 
	pop	xr0
	st	er0,	-28[fp]
	st	er2,	-26[fp]

;;	float result = 0;
CLINEA 0000H 0001H 0FC1H 0002H 0012H
	mov	er4,	#0 
	mov	er6,	#0 

;;	if(x>0){
CLINEA 0000H 0001H 0FC3H 0002H 0009H
	l	er0,	4[fp]
	l	er2,	6[fp]
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bgt	_$M82
	b	_$L796
_$M82 :
CBLOCK 255 3 4035

;;		result = (0.97239*YoverX)-(0.19195*pow(YoverX,3));
CLINEA 0000H 0000H 0FC4H 0003H 0034H
	l	er0,	-28[fp]
	l	er2,	-26[fp]
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	pop	qr0
	lea	-8[fp]
	st	qr0,	[ea]
	push	qr0
	mov	r0,	#059h
	mov	r1,	#0a3h
	mov	r2,	#01eh
	mov	r3,	#0a2h
	mov	r4,	#0d1h
	mov	r5,	#01dh
	mov	r6,	#0efh
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	pop	qr0
	lea	-16[fp]
	st	qr0,	[ea]
	mov	er0,	#0 
	mov	er2,	#0 
	mov	er4,	#0 
	mov	r6,	#08h
	mov	r7,	#040h
	push	qr0
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	er0,	fp
	add	er0,	#-24
	bl	_pow
	add	sp,	#16
	lea	-16[fp]
	l	qr0,	[ea]
	push	qr0
	lea	-24[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#036h
	mov	r1,	#0cdh
	mov	r2,	#03bh
	mov	r3,	#04eh
	mov	r4,	#0d1h
	mov	r5,	#091h
	mov	r6,	#0c8h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dsubu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	mov	er4,	er0
	mov	er6,	er2
CBLOCKEND 255 3 4037

;;	}
CLINEA 0000H 0000H 0FC5H 0002H 0002H
_$L796 :

;;	if((x<0)&&(y>=0)){
CLINEA 0000H 0001H 0FC6H 0002H 0013H
	l	er0,	4[fp]
	l	er2,	6[fp]
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$M83
	b	_$L798
_$M83 :
	push	xr8
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$M84
	b	_$L798
_$M84 :
CBLOCK 255 4 4038

;;		result = (0.97239*YoverX)-(0.19195*pow(YoverX,3))+3.14;
CLINEA 0000H 0000H 0FC7H 0003H 0039H
	l	er0,	-28[fp]
	l	er2,	-26[fp]
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	pop	qr0
	lea	-8[fp]
	st	qr0,	[ea]
	push	qr0
	mov	r0,	#059h
	mov	r1,	#0a3h
	mov	r2,	#01eh
	mov	r3,	#0a2h
	mov	r4,	#0d1h
	mov	r5,	#01dh
	mov	r6,	#0efh
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	pop	qr0
	lea	-16[fp]
	st	qr0,	[ea]
	mov	er0,	#0 
	mov	er2,	#0 
	mov	er4,	#0 
	mov	r6,	#08h
	mov	r7,	#040h
	push	qr0
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	er0,	fp
	add	er0,	#-24
	bl	_pow
	add	sp,	#16
	lea	-16[fp]
	l	qr0,	[ea]
	push	qr0
	lea	-24[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#036h
	mov	r1,	#0cdh
	mov	r2,	#03bh
	mov	r3,	#04eh
	mov	r4,	#0d1h
	mov	r5,	#091h
	mov	r6,	#0c8h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dsubu8sw
	add	sp,	#8 
	mov	r0,	#01fh
	mov	r1,	#085h
	mov	r2,	#0ebh
	mov	r3,	#051h
	mov	r4,	#0b8h
	mov	r5,	#01eh
	mov	r6,	#09h
	mov	r7,	#040h
	push	qr0
	bl	__daddu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	mov	er4,	er0
	mov	er6,	er2
CBLOCKEND 255 4 4040

;;	}	
CLINEA 0000H 0000H 0FC8H 0002H 0003H
_$L798 :

;;	if((y<0)&&(x<0)){
CLINEA 0000H 0001H 0FC9H 0002H 0012H
	push	xr8
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$M85
	b	_$L805
_$M85 :
	l	er0,	4[fp]
	l	er2,	6[fp]
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	blt	_$M86
	b	_$L805
_$M86 :
CBLOCK 255 5 4041

;;		result = (0.97239*YoverX)-(0.19195*pow(YoverX,3))-3.14;
CLINEA 0000H 0000H 0FCAH 0003H 0039H
	l	er0,	-28[fp]
	l	er2,	-26[fp]
	push	xr0
	add	sp,	#-4
	bl	__ftodu8sw
	pop	qr0
	lea	-8[fp]
	st	qr0,	[ea]
	push	qr0
	mov	r0,	#059h
	mov	r1,	#0a3h
	mov	r2,	#01eh
	mov	r3,	#0a2h
	mov	r4,	#0d1h
	mov	r5,	#01dh
	mov	r6,	#0efh
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	pop	qr0
	lea	-16[fp]
	st	qr0,	[ea]
	mov	er0,	#0 
	mov	er2,	#0 
	mov	er4,	#0 
	mov	r6,	#08h
	mov	r7,	#040h
	push	qr0
	lea	-8[fp]
	l	qr0,	[ea]
	push	qr0
	mov	er0,	fp
	add	er0,	#-24
	bl	_pow
	add	sp,	#16
	lea	-16[fp]
	l	qr0,	[ea]
	push	qr0
	lea	-24[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#036h
	mov	r1,	#0cdh
	mov	r2,	#03bh
	mov	r3,	#04eh
	mov	r4,	#0d1h
	mov	r5,	#091h
	mov	r6,	#0c8h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dsubu8sw
	add	sp,	#8 
	mov	r0,	#01fh
	mov	r1,	#085h
	mov	r2,	#0ebh
	mov	r3,	#051h
	mov	r4,	#0b8h
	mov	r5,	#01eh
	mov	r6,	#09h
	mov	r7,	#0c0h
	push	qr0
	bl	__daddu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	mov	er4,	er0
	mov	er6,	er2
CBLOCKEND 255 5 4043

;;	}
CLINEA 0000H 0000H 0FCBH 0002H 0002H
_$L805 :

;;	if((y>0)&&(x==0)){
CLINEA 0000H 0001H 0FCCH 0002H 0013H
	push	xr8
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L812
	l	er0,	4[fp]
	l	er2,	6[fp]
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bne	_$L812
CBLOCK 255 6 4044

;;		result = 1.57;
CLINEA 0000H 0001H 0FCDH 0003H 0010H
	mov	r0,	#0c3h
	mov	r1,	#0f5h
	mov	r2,	#0c8h
	mov	r3,	#03fh
	mov	er4,	er0
	mov	er6,	er2
CBLOCKEND 255 6 4046

;;	}
CLINEA 0000H 0000H 0FCEH 0002H 0002H
_$L812 :

;;	if((y<0)&&(x==0)){
CLINEA 0000H 0001H 0FCFH 0002H 0013H
	push	xr8
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L819
	l	er0,	4[fp]
	l	er2,	6[fp]
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bne	_$L819
CBLOCK 255 7 4047

;;		result = -1.57;
CLINEA 0000H 0001H 0FD0H 0003H 0011H
	mov	r0,	#0c3h
	mov	r1,	#0f5h
	mov	r2,	#0c8h
	mov	r3,	#0bfh
	mov	er4,	er0
	mov	er6,	er2
CBLOCKEND 255 7 4049

;;	}
CLINEA 0000H 0000H 0FD1H 0002H 0002H
_$L819 :

;;	if((x==0)&&(y==0)){			//we made this up....
CLINEA 0000H 0001H 0FD2H 0002H 002CH
	l	er0,	4[fp]
	l	er2,	6[fp]
	push	xr0
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bne	_$L826
	push	xr8
	mov	er0,	#0 
	mov	er2,	#0 
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bne	_$L826
CBLOCK 255 8 4050

;;		result = (0.97239*YoverX)-(0.19195*pow(YoverX,3));
CLINEA 0000H 0000H 0FD6H 0003H 0034H
	mov	er0,	#0 
	mov	er2,	#0 
	mov	er4,	#0 
	mov	r6,	#08h
	mov	r7,	#040h
	push	qr0
	mov	r6,	#0f0h
	mov	r7,	#03fh
	push	qr0
	mov	er0,	fp
	add	er0,	#-16
	bl	_pow
	add	sp,	#16
	mov	r0,	#059h
	mov	r1,	#0a3h
	mov	r2,	#01eh
	mov	r3,	#0a2h
	mov	r4,	#0d1h
	mov	r5,	#01dh
	mov	r6,	#0efh
	push	qr0
	lea	-16[fp]
	l	qr0,	[ea]
	push	qr0
	mov	r0,	#036h
	mov	r1,	#0cdh
	mov	r2,	#03bh
	mov	r3,	#04eh
	mov	r4,	#0d1h
	mov	r5,	#091h
	mov	r6,	#0c8h
	mov	r7,	#03fh
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dsubu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	mov	er4,	er0
	mov	er6,	er2
CBLOCKEND 255 8 4055

;;	}
CLINEA 0000H 0000H 0FD7H 0002H 0002H
_$L826 :

;;	result *= 57.29;
CLINEA 0000H 0001H 0FD8H 0002H 0011H
	push	xr4
	add	sp,	#-4
	bl	__ftodu8sw
	mov	r0,	#085h
	mov	r1,	#0ebh
	mov	r2,	#051h
	mov	r3,	#0b8h
	mov	r4,	#01eh
	mov	r5,	#0a5h
	mov	r6,	#04ch
	mov	r7,	#040h
	push	qr0
	bl	__dmulu8sw
	add	sp,	#8 
	bl	__dtofu8sw
	add	sp,	#4 
	pop	xr0
	mov	er4,	er0
	mov	er6,	er2

;;	if(result > 45){
CLINEA 0000H 0001H 0FDAH 0002H 0011H
	push	xr0
	mov	er0,	#0 
	mov	r2,	#034h
	mov	r3,	#042h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	ble	_$L833
CBLOCK 255 9 4058

;;		result = 45;
CLINEA 0000H 0001H 0FDBH 0003H 000EH
	mov	r2,	#034h
	mov	r3,	#042h
	mov	er4,	#0 
	mov	er6,	er2
CBLOCKEND 255 9 4060

;;	}
CLINEA 0000H 0000H 0FDCH 0002H 0002H
_$L833 :

;;	if(result < -45){
CLINEA 0000H 0001H 0FDDH 0002H 0012H
	push	xr4
	mov	er0,	#0 
	mov	r2,	#034h
	mov	r3,	#0c2h
	push	xr0
	bl	__fcmpu8sw
	add	sp,	#8 
	mov	psw,	r0
	bge	_$L835
CBLOCK 255 10 4061

;;		result = -45;
CLINEA 0000H 0001H 0FDEH 0003H 000FH
	mov	r2,	#034h
	mov	r3,	#0c2h
	mov	er4,	#0 
	mov	er6,	er2
CBLOCKEND 255 10 4063

;;	}
CLINEA 0000H 0000H 0FDFH 0002H 0002H
_$L835 :

;;	return(result);
CLINEA 0000H 0001H 0FE1H 0002H 0010H
	mov	er0,	er4
	mov	er2,	er6
CBLOCKEND 255 2 4066

;;}
CLINEA 0000H 0000H 0FE2H 0001H 0001H
	pop	xr4
	pop	xr8
	mov	sp,	fp
	pop	fp
	pop	pc
CBLOCKEND 255 1 4066
CFUNCTIONEND 255


	rseg $$NVARmain
_$ST0 :
	ds	02h
	public _AccelSensorControlPID_D
	public _AccelSensorControlPID_I
	public _AccelSensorControlPID_P
	public _Shutdown
	public _NOPms
	public _NOPus
	public _approx_arctan2
	public _checkI2C
	public _main_clrWDT
	public _Accel_PID_XYChangeFlag
	public _main_reqNotHalt
	public _ReturnMagData
	public _DistanceSensorControl
	public _RangeSensorControlPID
	public _PortA_Digital_Inputs
	public _MagSensorControl
	public _ESC2_PWM
	public _Get_AccGyroData
	public _main
	public _MagSensorControlPID
	public _ClearVariables
	public _PortD_Low
	public _NOP1000
	public _ESC1_PWM
	public _CheckSafetyLimitUnscaled
	public _CalibrateAccel
	public _Get_RangeData
	public _PortC_Low
	public _CheckSafetyLimit
	public _ESC4_PWM
	public _Get_MagData
	public _UARTTunePID
	public _Get_PingData
	public _SerialOutCoefficients
	public _PortB_Low
	public _CalibrateMotors
	public _ReturnAccelData
	public _ESC3_PWM
	public _CalibrateGyro
	public _RampUpMotorTest
	public _NOP
	public _Emit_Warning
	public _InitializeTone
	public _PortA_Low
	public _analog_comparator
	public _Run_AccGyroCF
	public _SoftStart
	public _ReturnSensorData
	__flgUartFin comm data 01h #00h
	__flgI2CFin comm data 01h #00h
	__reqNotHalt comm data 01h #00h
	extrn code near : _abs
	extrn code near : _irq_init
	extrn code near : _uart_PortSet
	extrn code near : _i2c_stop
	extrn code near : _i2c_startReceive
	extrn code near : _uart_startReceive
	extrn code near : _pow
	extrn code near : _atan
	extrn code near : _uart_init
	extrn code near : _i2c_continue
	extrn code near : _irq_di
	extrn code near : _irq_ei
	extrn code near : _sscanf_nn
	extrn code near : _irq_setHdr
	extrn code near : _sprintf_nn
	extrn code near : _uart_stop
	extrn code near : _uart_startSend
	extrn code near : _i2c_startSend
	extrn code near : _uart_continue
	extrn code near : _atan2
	extrn code near : _i2c_init
	extrn code near : _tm_init
	extrn code : $$start_up

	cseg #00h at 02h
	dw	$$start_up

	rseg $$NINITTAB
	db	068h
	db	06bh
	db	00h
	db	01ch
	db	00h
	align
	dw	00h
	dw	04680h
	db	01bh
	db	08h
	dw	0126fh
	dw	04283h
	db	01ah
	db	04h
	db	019h
	db	013h
	db	038h
	db	01h
	db	00h
	db	00h
	db	03bh
	align
	dw	00h
	dw	00h
	db	00h
	db	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	db	01eh
	db	00h
	db	078h
	db	01h
	db	060h
	db	02h
	db	01h
	db	03h
	db	09h
	align
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	08f5ch
	dw	03fc2h
	dw	0126fh
	dw	0be03h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	db	070h
	db	051h
	dw	00h
	dw	0ah
	dw	0ah
	dw	00h
	dw	0428ch
	dw	00h
	dw	04248h
	dw	00h
	dw	04370h
	dw	047aeh
	dw	0bde1h
	dw	047aeh
	dw	03de1h
	dw	047aeh
	dw	0bde1h
	dw	047aeh
	dw	03de1h
	dw	00h
	dw	03f80h
	dw	08000h
	dw	043b3h
	dw	00h
	dw	04334h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	03ec0h
	dw	00h
	dw	00h
	dw	0999ah
	dw	03f59h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	051ech
	dw	03f78h
	dw	0c28fh
	dw	03cf5h
	db	00h
	db	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	db	01h
	align
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	03f80h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	0424ch
	dw	00h
	dw	04138h
	dw	00h
	dw	04188h
	dw	00h
	dw	0424ch
	dw	00h
	dw	04138h
	dw	00h
	dw	04188h
	db	00h
	db	00h
	db	00h
	align
	dw	03fffh
	dw	03fffh
	dw	03fffh
	dw	03fffh
	db	00h
	align
	dw	00h
	dw	0428ch
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	db	00h
	db	00h
	dw	03a98h
	dw	01f40h
	dw	020d0h
	dw	04268h
	db	00h
	db	00h
	dw	00h
	dw	03a98h
	dw	02904h
	dw	02134h
	dw	0ff88h
	dw	0ff9ch
	dw	032h
	dw	00h
	db	00h
	align
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h
	dw	00h

	rseg $$TAB_uartSetParam$main
__uartSetParam :
	dw	0e100h
	dw	00h
	db	00h
	db	02h
	db	00h
	db	00h
	db	00h
	align

	rseg $$TAB$$S243$main
$$S243 :
	DB	"%f,%f,%f,%f,%f,%f,%f,%u", 00H

	rseg $$TAB$$S256$main
$$S256 :
	DB	"%f,%f,%f", 00H

	rseg $$TAB$$S269$main
$$S269 :
	DB	"%f", 00H

	rseg $$TAB$$S287$main
$$S287 :
	DB	"Gyro Calibration: Please Keep the Quad Flat and Return Any 2 chars to Start", 00H

	rseg $$TAB$$S316$main
$$S316 :
	DB	"Gyro Calibration Complete!", 00H

	rseg $$TAB$$S332$main
$$S332 :
	DB	"Accel Calibration: Keep Quad Flat! Return any 2 chars to Start", 00H

	rseg $$TAB$$S363$main
$$S363 :
	DB	"Accel Calibration: Tilt the Quad 90deg in the ROLL Direction! Return any 2 chars to Start", 00H

	rseg $$TAB$$S388$main
$$S388 :
	DB	"Accel Calibration: Tilt the Quad 90deg in the PITCH direction! Return any 2 chars to Start", 00H

	rseg $$TAB$$S413$main
$$S413 :
	DB	"Accel Calibration Complete!", 00H

	rseg $$TAB$$S435$main
$$S435 :
	DB	"Current Settings: kp=%f,ki=%f,kd=%f,a1=%f,a2=%f,Pb=%u,Db=%u", 00H

	rseg $$TAB$$S491$main
$$S491 :
	DB	"    New Settings: kp=%f,ki=%f,kd=%f,a1=%f,a2=%f,Pb=%u,Db=%u", 00H

	rseg $$TAB$$S569$main
$$S569 :
	DB	"%f,%f,%f,%f", 00H

	rseg $$NINITVAR
_MPU6050Address :
	ds	01h
_AccGyro_PWRMGMT1REG :
	ds	01h
_AccGyro_PWRMGMT1REG_Contents :
	ds	01h
_AccGyro_AccelConfig :
	ds	01h
_AccGyro_AccelConfig_Contents :
	ds	01h
	align
_AccGyro_AccelScaling :
	ds	04h
_AccGyro_GyroConfig :
	ds	01h
_AccGyro_GyroConfig_Contents :
	ds	01h
_AccGyro_GyroScaling :
	ds	04h
_AccGyro_GyroAccelLPF :
	ds	01h
_AccGyro_GyroAccelLPF_Contents :
	ds	01h
_AccGyro_GyroAccel_SMPRTDIV :
	ds	01h
_AccGyro_GyroAccelLPF_SMPRTDIVCo :
	ds	01h
_AccGyro_INTENABLEReg :
	ds	01h
_AccGyro_INTENABLEReg_contents :
	ds	01h
_AccGYRO_Test :
	ds	01h
_AccGyro_ReadFlag :
	ds	01h
_AccGyro_ReadData :
	ds	01h
	align
_Temp_out :
	ds	04h
_Accel_SavIndex :
	ds	01h
_AccGyro_CF_FlagCounter :
	ds	01h
_CF_Accel_XRoll :
	ds	04h
_CF_Accel_YPitch :
	ds	04h
_CF_Gyro_XRoll :
	ds	04h
_CF_Gyro_YPitch :
	ds	04h
_CF_Accel_ForceMagApprox :
	ds	04h
_CF_Gyro_CurrentCount :
	ds	04h
_Gyro_Xcal :
	ds	04h
_Gyro_Ycal :
	ds	04h
_Gyro_Zcal :
	ds	04h
_HMC5883Address :
	ds	01h
_Mag_ConfigA :
	ds	01h
_Mag_ConfigA_Contents :
	ds	01h
_Mag_ConfigB :
	ds	01h
_Mag_ConfigB_Contents :
	ds	01h
_Mag_ModeReg :
	ds	01h
_Mag_ModeReg_Contents :
	ds	01h
_Mag_ReadData :
	ds	01h
_Mag_Status :
	ds	01h
	align
_Mag_Xout :
	ds	04h
_Mag_Yout :
	ds	04h
_Mag_Zout :
	ds	04h
_Mag_Angle :
	ds	04h
_Mag_GainFactor :
	ds	04h
_Mag_DeclinationAngle :
	ds	04h
_timer_us :
	ds	02h
_Ping_timer :
	ds	02h
_Ping_out :
	ds	04h
_Range_Address :
	ds	01h
_Range_TakeRangeReading :
	ds	01h
_Range_out :
	ds	02h
_MotorStep :
	ds	02h
_Mag_MotorStep :
	ds	02h
_Range_ZHiThres :
	ds	04h
_Range_ZLoThres :
	ds	04h
_Range_Ceiling :
	ds	04h
_Accel_XLoThres :
	ds	04h
_Accel_XHiThres :
	ds	04h
_Accel_YLoThres :
	ds	04h
_Accel_YHiThres :
	ds	04h
_Mag_CWThres :
	ds	04h
_Mag_CCWThres :
	ds	04h
_Mag_OpposingPole :
	ds	04h
_Mag_PIDSetpoint :
	ds	04h
_Mag_PIDCorrectionFactor :
	ds	04h
_Mag_PIDAngleScaled :
	ds	04h
_Mag_PIDError :
	ds	04h
_Mag_PIDCounter :
	ds	02h
_Mag_PIDCurrentCount :
	ds	04h
_Mag_PIDErrSum :
	ds	04h
_Mag_PIDdErr :
	ds	04h
_Mag_PIDErrPrev :
	ds	04h
_Mag_PID_kp :
	ds	04h
_Mag_PID_ki :
	ds	04h
_Mag_PID_kd :
	ds	04h
_Mag_PIDOutput :
	ds	04h
_CF_Gyro_Counter :
	ds	04h
_CF_YPitch :
	ds	04h
_CF_XRoll :
	ds	04h
_CF_HPF :
	ds	04h
_CF_LPF :
	ds	04h
_CF_UseFlag :
	ds	01h
_CF_Counter :
	ds	01h
_CF_YPitch_avg :
	ds	04h
_CF_XRoll_avg :
	ds	04h
_CF_highlow_flag :
	ds	01h
	align
_CF_YPitch_high :
	ds	04h
_CF_XRoll_high :
	ds	04h
_CF_YPitch_low :
	ds	04h
_CF_XRoll_low :
	ds	04h
_CF_avgCnt :
	ds	04h
_CF_StdDev_M_X :
	ds	04h
_CF_StdDev_M_Y :
	ds	04h
_CF_StdDev_Mtmp_X :
	ds	04h
_CF_StdDev_Mtmp_Y :
	ds	04h
_CF_StdDev_S_X :
	ds	04h
_CF_StdDev_S_Y :
	ds	04h
_CF_StdDev_K :
	ds	04h
_Accel_PID_XRollError :
	ds	04h
_Accel_PID_XRollCounter_I :
	ds	02h
_Accel_PID_XRollCounter_D :
	ds	02h
_Accel_PID_XRollErrSum :
	ds	04h
_Accel_PID_XRollErrPrev :
	ds	04h
_Accel_PID_YPitchError :
	ds	04h
_Accel_PID_YPitchCounter_I :
	ds	02h
_Accel_PID_YPitchCounter_D :
	ds	02h
_Accel_PID_YPitchErrSum :
	ds	04h
_Accel_PID_YPitchErrPrev :
	ds	04h
_Accel_PID_XRolldErr :
	ds	04h
_Accel_PID_YPitchdErr :
	ds	04h
_Accel_PID_XRoll_kp :
	ds	04h
_Accel_PID_XRoll_ki :
	ds	04h
_Accel_PID_XRoll_kd :
	ds	04h
_Accel_PID_YPitch_kp :
	ds	04h
_Accel_PID_YPitch_ki :
	ds	04h
_Accel_PID_YPitch_kd :
	ds	04h
_Accel_PID_IFlag :
	ds	01h
_Accel_PID_DFlag :
	ds	01h
_Accel_PID_XYChangeFlag :
	ds	01h
	align
_Accel_PID_Motor1 :
	ds	02h
_Accel_PID_Motor2 :
	ds	02h
_Accel_PID_Motor3 :
	ds	02h
_Accel_PID_Motor4 :
	ds	02h
_Accel_PID_GoCounter :
	ds	01h
	align
_Range_PIDSetpoint :
	ds	04h
_Range_PIDError :
	ds	04h
_Range_PIDCounter :
	ds	02h
_Range_PIDCurrentCount :
	ds	04h
_Range_PIDErrSum :
	ds	04h
_Range_PIDdErr :
	ds	04h
_Range_PIDErrPrev :
	ds	04h
_Range_PIDOutput :
	ds	04h
_Range_PID_kp :
	ds	04h
_Range_PID_ki :
	ds	04h
_Range_PID_kd :
	ds	04h
_TestingEndTimer :
	ds	02h
_Timer8Counter :
	ds	02h
_Accel_PID_PBounds_Var_Pos :
	ds	02h
_Accel_PID_DBounds_Var_Pos :
	ds	02h
_Accel_PID_PBounds_Var_Neg :
	ds	02h
_Accel_PID_DBounds_Var_Neg :
	ds	02h
_PrePIDCount :
	ds	01h
_PWMflag :
	ds	01h
_PWMUpperDutyLimitCalib :
	ds	02h
_PWMLowerDutyLimitCalib :
	ds	02h
_PWMSafeDuty :
	ds	02h
_PWMPeriod :
	ds	02h
_PWMCounter :
	ds	01h
_PWMSensorResPerInc :
	ds	01h
_PWMUpperLowerDiff :
	ds	02h
_PWMUpperDutyLimitRun :
	ds	02h
_PWMIdleDutyRun :
	ds	02h
_PWMLowerDutyLimitRun :
	ds	02h
_PWMtoRPMOffset_Mot2 :
	ds	02h
_PWMtoRPMOffset_Mot3 :
	ds	02h
_PWMtoRPMOffset_Mot4 :
	ds	02h
_$ST1 :
	ds	02h
_$ST2 :
	ds	01h
	align
_$ST3 :
	ds	04h
_$ST4 :
	ds	04h
_$ST5 :
	ds	04h
_$ST6 :
	ds	04h
_$ST7 :
	ds	04h
_$ST8 :
	ds	04h
_$ST9 :
	ds	04h
_$ST10 :
	ds	04h
_$ST11 :
	ds	04h
_$ST12 :
	ds	04h

	rseg $$NVARmain
_RecWorld :
	ds	08h
_SensorReturn :
	ds	0c8h
_Gyro_Zout :
	ds	04h
_Gyro_Yout :
	ds	04h
_NewVar_Str :
	ds	06h
_Accel_Zout_Avg :
	ds	04h
_Accel_Yout_Avg :
	ds	04h
_Accel_Xout_Avg :
	ds	04h
_NewVar :
	ds	04h
_AccGyro_Data :
	ds	0eh
_Range_Output :
	ds	02h
_Accel_Zcal :
	ds	0ch
_Accel_Xcal :
	ds	0ch
_isDemoing :
	ds	02h
_Mag_Data :
	ds	06h
_Accel_Xout :
	ds	044h
_Accel_Ycal :
	ds	0ch
_SensorReturnSM :
	ds	032h
_testI :
	ds	02h
_testD :
	ds	02h
_testP :
	ds	02h
_Accel_Yout :
	ds	044h
_Accel_Zout :
	ds	044h
_Gyro_Xout :
	ds	04h
	extrn code : __faddu8sw
	extrn code : __fsubu8sw
	extrn code : __fnegu8sw
	extrn code : __fcmpu8sw
	extrn code : __fmulu8sw
	extrn code : __fdivu8sw
	extrn code : __fildu8sw
	extrn code : __ftolu8sw
	extrn code : __ftodu8sw
	extrn code : __daddu8sw
	extrn code : __dsubu8sw
	extrn code : __dmulu8sw
	extrn code : __dildu8sw
	extrn code : __dtofu8sw
	extrn code : __fuldu8sw

	end
